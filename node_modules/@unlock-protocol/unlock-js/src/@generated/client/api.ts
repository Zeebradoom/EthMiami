/* tslint:disable */
/* eslint-disable */
/**
 * Unlock Locksmith
 * Locksmith provides backend functionality for enabling ticketing, metadata storage, and notification hooks.
 *
 * The version of the OpenAPI document: 2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {number}
     * @memberof Application
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'walletAddress'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationBody
 */
export interface ApplicationBody {
    /**
     * 
     * @type {string}
     * @memberof ApplicationBody
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationBody
     */
    'key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationBody
     */
    'walletAddress'?: string;
}
/**
 * 
 * @export
 * @interface Applications200Response
 */
export interface Applications200Response {
    /**
     * 
     * @type {Array<Application>}
     * @memberof Applications200Response
     */
    'results'?: Array<Application>;
}
/**
 * 
 * @export
 * @interface Auth
 */
export interface Auth {
    /**
     * 
     * @type {string}
     * @memberof Auth
     */
    'walletAddress': string;
}
/**
 * 
 * @export
 * @interface AuthResult
 */
export interface AuthResult {
    /**
     * 
     * @type {string}
     * @memberof AuthResult
     */
    'walletAddress': string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthResult
     */
    'accessToken': string;
}
/**
 * 
 * @export
 * @interface Balance200ResponseValue
 */
export interface Balance200ResponseValue {
    /**
     * 
     * @type {string}
     * @memberof Balance200ResponseValue
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof Balance200ResponseValue
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Balance200ResponseValue
     */
    'balance'?: string;
}
/**
 * 
 * @export
 * @interface CaptureOnRampSession200Response
 */
export interface CaptureOnRampSession200Response {
    /**
     * 
     * @type {string}
     * @memberof CaptureOnRampSession200Response
     */
    'hash'?: string;
}
/**
 * 
 * @export
 * @interface CapturePurchaseRequest
 */
export interface CapturePurchaseRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CapturePurchaseRequest
     */
    'recipients'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CapturePurchaseRequest
     */
    'network': number;
    /**
     * 
     * @type {string}
     * @memberof CapturePurchaseRequest
     */
    'lock': string;
    /**
     * 
     * @type {string}
     * @memberof CapturePurchaseRequest
     */
    'userAddress': string;
    /**
     * 
     * @type {string}
     * @memberof CapturePurchaseRequest
     */
    'paymentIntent': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CapturePurchaseRequest
     */
    'data'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CapturePurchaseRequest
     */
    'referrers'?: Array<string>;
    /**
     * whether to extend or purchase membership for the recipient.
     * @type {string}
     * @memberof CapturePurchaseRequest
     */
    'purchaseType'?: CapturePurchaseRequestPurchaseTypeEnum;
}

export const CapturePurchaseRequestPurchaseTypeEnum = {
    Extend: 'extend',
    Purchase: 'purchase'
} as const;

export type CapturePurchaseRequestPurchaseTypeEnum = typeof CapturePurchaseRequestPurchaseTypeEnum[keyof typeof CapturePurchaseRequestPurchaseTypeEnum];

/**
 * 
 * @export
 * @interface CheckClaim200Response
 */
export interface CheckClaim200Response {
    /**
     * 
     * @type {boolean}
     * @memberof CheckClaim200Response
     */
    'canClaim'?: boolean;
}
/**
 * 
 * @export
 * @interface CheckClaimRequest
 */
export interface CheckClaimRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckClaimRequest
     */
    'recipients'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckClaimRequest
     */
    'data'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CheckoutConfig
 */
export interface CheckoutConfig {
    /**
     * 
     * @type {string}
     * @memberof CheckoutConfig
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutConfig
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutConfig
     */
    'by': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CheckoutConfig
     */
    'config': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof CheckoutConfig
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutConfig
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface Claim200Response
 */
export interface Claim200Response {
    /**
     * 
     * @type {string}
     * @memberof Claim200Response
     */
    'transactionHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof Claim200Response
     */
    'owner'?: string;
}
/**
 * 
 * @export
 * @interface ClaimRequest
 */
export interface ClaimRequest {
    /**
     * 
     * @type {string}
     * @memberof ClaimRequest
     */
    'data'?: string;
    /**
     * Email address of the recipient
     * @type {string}
     * @memberof ClaimRequest
     */
    'email'?: string;
    /**
     * Recipient address for key
     * @type {string}
     * @memberof ClaimRequest
     */
    'recipient'?: string;
}
/**
 * 
 * @export
 * @interface ConnectStripeAccount200Response
 */
export interface ConnectStripeAccount200Response {
    /**
     * 
     * @type {string}
     * @memberof ConnectStripeAccount200Response
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConnectStripeAccount200Response
     */
    'created'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConnectStripeAccount200Response
     */
    'expiresAt'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConnectStripeAccount200Response
     */
    'object'?: string;
}
/**
 * 
 * @export
 * @interface ConnectStripeAccountRequest
 */
export interface ConnectStripeAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectStripeAccountRequest
     */
    'baseUrl': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectStripeAccountRequest
     */
    'stripeAccount'?: string;
}
/**
 * 
 * @export
 * @interface CreateLockContract201Response
 */
export interface CreateLockContract201Response {
    /**
     * 
     * @type {string}
     * @memberof CreateLockContract201Response
     */
    'transactionHash'?: string;
}
/**
 * 
 * @export
 * @interface CreateOnRampSessionRequest
 */
export interface CreateOnRampSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateOnRampSessionRequest
     */
    'transferSignature'?: string;
    /**
     * 
     * @type {CreateOnRampSessionRequestTransferMessage}
     * @memberof CreateOnRampSessionRequest
     */
    'transferMessage'?: CreateOnRampSessionRequestTransferMessage;
    /**
     * 
     * @type {string}
     * @memberof CreateOnRampSessionRequest
     */
    'purchaseSignature'?: string;
    /**
     * 
     * @type {CreateOnRampSessionRequestPurchaseMessage}
     * @memberof CreateOnRampSessionRequest
     */
    'purchaseMessage'?: CreateOnRampSessionRequestPurchaseMessage;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateOnRampSessionRequest
     */
    'recipients'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateOnRampSessionRequest
     */
    'purchaseData'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateOnRampSessionRequestPurchaseMessage
 */
export interface CreateOnRampSessionRequestPurchaseMessage {
    /**
     * 
     * @type {string}
     * @memberof CreateOnRampSessionRequestPurchaseMessage
     */
    'lock': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOnRampSessionRequestPurchaseMessage
     */
    'sender': string;
    /**
     * 
     * @type {number}
     * @memberof CreateOnRampSessionRequestPurchaseMessage
     */
    'expiration': number;
}
/**
 * 
 * @export
 * @interface CreateOnRampSessionRequestTransferMessage
 */
export interface CreateOnRampSessionRequestTransferMessage {
    /**
     * 
     * @type {string}
     * @memberof CreateOnRampSessionRequestTransferMessage
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOnRampSessionRequestTransferMessage
     */
    'nonce': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOnRampSessionRequestTransferMessage
     */
    'to': string;
    /**
     * 
     * @type {number}
     * @memberof CreateOnRampSessionRequestTransferMessage
     */
    'validAfter': number;
    /**
     * 
     * @type {number}
     * @memberof CreateOnRampSessionRequestTransferMessage
     */
    'validBefore': number;
    /**
     * 
     * @type {string}
     * @memberof CreateOnRampSessionRequestTransferMessage
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface CreateTransferCode200Response
 */
export interface CreateTransferCode200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateTransferCode200Response
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransferCode200Response
     */
    'lock': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTransferCode200Response
     */
    'token': string;
    /**
     * 
     * @type {number}
     * @memberof CreateTransferCode200Response
     */
    'deadline': number;
    /**
     * Part of the transfer code that is required to be used with the part sent to the recipient.
     * @type {string}
     * @memberof CreateTransferCode200Response
     */
    'transferCode': string;
}
/**
 * 
 * @export
 * @interface CreateTransferCode404Response
 */
export interface CreateTransferCode404Response {
    /**
     * 
     * @type {string}
     * @memberof CreateTransferCode404Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DeleteCheckoutConfig200Response
 */
export interface DeleteCheckoutConfig200Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteCheckoutConfig200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface EmailTicket200Response
 */
export interface EmailTicket200Response {
    /**
     * 
     * @type {boolean}
     * @memberof EmailTicket200Response
     */
    'sent'?: boolean;
}
/**
 * 
 * @export
 * @interface EventDetails
 */
export interface EventDetails {
    /**
     * 
     * @type {string}
     * @memberof EventDetails
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDetails
     */
    'eventDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDetails
     */
    'eventDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDetails
     */
    'eventTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDetails
     */
    'eventAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDetails
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDetails
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface GenericInvalidBodyError
 */
export interface GenericInvalidBodyError {
    /**
     * 
     * @type {string}
     * @memberof GenericInvalidBodyError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericInvalidBodyError
     */
    'error'?: string | null;
}
/**
 * 
 * @export
 * @interface GenericNotFound
 */
export interface GenericNotFound {
    /**
     * 
     * @type {string}
     * @memberof GenericNotFound
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GenericServerError
 */
export interface GenericServerError {
    /**
     * 
     * @type {string}
     * @memberof GenericServerError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GenericSuccess
 */
export interface GenericSuccess {
    /**
     * 
     * @type {string}
     * @memberof GenericSuccess
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetChargesForLock200Response
 */
export interface GetChargesForLock200Response {
    /**
     * 
     * @type {number}
     * @memberof GetChargesForLock200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof GetChargesForLock200Response
     */
    'creditCardProcessingFee'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetChargesForLock200Response
     */
    'unlockServiceFee': number;
    /**
     * 
     * @type {number}
     * @memberof GetChargesForLock200Response
     */
    'gasCost': number;
    /**
     * 
     * @type {Array<GetChargesForLock200ResponsePricesInner>}
     * @memberof GetChargesForLock200Response
     */
    'prices'?: Array<GetChargesForLock200ResponsePricesInner>;
}
/**
 * 
 * @export
 * @interface GetChargesForLock200ResponsePricesInner
 */
export interface GetChargesForLock200ResponsePricesInner {
    /**
     * 
     * @type {string}
     * @memberof GetChargesForLock200ResponsePricesInner
     */
    'userAddress': string;
    /**
     * 
     * @type {string}
     * @memberof GetChargesForLock200ResponsePricesInner
     */
    'amount': string;
    /**
     * 
     * @type {string}
     * @memberof GetChargesForLock200ResponsePricesInner
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface GetCustomEmailContent200Response
 */
export interface GetCustomEmailContent200Response {
    /**
     * 
     * @type {string}
     * @memberof GetCustomEmailContent200Response
     */
    'lockAddress'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetCustomEmailContent200Response
     */
    'network'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetCustomEmailContent200Response
     */
    'template'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomEmailContent200Response
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface GetDataForRecipientsAndGuild200Response
 */
export interface GetDataForRecipientsAndGuild200Response {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetDataForRecipientsAndGuild200Response
     */
    'result'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetLockStripeConnectionDetails200Response
 */
export interface GetLockStripeConnectionDetails200Response {
    /**
     * 
     * @type {GetLockStripeConnectionDetails200ResponseCountrySpec}
     * @memberof GetLockStripeConnectionDetails200Response
     */
    'countrySpec'?: GetLockStripeConnectionDetails200ResponseCountrySpec;
    /**
     * 
     * @type {GetLockStripeConnectionDetails200ResponseAccount}
     * @memberof GetLockStripeConnectionDetails200Response
     */
    'account'?: GetLockStripeConnectionDetails200ResponseAccount;
    /**
     * 
     * @type {number}
     * @memberof GetLockStripeConnectionDetails200Response
     */
    'connected'?: number;
}
/**
 * 
 * @export
 * @interface GetLockStripeConnectionDetails200ResponseAccount
 */
export interface GetLockStripeConnectionDetails200ResponseAccount {
    /**
     * 
     * @type {string}
     * @memberof GetLockStripeConnectionDetails200ResponseAccount
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetLockStripeConnectionDetails200ResponseAccount
     */
    'charges_enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetLockStripeConnectionDetails200ResponseAccount
     */
    'payouts_enabled'?: boolean;
    /**
     * 
     * @type {GetLockStripeConnectionDetails200ResponseAccountRequirements}
     * @memberof GetLockStripeConnectionDetails200ResponseAccount
     */
    'requirements'?: GetLockStripeConnectionDetails200ResponseAccountRequirements;
}
/**
 * 
 * @export
 * @interface GetLockStripeConnectionDetails200ResponseAccountRequirements
 */
export interface GetLockStripeConnectionDetails200ResponseAccountRequirements {
    /**
     * 
     * @type {string}
     * @memberof GetLockStripeConnectionDetails200ResponseAccountRequirements
     */
    'disabled_reason'?: string;
}
/**
 * 
 * @export
 * @interface GetLockStripeConnectionDetails200ResponseCountrySpec
 */
export interface GetLockStripeConnectionDetails200ResponseCountrySpec {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetLockStripeConnectionDetails200ResponseCountrySpec
     */
    'supported_payment_currencies'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetReceipt200Response
 */
export interface GetReceipt200Response {
    /**
     * 
     * @type {GetReceipt200ResponsePurchaser}
     * @memberof GetReceipt200Response
     */
    'purchaser'?: GetReceipt200ResponsePurchaser;
    /**
     * 
     * @type {GetReceipt200ResponseSupplier}
     * @memberof GetReceipt200Response
     */
    'supplier'?: GetReceipt200ResponseSupplier;
    /**
     * 
     * @type {GetReceipt200ResponseReceipt}
     * @memberof GetReceipt200Response
     */
    'receipt'?: GetReceipt200ResponseReceipt;
}
/**
 * 
 * @export
 * @interface GetReceipt200ResponsePurchaser
 */
export interface GetReceipt200ResponsePurchaser {
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'fullname'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'businessName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'addressLine1'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'zip'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface GetReceipt200ResponseReceipt
 */
export interface GetReceipt200ResponseReceipt {
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponseReceipt
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetReceipt200ResponseReceipt
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponseReceipt
     */
    'sender'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponseReceipt
     */
    'payer'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponseReceipt
     */
    'lockAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponseReceipt
     */
    'tokenAddress'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetReceipt200ResponseReceipt
     */
    'gasTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetReceipt200ResponseReceipt
     */
    'amountTransferred'?: number;
}
/**
 * 
 * @export
 * @interface GetReceipt200ResponseSupplier
 */
export interface GetReceipt200ResponseSupplier {
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'supplierName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'vat'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'servicePerformed'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'addressLine1'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'zip'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface GetReceipts200Response
 */
export interface GetReceipts200Response {
    /**
     * 
     * @type {Array<GetReceipts200ResponseItemsInner>}
     * @memberof GetReceipts200Response
     */
    'items'?: Array<GetReceipts200ResponseItemsInner>;
}
/**
 * 
 * @export
 * @interface GetReceipts200ResponseItemsInner
 */
export interface GetReceipts200ResponseItemsInner {
    /**
     * 
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'receiptNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'sender'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'payer'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'lockAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'tokenAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'gasTotal'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'amountTransferred'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'network'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'supplierAddress'?: string;
}
/**
 * 
 * @export
 * @interface GetReceiptsBase200Response
 */
export interface GetReceiptsBase200Response {
    /**
     * 
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'supplierName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'vat'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetReceiptsBase200Response
     */
    'vatBasisPointsRate'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'servicePerformed'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'addressLine1'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'zip'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface GetStripeConnections200Response
 */
export interface GetStripeConnections200Response {
    /**
     * 
     * @type {Array<object>}
     * @memberof GetStripeConnections200Response
     */
    'result'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof GetStripeConnections200Response
     */
    'error'?: string | null;
}
/**
 * 
 * @export
 * @interface GetSubscription200Response
 */
export interface GetSubscription200Response {
    /**
     * 
     * @type {Array<GetSubscription200ResponseSubscriptionsInner>}
     * @memberof GetSubscription200Response
     */
    'subscriptions'?: Array<GetSubscription200ResponseSubscriptionsInner>;
}
/**
 * 
 * @export
 * @interface GetSubscription200ResponseSubscriptionsInner
 */
export interface GetSubscription200ResponseSubscriptionsInner {
    /**
     * 
     * @type {number}
     * @memberof GetSubscription200ResponseSubscriptionsInner
     */
    'next'?: number | null;
    /**
     * 
     * @type {GetSubscription200ResponseSubscriptionsInnerBalance}
     * @memberof GetSubscription200ResponseSubscriptionsInner
     */
    'balance'?: GetSubscription200ResponseSubscriptionsInnerBalance;
    /**
     * 
     * @type {GetSubscription200ResponseSubscriptionsInnerBalance}
     * @memberof GetSubscription200ResponseSubscriptionsInner
     */
    'price'?: GetSubscription200ResponseSubscriptionsInnerBalance;
    /**
     * Approved number of renewals by user.
     * @type {string}
     * @memberof GetSubscription200ResponseSubscriptionsInner
     */
    'approvedRenewals'?: string;
    /**
     * Possible number of renewals based on the user account balance.
     * @type {string}
     * @memberof GetSubscription200ResponseSubscriptionsInner
     */
    'possibleRenewals'?: string;
    /**
     * The type of payment method used for the subscription.
     * @type {string}
     * @memberof GetSubscription200ResponseSubscriptionsInner
     */
    'type'?: GetSubscription200ResponseSubscriptionsInnerTypeEnum;
}

export const GetSubscription200ResponseSubscriptionsInnerTypeEnum = {
    Crypto: 'crypto',
    Fiat: 'fiat'
} as const;

export type GetSubscription200ResponseSubscriptionsInnerTypeEnum = typeof GetSubscription200ResponseSubscriptionsInnerTypeEnum[keyof typeof GetSubscription200ResponseSubscriptionsInnerTypeEnum];

/**
 * 
 * @export
 * @interface GetSubscription200ResponseSubscriptionsInnerBalance
 */
export interface GetSubscription200ResponseSubscriptionsInnerBalance {
    /**
     * 
     * @type {string}
     * @memberof GetSubscription200ResponseSubscriptionsInnerBalance
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSubscription200ResponseSubscriptionsInnerBalance
     */
    'amount'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetSubscription200ResponseSubscriptionsInnerBalance
     */
    'decimals'?: number;
}
/**
 * 
 * @export
 * @interface GetTicket200Response
 */
export interface GetTicket200Response {
    /**
     * 
     * @type {string}
     * @memberof GetTicket200Response
     */
    'keyId': string;
    /**
     * 
     * @type {string}
     * @memberof GetTicket200Response
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetTicket200Response
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof GetTicket200Response
     */
    'manager': string;
    /**
     * 
     * @type {string}
     * @memberof GetTicket200Response
     */
    'lockAddress': string;
    /**
     * 
     * @type {string}
     * @memberof GetTicket200Response
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof GetTicket200Response
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof GetTicket200Response
     */
    'checkedInAt'?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof GetTicket200Response
     */
    'userMetadata': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof GetTicket200Response
     */
    'expiration': string;
    /**
     * 
     * @type {Array<GetTicket200ResponseAttributesInner>}
     * @memberof GetTicket200Response
     */
    'attributes': Array<GetTicket200ResponseAttributesInner>;
    /**
     * 
     * @type {string}
     * @memberof GetTicket200Response
     */
    'publicLockVersion': string;
    /**
     * Whether the user who requested the ticket can verify the ticket.
     * @type {boolean}
     * @memberof GetTicket200Response
     */
    'isVerifier': boolean;
}
/**
 * 
 * @export
 * @interface GetTicket200ResponseAttributesInner
 */
export interface GetTicket200ResponseAttributesInner {
    /**
     * 
     * @type {string}
     * @memberof GetTicket200ResponseAttributesInner
     */
    'trait_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTicket200ResponseAttributesInner
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof GetTicket200ResponseAttributesInner
     */
    'display_type'?: string;
}
/**
 * 
 * @export
 * @interface GetTotalPrice200Response
 */
export interface GetTotalPrice200Response {
    /**
     * 
     * @type {number}
     * @memberof GetTotalPrice200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof GetTotalPrice200Response
     */
    'subtotal': number;
    /**
     * 
     * @type {number}
     * @memberof GetTotalPrice200Response
     */
    'gasCost': number;
    /**
     * 
     * @type {number}
     * @memberof GetTotalPrice200Response
     */
    'unlockServiceFee': number;
    /**
     * 
     * @type {number}
     * @memberof GetTotalPrice200Response
     */
    'creditCardProcessingFee': number;
    /**
     * 
     * @type {boolean}
     * @memberof GetTotalPrice200Response
     */
    'isCreditCardPurchasable': boolean;
}
/**
 * 
 * @export
 * @interface IsCardPaymentEnabledForLock200Response
 */
export interface IsCardPaymentEnabledForLock200Response {
    /**
     * 
     * @type {boolean}
     * @memberof IsCardPaymentEnabledForLock200Response
     */
    'creditCardEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface KeyMetadata
 */
export interface KeyMetadata {
    /**
     * 
     * @type {string}
     * @memberof KeyMetadata
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeyMetadata
     */
    'lockName'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeyMetadata
     */
    'lockAddress'?: string;
    /**
     * 
     * @type {number}
     * @memberof KeyMetadata
     */
    'expiration'?: number;
    /**
     * 
     * @type {string}
     * @memberof KeyMetadata
     */
    'keyHolderAddress'?: string;
}
/**
 * 
 * @export
 * @interface KeyMetadata200Response
 */
export interface KeyMetadata200Response {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof KeyMetadata200Response
     */
    'keyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof KeyMetadata200Response
     */
    'lockAddress'?: string;
    /**
     * 
     * @type {number}
     * @memberof KeyMetadata200Response
     */
    'network'?: number;
}
/**
 * 
 * @export
 * @interface ListCheckoutConfigs200Response
 */
export interface ListCheckoutConfigs200Response {
    /**
     * 
     * @type {Array<CheckoutConfig>}
     * @memberof ListCheckoutConfigs200Response
     */
    'results'?: Array<CheckoutConfig>;
}
/**
 * 
 * @export
 * @interface ListPaymentMethods200Response
 */
export interface ListPaymentMethods200Response {
    /**
     * 
     * @type {Array<PaymentMethod>}
     * @memberof ListPaymentMethods200Response
     */
    'methods'?: Array<PaymentMethod>;
}
/**
 * 
 * @export
 * @interface LockContractOptions
 */
export interface LockContractOptions {
    /**
     * 
     * @type {string}
     * @memberof LockContractOptions
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof LockContractOptions
     */
    'expirationDuration'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LockContractOptions
     */
    'maxNumberOfKeys'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LockContractOptions
     */
    'keyPrice'?: string;
    /**
     * 
     * @type {string}
     * @memberof LockContractOptions
     */
    'creator'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LockContractOptions
     */
    'currencyContractAddress'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof LockContractOptions
     */
    'publicLockVersion'?: number | null;
}
/**
 * 
 * @export
 * @interface LockSettings
 */
export interface LockSettings {
    /**
     * 
     * @type {string}
     * @memberof LockSettings
     */
    'lockAddress'?: string;
    /**
     * 
     * @type {number}
     * @memberof LockSettings
     */
    'network'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LockSettings
     */
    'sendEmail'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LockSettings
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof LockSettings
     */
    'replyTo'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof LockSettings
     */
    'creditCardPrice'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof LockSettings
     */
    'emailSender'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LockSettings
     */
    'checkoutConfigId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LockSettings
     */
    'hookGuildId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof LockSettings
     */
    'unlockFeeChargedToUser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LockSettings
     */
    'creditCardCurrency'?: string;
    /**
     * 
     * @type {string}
     * @memberof LockSettings
     */
    'crossmintClientId'?: string | null;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface NotAuthenticated
 */
export interface NotAuthenticated {
    /**
     * 
     * @type {string}
     * @memberof NotAuthenticated
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethod
 */
export interface PaymentMethod {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'object'?: string;
    /**
     * 
     * @type {PaymentMethodBillingDetails}
     * @memberof PaymentMethod
     */
    'billing_details'?: PaymentMethodBillingDetails;
    /**
     * 
     * @type {PaymentMethodCard}
     * @memberof PaymentMethod
     */
    'card'?: PaymentMethodCard;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethod
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'customer'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PaymentMethod
     */
    'metadata'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethodBillingDetails
 */
export interface PaymentMethodBillingDetails {
    /**
     * 
     * @type {PaymentMethodBillingDetailsAddress}
     * @memberof PaymentMethodBillingDetails
     */
    'address'?: PaymentMethodBillingDetailsAddress;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodBillingDetails
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodBillingDetails
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodBillingDetails
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethodBillingDetailsAddress
 */
export interface PaymentMethodBillingDetailsAddress {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'line1'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'line2'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'postal_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethodCard
 */
export interface PaymentMethodCard {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'brand'?: string;
    /**
     * 
     * @type {PaymentMethodCardChecks}
     * @memberof PaymentMethodCard
     */
    'checks'?: PaymentMethodCardChecks;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'country'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodCard
     */
    'exp_month'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethodCard
     */
    'exp_year'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'funding'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'generated_from'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'last4'?: string;
    /**
     * 
     * @type {PaymentMethodCardNetworks}
     * @memberof PaymentMethodCard
     */
    'networks'?: PaymentMethodCardNetworks;
    /**
     * 
     * @type {PaymentMethodCardThreeDSecureUsage}
     * @memberof PaymentMethodCard
     */
    'three_d_secure_usage'?: PaymentMethodCardThreeDSecureUsage;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'wallet'?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethodCardChecks
 */
export interface PaymentMethodCardChecks {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardChecks
     */
    'address_line1_check'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardChecks
     */
    'address_postal_code_check'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardChecks
     */
    'cvc_check'?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethodCardNetworks
 */
export interface PaymentMethodCardNetworks {
    /**
     * 
     * @type {Array<string>}
     * @memberof PaymentMethodCardNetworks
     */
    'available'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodCardNetworks
     */
    'preferred'?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethodCardThreeDSecureUsage
 */
export interface PaymentMethodCardThreeDSecureUsage {
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodCardThreeDSecureUsage
     */
    'supported'?: boolean;
}
/**
 * 
 * @export
 * @interface Price200Response
 */
export interface Price200Response {
    /**
     * 
     * @type {Price200ResponseResult}
     * @memberof Price200Response
     */
    'result'?: Price200ResponseResult;
}
/**
 * 
 * @export
 * @interface Price200ResponseResult
 */
export interface Price200ResponseResult {
    /**
     * 
     * @type {number}
     * @memberof Price200ResponseResult
     */
    'decimals'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Price200ResponseResult
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof Price200ResponseResult
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof Price200ResponseResult
     */
    'symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof Price200ResponseResult
     */
    'confidence'?: number;
    /**
     * 
     * @type {number}
     * @memberof Price200ResponseResult
     */
    'priceInAmount'?: number | null;
}
/**
 * 
 * @export
 * @interface Purchase200Response
 */
export interface Purchase200Response {
    /**
     * 
     * @type {string}
     * @memberof Purchase200Response
     */
    'clientSecret'?: string;
    /**
     * 
     * @type {string}
     * @memberof Purchase200Response
     */
    'stripeAccount'?: string;
    /**
     * 
     * @type {number}
     * @memberof Purchase200Response
     */
    'totalPriceInDents'?: number;
    /**
     * 
     * @type {Purchase200ResponsePricing}
     * @memberof Purchase200Response
     */
    'pricing'?: Purchase200ResponsePricing | null;
}
/**
 * 
 * @export
 * @interface Purchase200ResponsePricing
 */
export interface Purchase200ResponsePricing {
    /**
     * 
     * @type {number}
     * @memberof Purchase200ResponsePricing
     */
    'keyPrice'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Purchase200ResponsePricing
     */
    'unlockServiceFee'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Purchase200ResponsePricing
     */
    'creditCardProcessing'?: number | null;
}
/**
 * 
 * @export
 * @interface PurchaseRequest
 */
export interface PurchaseRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof PurchaseRequest
     */
    'recipients': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PurchaseRequest
     */
    'stripeTokenId': string;
    /**
     * 
     * @type {number}
     * @memberof PurchaseRequest
     */
    'pricing': number;
    /**
     * 
     * @type {number}
     * @memberof PurchaseRequest
     */
    'recurring'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PurchaseRequest
     */
    'data'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PurchaseRequest
     */
    'referrers'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RemovePaymentMethods200Response
 */
export interface RemovePaymentMethods200Response {
    /**
     * 
     * @type {boolean}
     * @memberof RemovePaymentMethods200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface SaveEventDataRequest
 */
export interface SaveEventDataRequest {
    /**
     * 
     * @type {number}
     * @memberof SaveEventDataRequest
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SaveEventDataRequest
     */
    'name'?: string;
    /**
     * 
     * @type {object}
     * @memberof SaveEventDataRequest
     */
    'data'?: object;
    /**
     * 
     * @type {Array<string>}
     * @memberof SaveEventDataRequest
     */
    'locks'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SaveLockSetting200Response
 */
export interface SaveLockSetting200Response {
    /**
     * 
     * @type {boolean}
     * @memberof SaveLockSetting200Response
     */
    'sendEmail'?: boolean;
}
/**
 * 
 * @export
 * @interface SaveReceipt200Response
 */
export interface SaveReceipt200Response {
    /**
     * 
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'fullname'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'businessName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'addressLine1'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'addressLine2'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'zip'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface SendCustomEmail200Response
 */
export interface SendCustomEmail200Response {
    /**
     * 
     * @type {boolean}
     * @memberof SendCustomEmail200Response
     */
    'sent'?: boolean;
}
/**
 * 
 * @export
 * @interface SendCustomEmailRequest
 */
export interface SendCustomEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof SendCustomEmailRequest
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof SendCustomEmailRequest
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface SetupPayment200Response
 */
export interface SetupPayment200Response {
    /**
     * 
     * @type {string}
     * @memberof SetupPayment200Response
     */
    'clientSecret'?: string;
}
/**
 * 
 * @export
 * @interface SignTicket200Response
 */
export interface SignTicket200Response {
    /**
     * 
     * @type {string}
     * @memberof SignTicket200Response
     */
    'payload'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignTicket200Response
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface TicketVerificationUrl200Response
 */
export interface TicketVerificationUrl200Response {
    /**
     * 
     * @type {string}
     * @memberof TicketVerificationUrl200Response
     */
    'verificationUrl'?: string;
}
/**
 * 
 * @export
 * @interface TransferDoneRequest
 */
export interface TransferDoneRequest {
    /**
     * The signature of the transfer code sent to the recipient.
     * @type {string}
     * @memberof TransferDoneRequest
     */
    'transferSignature': string;
    /**
     * 
     * @type {string}
     * @memberof TransferDoneRequest
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof TransferDoneRequest
     */
    'lock': string;
    /**
     * 
     * @type {string}
     * @memberof TransferDoneRequest
     */
    'token': string;
    /**
     * 
     * @type {number}
     * @memberof TransferDoneRequest
     */
    'network': number;
    /**
     * 
     * @type {number}
     * @memberof TransferDoneRequest
     */
    'deadline': number;
}
/**
 * 
 * @export
 * @interface UpdateCheckoutConfigRequest
 */
export interface UpdateCheckoutConfigRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCheckoutConfigRequest
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UpdateCheckoutConfigRequest
     */
    'config': { [key: string]: any; };
}
/**
 * JSON metadata inside metadata field will be saved.
 * @export
 * @interface UpdateLockMetadataRequest
 */
export interface UpdateLockMetadataRequest {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UpdateLockMetadataRequest
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UpdateUserMetadataRequest
 */
export interface UpdateUserMetadataRequest {
    /**
     * 
     * @type {UserMetadataInput}
     * @memberof UpdateUserMetadataRequest
     */
    'metadata'?: UserMetadataInput;
}
/**
 * 
 * @export
 * @interface UpdateUsersMetadata201Response
 */
export interface UpdateUsersMetadata201Response {
    /**
     * 
     * @type {Array<UserMetadata>}
     * @memberof UpdateUsersMetadata201Response
     */
    'result'?: Array<UserMetadata>;
    /**
     * Array containing user addresses for which metadata was not created.
     * @type {Array<string>}
     * @memberof UpdateUsersMetadata201Response
     */
    'error'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateUsersMetadataRequest
 */
export interface UpdateUsersMetadataRequest {
    /**
     * 
     * @type {Array<UserMetadata>}
     * @memberof UpdateUsersMetadataRequest
     */
    'users'?: Array<UserMetadata>;
}
/**
 * 
 * @export
 * @interface UploadImages201Response
 */
export interface UploadImages201Response {
    /**
     * 
     * @type {Array<UploadImages201ResponseResultsInner>}
     * @memberof UploadImages201Response
     */
    'results'?: Array<UploadImages201ResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface UploadImages201ResponseResultsInner
 */
export interface UploadImages201ResponseResultsInner {
    /**
     * 
     * @type {string}
     * @memberof UploadImages201ResponseResultsInner
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadImages201ResponseResultsInner
     */
    'publicUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadImages201ResponseResultsInner
     */
    'originamName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadImages201ResponseResultsInner
     */
    'mimetype'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadImages201ResponseResultsInner
     */
    'contentType'?: string;
    /**
     * 
     * @type {number}
     * @memberof UploadImages201ResponseResultsInner
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof UploadImages201ResponseResultsInner
     */
    'key'?: string;
    /**
     * 
     * @type {UploadImages201ResponseResultsInnerMetadata}
     * @memberof UploadImages201ResponseResultsInner
     */
    'metadata'?: UploadImages201ResponseResultsInnerMetadata;
    /**
     * 
     * @type {string}
     * @memberof UploadImages201ResponseResultsInner
     */
    'encoding'?: string;
}
/**
 * 
 * @export
 * @interface UploadImages201ResponseResultsInnerMetadata
 */
export interface UploadImages201ResponseResultsInnerMetadata {
    /**
     * 
     * @type {string}
     * @memberof UploadImages201ResponseResultsInnerMetadata
     */
    'fieldName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadImages201ResponseResultsInnerMetadata
     */
    'createdBy'?: string;
}
/**
 * 
 * @export
 * @interface UserMetadata
 */
export interface UserMetadata {
    /**
     * 
     * @type {number}
     * @memberof UserMetadata
     */
    'network': number;
    /**
     * 
     * @type {string}
     * @memberof UserMetadata
     */
    'lockAddress': string;
    /**
     * 
     * @type {string}
     * @memberof UserMetadata
     */
    'userAddress': string;
    /**
     * 
     * @type {UserMetadataInput}
     * @memberof UserMetadata
     */
    'metadata': UserMetadataInput;
}
/**
 * 
 * @export
 * @interface UserMetadataInput
 */
export interface UserMetadataInput {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UserMetadataInput
     */
    'public'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UserMetadataInput
     */
    'protected'?: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface Verifier
 */
export interface Verifier {
    /**
     * 
     * @type {string}
     * @memberof Verifier
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof Verifier
     */
    'lockAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof Verifier
     */
    'lockManager'?: string;
    /**
     * 
     * @type {number}
     * @memberof Verifier
     */
    'network'?: number;
}
/**
 * 
 * @export
 * @interface Verifier200Response
 */
export interface Verifier200Response {
    /**
     * 
     * @type {boolean}
     * @memberof Verifier200Response
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface Verifiers200Response
 */
export interface Verifiers200Response {
    /**
     * 
     * @type {Array<Verifier>}
     * @memberof Verifiers200Response
     */
    'results'?: Array<Verifier>;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List applications created the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applications: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/applications/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balance: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/purchase`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a fiat subscription.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription: async (network: number, lockAddress: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('cancelSubscription', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('cancelSubscription', 'lockAddress', lockAddress)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('cancelSubscription', 'keyId', keyId)
            const localVarPath = `/v2/subscriptions/{network}/locks/{lockAddress}/keys/{keyId}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Setup an onramp session for the user.
         * @param {string} session The id of the onramp session
         * @param {string} transactionHash The transacttion hash for the deposit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureOnRampSession: async (session: string, transactionHash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('captureOnRampSession', 'session', session)
            // verify required parameter 'transactionHash' is not null or undefined
            assertParamExists('captureOnRampSession', 'transactionHash', transactionHash)
            const localVarPath = `/v2/purchase/onramp/{session}/capture`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (transactionHash !== undefined) {
                localVarQueryParameter['transactionHash'] = transactionHash;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Capture a purchase
         * @param {CapturePurchaseRequest} [capturePurchaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturePurchase: async (capturePurchaseRequest?: CapturePurchaseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/purchase/capture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(capturePurchaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if claim is possible for a given purchase
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {CheckClaimRequest} [checkClaimRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkClaim: async (network: number, lockAddress: string, checkClaimRequest?: CheckClaimRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('checkClaim', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('checkClaim', 'lockAddress', lockAddress)
            const localVarPath = `/claim/{network}/locks/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkClaimRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark a ticket as checked in.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkTicket: async (network: number, lockAddress: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('checkTicket', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('checkTicket', 'lockAddress', lockAddress)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('checkTicket', 'keyId', keyId)
            const localVarPath = `/v2/api/ticket/{network}/lock/{lockAddress}/key/{keyId}/check`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Claim a membership key for a lock. If not authenticated, requires an email in the body.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} captcha Recaptcha value to pass.
         * @param {ClaimRequest} claimRequest 
         * @param {string} [recipient] Recipient address for key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claim: async (network: number, lockAddress: string, captcha: string, claimRequest: ClaimRequest, recipient?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('claim', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('claim', 'lockAddress', lockAddress)
            // verify required parameter 'captcha' is not null or undefined
            assertParamExists('claim', 'captcha', captcha)
            // verify required parameter 'claimRequest' is not null or undefined
            assertParamExists('claim', 'claimRequest', claimRequest)
            const localVarPath = `/v2/claim/{network}/locks/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (captcha !== undefined && captcha !== null) {
                localVarHeaderParameter['captcha'] = String(captcha);
            }

            if (recipient !== undefined && recipient !== null) {
                localVarHeaderParameter['recipient'] = String(recipient);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(claimRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Connect a stripe account to a lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {ConnectStripeAccountRequest} [connectStripeAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectStripeAccount: async (network: number, lockAddress: string, connectStripeAccountRequest?: ConnectStripeAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('connectStripeAccount', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('connectStripeAccount', 'lockAddress', lockAddress)
            const localVarPath = `/v2/stripe/connect/{network}/locks/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectStripeAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create application associated with user wallet.
         * @param {ApplicationBody} applicationBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (applicationBody: ApplicationBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationBody' is not null or undefined
            assertParamExists('createApplication', 'applicationBody', applicationBody)
            const localVarPath = `/v2/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} network Network id.
         * @param {string} captcha Recaptcha value to pass.
         * @param {LockContractOptions} lockContractOptions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLockContract: async (network: number, captcha: string, lockContractOptions: LockContractOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('createLockContract', 'network', network)
            // verify required parameter 'captcha' is not null or undefined
            assertParamExists('createLockContract', 'captcha', captcha)
            // verify required parameter 'lockContractOptions' is not null or undefined
            assertParamExists('createLockContract', 'lockContractOptions', lockContractOptions)
            const localVarPath = `/v2/api/contracts/{network}/lock`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            await setApiKeyToObject(localVarQueryParameter, "api-key", configuration)

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (captcha !== undefined && captcha !== null) {
                localVarHeaderParameter['captcha'] = String(captcha);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lockContractOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Setup an onramp session for the user.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {CreateOnRampSessionRequest} createOnRampSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOnRampSession: async (network: number, lockAddress: string, createOnRampSessionRequest: CreateOnRampSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('createOnRampSession', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('createOnRampSession', 'lockAddress', lockAddress)
            // verify required parameter 'createOnRampSessionRequest' is not null or undefined
            assertParamExists('createOnRampSession', 'createOnRampSessionRequest', createOnRampSessionRequest)
            const localVarPath = `/v2/purchase/onramp/{network}/locks/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOnRampSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a transfer code to transfer an airdropped key to an email address.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransferCode: async (network: number, lockAddress: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('createTransferCode', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('createTransferCode', 'lockAddress', lockAddress)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('createTransferCode', 'keyId', keyId)
            const localVarPath = `/v2/transfer/{network}/locks/{lockAddress}/keys/{keyId}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create verifier.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} verifierAddress User address to use as verifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVerifier: async (network: number, lockAddress: string, verifierAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('createVerifier', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('createVerifier', 'lockAddress', lockAddress)
            // verify required parameter 'verifierAddress' is not null or undefined
            assertParamExists('createVerifier', 'verifierAddress', verifierAddress)
            const localVarPath = `/v2/api/verifier/{network}/{lockAddress}/{verifierAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"verifierAddress"}}`, encodeURIComponent(String(verifierAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete application by id.
         * @param {string} id Application id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApplication', 'id', id)
            const localVarPath = `/v2/applications/:id`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a checkout config
         * @param {string} id The id of the checkout config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCheckoutConfig: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCheckoutConfig', 'id', id)
            const localVarPath = `/v2/checkout/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove verifier.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} verifierAddress User address to use as verifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVerifier: async (network: number, lockAddress: string, verifierAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('deleteVerifier', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('deleteVerifier', 'lockAddress', lockAddress)
            // verify required parameter 'verifierAddress' is not null or undefined
            assertParamExists('deleteVerifier', 'verifierAddress', verifierAddress)
            const localVarPath = `/v2/api/verifier/{network}/{lockAddress}/{verifierAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"verifierAddress"}}`, encodeURIComponent(String(verifierAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disconnect stripe account.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectStripe: async (network: number, lockAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('disconnectStripe', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('disconnectStripe', 'lockAddress', lockAddress)
            const localVarPath = `/{network}/lock/{lockAddress}/stripe`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send QR code by email.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailTicket: async (network: number, lockAddress: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('emailTicket', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('emailTicket', 'lockAddress', lockAddress)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('emailTicket', 'keyId', keyId)
            const localVarPath = `/v2/api/ticket/{network}/{lockAddress}/{keyId}/email`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate certificate for specific key
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCertificate: async (network: number, lockAddress: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('generateCertificate', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('generateCertificate', 'lockAddress', lockAddress)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('generateCertificate', 'keyId', keyId)
            const localVarPath = `/v2/certificate/{network}/lock/{lockAddress}/key/{keyId}/generate`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a ticket for a key.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTicket: async (network: number, lockAddress: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('generateTicket', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('generateTicket', 'lockAddress', lockAddress)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('generateTicket', 'keyId', keyId)
            const localVarPath = `/v2/api/ticket/{network}/lock/{lockAddress}/key/{keyId}/generate`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the price breakdown for recipients & total charges with fees for a specific lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {Array<string>} purchaseData The purchase data passed to the purchase function
         * @param {Array<string>} recipients The recipients passed to the purchase function
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargesForLock: async (network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getChargesForLock', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('getChargesForLock', 'lockAddress', lockAddress)
            // verify required parameter 'purchaseData' is not null or undefined
            assertParamExists('getChargesForLock', 'purchaseData', purchaseData)
            // verify required parameter 'recipients' is not null or undefined
            assertParamExists('getChargesForLock', 'recipients', recipients)
            const localVarPath = `/v2/api/charges/{network}/locks/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (purchaseData) {
                localVarQueryParameter['purchaseData[]'] = purchaseData;
            }

            if (recipients) {
                localVarQueryParameter['recipients[]'] = recipients;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The id of the checkout config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckoutConfig: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCheckoutConfig', 'id', id)
            const localVarPath = `/v2/checkout/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get custom email content for a specific template and lock details
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} template Template id for email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomEmailContent: async (network: number, lockAddress: string, template: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getCustomEmailContent', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('getCustomEmailContent', 'lockAddress', lockAddress)
            // verify required parameter 'template' is not null or undefined
            assertParamExists('getCustomEmailContent', 'template', template)
            const localVarPath = `/v2/email/{network}/locks/{lockAddress}/custom/{template}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"template"}}`, encodeURIComponent(String(template)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the data for recipients and guild. This is to be used in conjunction with the Guild
         * @param {number} network The network the lock is on
         * @param {string} [lockAddress] The address of the lock
         * @param {Array<string>} [recipients] The list of recipients for the purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataForRecipientsAndGuild: async (network: number, lockAddress?: string, recipients?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getDataForRecipientsAndGuild', 'network', network)
            const localVarPath = `/v2/hooks/guild`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (network !== undefined) {
                localVarQueryParameter['network'] = network;
            }

            if (lockAddress !== undefined) {
                localVarQueryParameter['lockAddress'] = lockAddress;
            }

            if (recipients) {
                localVarQueryParameter['recipients'] = recipients;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the event details from lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDetails: async (network: number, lockAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getEventDetails', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('getEventDetails', 'lockAddress', lockAddress)
            const localVarPath = `/v2/events/{network}/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get saved lock settings
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLockSettings: async (network: number, lockAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getLockSettings', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('getLockSettings', 'lockAddress', lockAddress)
            const localVarPath = `/v2/lock-settings/{network}/locks/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get lock setting by slug
         * @param {string} slug Slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLockSettingsBySlug: async (slug: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('getLockSettingsBySlug', 'slug', slug)
            const localVarPath = `/v2/lock-settings/slug/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Stripe connection details
         * @param {string} lockAddress Lock address.
         * @param {number} chain Lock network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLockStripeConnectionDetails: async (lockAddress: string, chain: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('getLockStripeConnectionDetails', 'lockAddress', lockAddress)
            // verify required parameter 'chain' is not null or undefined
            assertParamExists('getLockStripeConnectionDetails', 'chain', chain)
            const localVarPath = `/lock/{lockAddress}/stripe-connected`
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (chain !== undefined) {
                localVarQueryParameter['chain'] = chain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get receipt details
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} hash Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceipt: async (network: number, lockAddress: string, hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getReceipt', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('getReceipt', 'lockAddress', lockAddress)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getReceipt', 'hash', hash)
            const localVarPath = `/v2/receipts/{network}/{lockAddress}/{hash}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all receipts for a lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceipts: async (network: number, lockAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getReceipts', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('getReceipts', 'lockAddress', lockAddress)
            const localVarPath = `/v2/receipts/{network}/{lockAddress}/all`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supplier details
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceiptsBase: async (network: number, lockAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getReceiptsBase', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('getReceiptsBase', 'lockAddress', lockAddress)
            const localVarPath = `/v2/receipts-base/{network}/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the locks connected to Stripe for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeConnections: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/stripe/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an active subscription associated with the key. It can be fiat or crypto.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: async (network: number, lockAddress: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getSubscription', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('getSubscription', 'lockAddress', lockAddress)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('getSubscription', 'keyId', keyId)
            const localVarPath = `/v2/subscriptions/{network}/locks/{lockAddress}/keys/{keyId}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get a ticket for a key.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicket: async (network: number, lockAddress: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getTicket', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('getTicket', 'lockAddress', lockAddress)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('getTicket', 'keyId', keyId)
            const localVarPath = `/v2/api/ticket/{network}/lock/{lockAddress}/key/{keyId}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the total price for a purchase (including fees)
         * @param {number} network The network the lock is on
         * @param {number} [amount] Amount of tokens you want to get the price for in USD.
         * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalPrice: async (network: number, amount?: number, address?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getTotalPrice', 'network', network)
            const localVarPath = `/v2/api/purchase/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (network !== undefined) {
                localVarQueryParameter['network'] = network;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the price breakdown for universal credit card
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {Array<string>} purchaseData The purchase data passed to the purchase function
         * @param {Array<string>} recipients The recipients passed to the purchase function
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversalCardPrice: async (network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getUniversalCardPrice', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('getUniversalCardPrice', 'lockAddress', lockAddress)
            // verify required parameter 'purchaseData' is not null or undefined
            assertParamExists('getUniversalCardPrice', 'purchaseData', purchaseData)
            // verify required parameter 'recipients' is not null or undefined
            assertParamExists('getUniversalCardPrice', 'recipients', recipients)
            const localVarPath = `/v2/api/price/{network}/{lockAddress}/card`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (purchaseData) {
                localVarQueryParameter['purchaseData[]'] = purchaseData;
            }

            if (recipients) {
                localVarQueryParameter['recipients[]'] = recipients;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns if credit card payment are enable for a lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isCardPaymentEnabledForLock: async (network: number, lockAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('isCardPaymentEnabledForLock', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('isCardPaymentEnabledForLock', 'lockAddress', lockAddress)
            const localVarPath = `/v2/api/credit-card-details/{network}/locks/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get key and user metadata.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyMetadata: async (network: number, lockAddress: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('keyMetadata', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('keyMetadata', 'lockAddress', lockAddress)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('keyMetadata', 'keyId', keyId)
            const localVarPath = `/v2/api/metadata/{network}/locks/{lockAddress}/keys/{keyId}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of lock keys by network with additional metadata if the caller is the lockManager
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} query Query you want to search for.
         * @param {string} filterKey The key you want to search on.
         * @param {string} [expiration] Expiration time
         * @param {number} [page] Page number when paginating
         * @param {number} [max] Maximum number of items to get by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keys: async (network: number, lockAddress: string, query: string, filterKey: string, expiration?: string, page?: number, max?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('keys', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('keys', 'lockAddress', lockAddress)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('keys', 'query', query)
            // verify required parameter 'filterKey' is not null or undefined
            assertParamExists('keys', 'filterKey', filterKey)
            const localVarPath = `/v2/api/{network}/locks/{lockAddress}/keys`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Application required
            await setApiKeyToObject(localVarQueryParameter, "api-key", configuration)

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (filterKey !== undefined) {
                localVarQueryParameter['filterKey'] = filterKey;
            }

            if (expiration !== undefined) {
                localVarQueryParameter['expiration'] = expiration;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (max !== undefined) {
                localVarQueryParameter['max'] = max;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A list of all checkout configs created by the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCheckoutConfigs: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/checkout/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List payment methods for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentMethods: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/purchase/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get metadata for lock address.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockMetadata: async (network: number, lockAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('lockMetadata', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('lockMetadata', 'lockAddress', lockAddress)
            const localVarPath = `/v2/api/metadata/{network}/locks/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login as a user using Sign in with Ethereum message signed by the wallet address.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/v2/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout from locksmith. This will invalidate all your session tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide a unique nonce for using in sign in with ethereum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nonce: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/nonce`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} network Network id.
         * @param {number} [amount] Amount of tokens you want to get the price for in USD.
         * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        price: async (network: number, amount?: number, address?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('price', 'network', network)
            const localVarPath = `/v2/api/{network}/price`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create purchase intent for stripe.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {PurchaseRequest} purchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchase: async (network: number, lockAddress: string, purchaseRequest: PurchaseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('purchase', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('purchase', 'lockAddress', lockAddress)
            // verify required parameter 'purchaseRequest' is not null or undefined
            assertParamExists('purchase', 'purchaseRequest', purchaseRequest)
            const localVarPath = `/v2/purchase/intent/{network}/locks/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(purchaseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * resubscribe emails from lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reSubscribeEmail: async (network: number, lockAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('reSubscribeEmail', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('reSubscribeEmail', 'lockAddress', lockAddress)
            const localVarPath = `/v2/email-subscriptions/subscribe/{network}/locks/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove all payment methods for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePaymentMethods: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/purchase/payment-methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidate a session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revoke: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/revoke`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save custom email content for a specif lock.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} template Template id for email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCustomEmailContent: async (network: number, lockAddress: string, template: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('saveCustomEmailContent', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('saveCustomEmailContent', 'lockAddress', lockAddress)
            // verify required parameter 'template' is not null or undefined
            assertParamExists('saveCustomEmailContent', 'template', template)
            const localVarPath = `/v2/email/{network}/locks/{lockAddress}/custom/{template}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"template"}}`, encodeURIComponent(String(template)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save event data
         * @param {SaveEventDataRequest} [saveEventDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEventData: async (saveEventDataRequest?: SaveEventDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/events/save`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveEventDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save lock settings
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {LockSettings} [lockSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLockSetting: async (network: number, lockAddress: string, lockSettings?: LockSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('saveLockSetting', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('saveLockSetting', 'lockAddress', lockAddress)
            const localVarPath = `/v2/lock-settings/{network}/locks/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lockSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create purchaser details
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} hash Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveReceipt: async (network: number, lockAddress: string, hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('saveReceipt', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('saveReceipt', 'lockAddress', lockAddress)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('saveReceipt', 'hash', hash)
            const localVarPath = `/v2/receipts/{network}/{lockAddress}/{hash}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create supplier details.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveReceiptsBase: async (network: number, lockAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('saveReceiptsBase', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('saveReceiptsBase', 'lockAddress', lockAddress)
            const localVarPath = `/v2/receipts-base/{network}/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send custom email to recipients
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {SendCustomEmailRequest} [sendCustomEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCustomEmail: async (network: number, lockAddress: string, sendCustomEmailRequest?: SendCustomEmailRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('sendCustomEmail', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('sendCustomEmail', 'lockAddress', lockAddress)
            const localVarPath = `/v2/email/{network}/locks/{lockAddress}/custom/send`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendCustomEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Setup a payment method for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupPayment: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/purchase/setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate signature to prove validity of token.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTicket: async (network: number, lockAddress: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('signTicket', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('signTicket', 'lockAddress', lockAddress)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('signTicket', 'keyId', keyId)
            const localVarPath = `/v2/api/ticket/{network}/{lockAddress}/{keyId}/sign`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get QR code for the key.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ticketQRCode: async (network: number, lockAddress: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('ticketQRCode', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('ticketQRCode', 'lockAddress', lockAddress)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('ticketQRCode', 'keyId', keyId)
            const localVarPath = `/v2/api/ticket/{network}/{lockAddress}/{keyId}/qr`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the verification URL for the key.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ticketVerificationUrl: async (network: number, lockAddress: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('ticketVerificationUrl', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('ticketVerificationUrl', 'lockAddress', lockAddress)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('ticketVerificationUrl', 'keyId', keyId)
            const localVarPath = `/v2/api/ticket/{network}/{lockAddress}/{keyId}/verification`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finalize the transfer of a key to a recipient. This is to copy over any locksmith related data to the recipient\'s account.
         * @param {TransferDoneRequest} [transferDoneRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferDone: async (transferDoneRequest?: TransferDoneRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/transfer/done`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferDoneRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unsubscribe email from lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeEmail: async (network: number, lockAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('unsubscribeEmail', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('unsubscribeEmail', 'lockAddress', lockAddress)
            const localVarPath = `/v2/email-subscriptions/unsubscribe/{network}/locks/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update application by id.
         * @param {string} id Application id.
         * @param {ApplicationBody} [applicationBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication: async (id: string, applicationBody?: ApplicationBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateApplication', 'id', id)
            const localVarPath = `/v2/applications/:id`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new checkout config is created or updated if it already exists
         * @param {string} id This is optional. If you don\&#39;t pass an ID, a new config will be created. If you pass an ID, the config will be created.
         * @param {UpdateCheckoutConfigRequest} [updateCheckoutConfigRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckoutConfig: async (id: string, updateCheckoutConfigRequest?: UpdateCheckoutConfigRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCheckoutConfig', 'id', id)
            const localVarPath = `/v2/checkout/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCheckoutConfigRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update or create metadata for key.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKeyMetadata: async (network: number, lockAddress: string, keyId: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('updateKeyMetadata', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('updateKeyMetadata', 'lockAddress', lockAddress)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('updateKeyMetadata', 'keyId', keyId)
            // verify required parameter 'updateLockMetadataRequest' is not null or undefined
            assertParamExists('updateKeyMetadata', 'updateLockMetadataRequest', updateLockMetadataRequest)
            const localVarPath = `/v2/api/metadata/{network}/locks/{lockAddress}/keys/{keyId}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLockMetadataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update or create metadata for lock address.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLockMetadata: async (network: number, lockAddress: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('updateLockMetadata', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('updateLockMetadata', 'lockAddress', lockAddress)
            // verify required parameter 'updateLockMetadataRequest' is not null or undefined
            assertParamExists('updateLockMetadata', 'updateLockMetadataRequest', updateLockMetadataRequest)
            const localVarPath = `/v2/api/metadata/{network}/locks/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLockMetadataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update or create user metadata for lock.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} userAddress User address.
         * @param {UpdateUserMetadataRequest} updateUserMetadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserMetadata: async (network: number, lockAddress: string, userAddress: string, updateUserMetadataRequest: UpdateUserMetadataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('updateUserMetadata', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('updateUserMetadata', 'lockAddress', lockAddress)
            // verify required parameter 'userAddress' is not null or undefined
            assertParamExists('updateUserMetadata', 'userAddress', userAddress)
            // verify required parameter 'updateUserMetadataRequest' is not null or undefined
            assertParamExists('updateUserMetadata', 'updateUserMetadataRequest', updateUserMetadataRequest)
            const localVarPath = `/v2/api/metadata/{network}/locks/{lockAddress}/users/{userAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"userAddress"}}`, encodeURIComponent(String(userAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserMetadataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update or create user metadata for lock.
         * @param {UpdateUsersMetadataRequest} updateUsersMetadataRequest users array containing user metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsersMetadata: async (updateUsersMetadataRequest: UpdateUsersMetadataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUsersMetadataRequest' is not null or undefined
            assertParamExists('updateUsersMetadata', 'updateUsersMetadataRequest', updateUsersMetadataRequest)
            const localVarPath = `/v2/api/metadata/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUsersMetadataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload images to locksmith
         * @param {Array<any>} [images] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImages: async (images?: Array<any>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/images/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (images) {
                images.forEach((element) => {
                    localVarFormParams.append('images', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        user: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/auth/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if an address is a verifier of the lock.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} verifierAddress User address to use as verifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifier: async (network: number, lockAddress: string, verifierAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('verifier', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('verifier', 'lockAddress', lockAddress)
            // verify required parameter 'verifierAddress' is not null or undefined
            assertParamExists('verifier', 'verifierAddress', verifierAddress)
            const localVarPath = `/v2/api/verifier/{network}/lock/{lockAddress}/address/{verifierAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)))
                .replace(`{${"verifierAddress"}}`, encodeURIComponent(String(verifierAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of verifiers for the lock address.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiers: async (network: number, lockAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('verifiers', 'network', network)
            // verify required parameter 'lockAddress' is not null or undefined
            assertParamExists('verifiers', 'lockAddress', lockAddress)
            const localVarPath = `/v2/api/verifier/list/{network}/{lockAddress}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)))
                .replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication User required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * List applications created the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applications(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Applications200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.applications(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balance(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Balance200ResponseValue; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balance(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel a fiat subscription.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSubscription(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSubscription(network, lockAddress, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Setup an onramp session for the user.
         * @param {string} session The id of the onramp session
         * @param {string} transactionHash The transacttion hash for the deposit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async captureOnRampSession(session: string, transactionHash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaptureOnRampSession200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.captureOnRampSession(session, transactionHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Capture a purchase
         * @param {CapturePurchaseRequest} [capturePurchaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturePurchase(capturePurchaseRequest?: CapturePurchaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateLockContract201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturePurchase(capturePurchaseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if claim is possible for a given purchase
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {CheckClaimRequest} [checkClaimRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkClaim(network: number, lockAddress: string, checkClaimRequest?: CheckClaimRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckClaim200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkClaim(network, lockAddress, checkClaimRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark a ticket as checked in.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkTicket(network, lockAddress, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Claim a membership key for a lock. If not authenticated, requires an email in the body.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} captcha Recaptcha value to pass.
         * @param {ClaimRequest} claimRequest 
         * @param {string} [recipient] Recipient address for key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claim(network: number, lockAddress: string, captcha: string, claimRequest: ClaimRequest, recipient?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Claim200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claim(network, lockAddress, captcha, claimRequest, recipient, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Connect a stripe account to a lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {ConnectStripeAccountRequest} [connectStripeAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectStripeAccount(network: number, lockAddress: string, connectStripeAccountRequest?: ConnectStripeAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectStripeAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectStripeAccount(network, lockAddress, connectStripeAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create application associated with user wallet.
         * @param {ApplicationBody} applicationBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(applicationBody: ApplicationBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(applicationBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} network Network id.
         * @param {string} captcha Recaptcha value to pass.
         * @param {LockContractOptions} lockContractOptions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLockContract(network: number, captcha: string, lockContractOptions: LockContractOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateLockContract201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLockContract(network, captcha, lockContractOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Setup an onramp session for the user.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {CreateOnRampSessionRequest} createOnRampSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOnRampSession(network: number, lockAddress: string, createOnRampSessionRequest: CreateOnRampSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetupPayment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOnRampSession(network, lockAddress, createOnRampSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a transfer code to transfer an airdropped key to an email address.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransferCode(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransferCode200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransferCode(network, lockAddress, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create verifier.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} verifierAddress User address to use as verifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVerifier(network: number, lockAddress: string, verifierAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Verifier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVerifier(network, lockAddress, verifierAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete application by id.
         * @param {string} id Application id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a checkout config
         * @param {string} id The id of the checkout config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCheckoutConfig(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCheckoutConfig200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCheckoutConfig(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove verifier.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} verifierAddress User address to use as verifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVerifier(network: number, lockAddress: string, verifierAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Verifiers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVerifier(network, lockAddress, verifierAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disconnect stripe account.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disconnectStripe(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disconnectStripe(network, lockAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send QR code by email.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailTicket200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailTicket(network, lockAddress, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate certificate for specific key
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateCertificate(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateCertificate(network, lockAddress, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate a ticket for a key.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateTicket(network, lockAddress, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the price breakdown for recipients & total charges with fees for a specific lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {Array<string>} purchaseData The purchase data passed to the purchase function
         * @param {Array<string>} recipients The recipients passed to the purchase function
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChargesForLock(network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChargesForLock200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChargesForLock(network, lockAddress, purchaseData, recipients, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id The id of the checkout config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheckoutConfig(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCheckoutConfig(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get custom email content for a specific template and lock details
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} template Template id for email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomEmailContent(network: number, lockAddress: string, template: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomEmailContent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomEmailContent(network, lockAddress, template, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the data for recipients and guild. This is to be used in conjunction with the Guild
         * @param {number} network The network the lock is on
         * @param {string} [lockAddress] The address of the lock
         * @param {Array<string>} [recipients] The list of recipients for the purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataForRecipientsAndGuild(network: number, lockAddress?: string, recipients?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDataForRecipientsAndGuild200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataForRecipientsAndGuild(network, lockAddress, recipients, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the event details from lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventDetails(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventDetails(network, lockAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get saved lock settings
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLockSettings(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LockSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLockSettings(network, lockAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get lock setting by slug
         * @param {string} slug Slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLockSettingsBySlug(slug: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LockSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLockSettingsBySlug(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Stripe connection details
         * @param {string} lockAddress Lock address.
         * @param {number} chain Lock network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLockStripeConnectionDetails(lockAddress: string, chain: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLockStripeConnectionDetails200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLockStripeConnectionDetails(lockAddress, chain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get receipt details
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} hash Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReceipt(network: number, lockAddress: string, hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReceipt200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReceipt(network, lockAddress, hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all receipts for a lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReceipts(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReceipts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReceipts(network, lockAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supplier details
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReceiptsBase(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReceiptsBase200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReceiptsBase(network, lockAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the locks connected to Stripe for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStripeConnections(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStripeConnections200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStripeConnections(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an active subscription associated with the key. It can be fiat or crypto.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscription(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSubscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(network, lockAddress, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get a ticket for a key.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTicket200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicket(network, lockAddress, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the total price for a purchase (including fees)
         * @param {number} network The network the lock is on
         * @param {number} [amount] Amount of tokens you want to get the price for in USD.
         * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTotalPrice(network: number, amount?: number, address?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTotalPrice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTotalPrice(network, amount, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the price breakdown for universal credit card
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {Array<string>} purchaseData The purchase data passed to the purchase function
         * @param {Array<string>} recipients The recipients passed to the purchase function
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniversalCardPrice(network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChargesForLock200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniversalCardPrice(network, lockAddress, purchaseData, recipients, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns if credit card payment are enable for a lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isCardPaymentEnabledForLock(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsCardPaymentEnabledForLock200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isCardPaymentEnabledForLock(network, lockAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get key and user metadata.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyMetadata(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyMetadata200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyMetadata(network, lockAddress, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List of lock keys by network with additional metadata if the caller is the lockManager
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} query Query you want to search for.
         * @param {string} filterKey The key you want to search on.
         * @param {string} [expiration] Expiration time
         * @param {number} [page] Page number when paginating
         * @param {number} [max] Maximum number of items to get by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keys(network: number, lockAddress: string, query: string, filterKey: string, expiration?: string, page?: number, max?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KeyMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keys(network, lockAddress, query, filterKey, expiration, page, max, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A list of all checkout configs created by the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCheckoutConfigs(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCheckoutConfigs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCheckoutConfigs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List payment methods for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPaymentMethods(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentMethods200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentMethods(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get metadata for lock address.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockMetadata(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockMetadata(network, lockAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Login as a user using Sign in with Ethereum message signed by the wallet address.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Logout from locksmith. This will invalidate all your session tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provide a unique nonce for using in sign in with ethereum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nonce(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonce(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} network Network id.
         * @param {number} [amount] Amount of tokens you want to get the price for in USD.
         * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async price(network: number, amount?: number, address?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Price200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.price(network, amount, address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create purchase intent for stripe.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {PurchaseRequest} purchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchase(network: number, lockAddress: string, purchaseRequest: PurchaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Purchase200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchase(network, lockAddress, purchaseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * resubscribe emails from lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reSubscribeEmail(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemovePaymentMethods200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reSubscribeEmail(network, lockAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove all payment methods for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePaymentMethods(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemovePaymentMethods200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePaymentMethods(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Invalidate a session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revoke(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revoke(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Save custom email content for a specif lock.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} template Template id for email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveCustomEmailContent(network: number, lockAddress: string, template: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomEmailContent200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveCustomEmailContent(network, lockAddress, template, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Save event data
         * @param {SaveEventDataRequest} [saveEventDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveEventData(saveEventDataRequest?: SaveEventDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveEventDataRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveEventData(saveEventDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Save lock settings
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {LockSettings} [lockSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveLockSetting(network: number, lockAddress: string, lockSettings?: LockSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveLockSetting200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveLockSetting(network, lockAddress, lockSettings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create purchaser details
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} hash Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveReceipt(network: number, lockAddress: string, hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveReceipt200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveReceipt(network, lockAddress, hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create supplier details.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveReceiptsBase(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReceiptsBase200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveReceiptsBase(network, lockAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send custom email to recipients
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {SendCustomEmailRequest} [sendCustomEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendCustomEmail(network: number, lockAddress: string, sendCustomEmailRequest?: SendCustomEmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendCustomEmail200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendCustomEmail(network, lockAddress, sendCustomEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Setup a payment method for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setupPayment(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetupPayment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setupPayment(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate signature to prove validity of token.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignTicket200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signTicket(network, lockAddress, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get QR code for the key.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ticketQRCode(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ticketQRCode(network, lockAddress, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the verification URL for the key.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ticketVerificationUrl(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketVerificationUrl200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ticketVerificationUrl(network, lockAddress, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finalize the transfer of a key to a recipient. This is to copy over any locksmith related data to the recipient\'s account.
         * @param {TransferDoneRequest} [transferDoneRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferDone(transferDoneRequest?: TransferDoneRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransferCode404Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferDone(transferDoneRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unsubscribe email from lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribeEmail(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemovePaymentMethods200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribeEmail(network, lockAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update application by id.
         * @param {string} id Application id.
         * @param {ApplicationBody} [applicationBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplication(id: string, applicationBody?: ApplicationBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplication(id, applicationBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A new checkout config is created or updated if it already exists
         * @param {string} id This is optional. If you don\&#39;t pass an ID, a new config will be created. If you pass an ID, the config will be created.
         * @param {UpdateCheckoutConfigRequest} [updateCheckoutConfigRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCheckoutConfig(id: string, updateCheckoutConfigRequest?: UpdateCheckoutConfigRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCheckoutConfig(id, updateCheckoutConfigRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update or create metadata for key.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKeyMetadata(network: number, lockAddress: string, keyId: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKeyMetadata(network, lockAddress, keyId, updateLockMetadataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update or create metadata for lock address.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLockMetadata(network: number, lockAddress: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLockMetadata(network, lockAddress, updateLockMetadataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update or create user metadata for lock.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} userAddress User address.
         * @param {UpdateUserMetadataRequest} updateUserMetadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserMetadata(network: number, lockAddress: string, userAddress: string, updateUserMetadataRequest: UpdateUserMetadataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserMetadata(network, lockAddress, userAddress, updateUserMetadataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update or create user metadata for lock.
         * @param {UpdateUsersMetadataRequest} updateUsersMetadataRequest users array containing user metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUsersMetadata(updateUsersMetadataRequest: UpdateUsersMetadataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUsersMetadata201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsersMetadata(updateUsersMetadataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload images to locksmith
         * @param {Array<any>} [images] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadImages(images?: Array<any>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadImages201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadImages(images, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async user(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Auth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.user(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if an address is a verifier of the lock.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} verifierAddress User address to use as verifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifier(network: number, lockAddress: string, verifierAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Verifier200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifier(network, lockAddress, verifierAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List of verifiers for the lock address.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifiers(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Verifiers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifiers(network, lockAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * List applications created the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applications(options?: any): AxiosPromise<Applications200Response> {
            return localVarFp.applications(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balance(options?: any): AxiosPromise<{ [key: string]: Balance200ResponseValue; }> {
            return localVarFp.balance(options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a fiat subscription.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscription(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelSubscription(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Setup an onramp session for the user.
         * @param {string} session The id of the onramp session
         * @param {string} transactionHash The transacttion hash for the deposit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureOnRampSession(session: string, transactionHash: string, options?: any): AxiosPromise<CaptureOnRampSession200Response> {
            return localVarFp.captureOnRampSession(session, transactionHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Capture a purchase
         * @param {CapturePurchaseRequest} [capturePurchaseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturePurchase(capturePurchaseRequest?: CapturePurchaseRequest, options?: any): AxiosPromise<CreateLockContract201Response> {
            return localVarFp.capturePurchase(capturePurchaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if claim is possible for a given purchase
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {CheckClaimRequest} [checkClaimRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkClaim(network: number, lockAddress: string, checkClaimRequest?: CheckClaimRequest, options?: any): AxiosPromise<CheckClaim200Response> {
            return localVarFp.checkClaim(network, lockAddress, checkClaimRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark a ticket as checked in.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkTicket(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<GenericSuccess> {
            return localVarFp.checkTicket(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Claim a membership key for a lock. If not authenticated, requires an email in the body.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} captcha Recaptcha value to pass.
         * @param {ClaimRequest} claimRequest 
         * @param {string} [recipient] Recipient address for key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claim(network: number, lockAddress: string, captcha: string, claimRequest: ClaimRequest, recipient?: string, options?: any): AxiosPromise<Claim200Response> {
            return localVarFp.claim(network, lockAddress, captcha, claimRequest, recipient, options).then((request) => request(axios, basePath));
        },
        /**
         * Connect a stripe account to a lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {ConnectStripeAccountRequest} [connectStripeAccountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectStripeAccount(network: number, lockAddress: string, connectStripeAccountRequest?: ConnectStripeAccountRequest, options?: any): AxiosPromise<ConnectStripeAccount200Response> {
            return localVarFp.connectStripeAccount(network, lockAddress, connectStripeAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create application associated with user wallet.
         * @param {ApplicationBody} applicationBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(applicationBody: ApplicationBody, options?: any): AxiosPromise<Application> {
            return localVarFp.createApplication(applicationBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} network Network id.
         * @param {string} captcha Recaptcha value to pass.
         * @param {LockContractOptions} lockContractOptions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLockContract(network: number, captcha: string, lockContractOptions: LockContractOptions, options?: any): AxiosPromise<CreateLockContract201Response> {
            return localVarFp.createLockContract(network, captcha, lockContractOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * Setup an onramp session for the user.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {CreateOnRampSessionRequest} createOnRampSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOnRampSession(network: number, lockAddress: string, createOnRampSessionRequest: CreateOnRampSessionRequest, options?: any): AxiosPromise<SetupPayment200Response> {
            return localVarFp.createOnRampSession(network, lockAddress, createOnRampSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a transfer code to transfer an airdropped key to an email address.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransferCode(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<CreateTransferCode200Response> {
            return localVarFp.createTransferCode(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create verifier.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} verifierAddress User address to use as verifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVerifier(network: number, lockAddress: string, verifierAddress: string, options?: any): AxiosPromise<Verifier> {
            return localVarFp.createVerifier(network, lockAddress, verifierAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete application by id.
         * @param {string} id Application id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(id: string, options?: any): AxiosPromise<GenericSuccess> {
            return localVarFp.deleteApplication(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a checkout config
         * @param {string} id The id of the checkout config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCheckoutConfig(id: string, options?: any): AxiosPromise<DeleteCheckoutConfig200Response> {
            return localVarFp.deleteCheckoutConfig(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove verifier.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} verifierAddress User address to use as verifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVerifier(network: number, lockAddress: string, verifierAddress: string, options?: any): AxiosPromise<Verifiers200Response> {
            return localVarFp.deleteVerifier(network, lockAddress, verifierAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Disconnect stripe account.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectStripe(network: number, lockAddress: string, options?: any): AxiosPromise<void> {
            return localVarFp.disconnectStripe(network, lockAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Send QR code by email.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailTicket(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<EmailTicket200Response> {
            return localVarFp.emailTicket(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate certificate for specific key
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCertificate(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.generateCertificate(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a ticket for a key.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTicket(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.generateTicket(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the price breakdown for recipients & total charges with fees for a specific lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {Array<string>} purchaseData The purchase data passed to the purchase function
         * @param {Array<string>} recipients The recipients passed to the purchase function
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargesForLock(network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options?: any): AxiosPromise<GetChargesForLock200Response> {
            return localVarFp.getChargesForLock(network, lockAddress, purchaseData, recipients, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The id of the checkout config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckoutConfig(id: string, options?: any): AxiosPromise<CheckoutConfig> {
            return localVarFp.getCheckoutConfig(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get custom email content for a specific template and lock details
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} template Template id for email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomEmailContent(network: number, lockAddress: string, template: string, options?: any): AxiosPromise<GetCustomEmailContent200Response> {
            return localVarFp.getCustomEmailContent(network, lockAddress, template, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the data for recipients and guild. This is to be used in conjunction with the Guild
         * @param {number} network The network the lock is on
         * @param {string} [lockAddress] The address of the lock
         * @param {Array<string>} [recipients] The list of recipients for the purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataForRecipientsAndGuild(network: number, lockAddress?: string, recipients?: Array<string>, options?: any): AxiosPromise<GetDataForRecipientsAndGuild200Response> {
            return localVarFp.getDataForRecipientsAndGuild(network, lockAddress, recipients, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the event details from lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDetails(network: number, lockAddress: string, options?: any): AxiosPromise<EventDetails> {
            return localVarFp.getEventDetails(network, lockAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Get saved lock settings
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLockSettings(network: number, lockAddress: string, options?: any): AxiosPromise<LockSettings> {
            return localVarFp.getLockSettings(network, lockAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Get lock setting by slug
         * @param {string} slug Slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLockSettingsBySlug(slug: string, options?: any): AxiosPromise<LockSettings> {
            return localVarFp.getLockSettingsBySlug(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Stripe connection details
         * @param {string} lockAddress Lock address.
         * @param {number} chain Lock network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLockStripeConnectionDetails(lockAddress: string, chain: number, options?: any): AxiosPromise<GetLockStripeConnectionDetails200Response> {
            return localVarFp.getLockStripeConnectionDetails(lockAddress, chain, options).then((request) => request(axios, basePath));
        },
        /**
         * Get receipt details
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} hash Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceipt(network: number, lockAddress: string, hash: string, options?: any): AxiosPromise<GetReceipt200Response> {
            return localVarFp.getReceipt(network, lockAddress, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all receipts for a lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceipts(network: number, lockAddress: string, options?: any): AxiosPromise<GetReceipts200Response> {
            return localVarFp.getReceipts(network, lockAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supplier details
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReceiptsBase(network: number, lockAddress: string, options?: any): AxiosPromise<GetReceiptsBase200Response> {
            return localVarFp.getReceiptsBase(network, lockAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the locks connected to Stripe for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeConnections(options?: any): AxiosPromise<GetStripeConnections200Response> {
            return localVarFp.getStripeConnections(options).then((request) => request(axios, basePath));
        },
        /**
         * Get an active subscription associated with the key. It can be fiat or crypto.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<GetSubscription200Response> {
            return localVarFp.getSubscription(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * get a ticket for a key.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicket(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<GetTicket200Response> {
            return localVarFp.getTicket(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the total price for a purchase (including fees)
         * @param {number} network The network the lock is on
         * @param {number} [amount] Amount of tokens you want to get the price for in USD.
         * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalPrice(network: number, amount?: number, address?: string, options?: any): AxiosPromise<GetTotalPrice200Response> {
            return localVarFp.getTotalPrice(network, amount, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the price breakdown for universal credit card
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {Array<string>} purchaseData The purchase data passed to the purchase function
         * @param {Array<string>} recipients The recipients passed to the purchase function
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversalCardPrice(network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options?: any): AxiosPromise<GetChargesForLock200Response> {
            return localVarFp.getUniversalCardPrice(network, lockAddress, purchaseData, recipients, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns if credit card payment are enable for a lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isCardPaymentEnabledForLock(network: number, lockAddress: string, options?: any): AxiosPromise<IsCardPaymentEnabledForLock200Response> {
            return localVarFp.isCardPaymentEnabledForLock(network, lockAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Get key and user metadata.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyMetadata(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<KeyMetadata200Response> {
            return localVarFp.keyMetadata(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List of lock keys by network with additional metadata if the caller is the lockManager
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} query Query you want to search for.
         * @param {string} filterKey The key you want to search on.
         * @param {string} [expiration] Expiration time
         * @param {number} [page] Page number when paginating
         * @param {number} [max] Maximum number of items to get by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keys(network: number, lockAddress: string, query: string, filterKey: string, expiration?: string, page?: number, max?: number, options?: any): AxiosPromise<Array<KeyMetadata>> {
            return localVarFp.keys(network, lockAddress, query, filterKey, expiration, page, max, options).then((request) => request(axios, basePath));
        },
        /**
         * A list of all checkout configs created by the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCheckoutConfigs(options?: any): AxiosPromise<ListCheckoutConfigs200Response> {
            return localVarFp.listCheckoutConfigs(options).then((request) => request(axios, basePath));
        },
        /**
         * List payment methods for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentMethods(options?: any): AxiosPromise<ListPaymentMethods200Response> {
            return localVarFp.listPaymentMethods(options).then((request) => request(axios, basePath));
        },
        /**
         * Get metadata for lock address.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockMetadata(network: number, lockAddress: string, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.lockMetadata(network, lockAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Login as a user using Sign in with Ethereum message signed by the wallet address.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: any): AxiosPromise<AuthResult> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout from locksmith. This will invalidate all your session tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<GenericSuccess> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * Provide a unique nonce for using in sign in with ethereum
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nonce(options?: any): AxiosPromise<string> {
            return localVarFp.nonce(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} network Network id.
         * @param {number} [amount] Amount of tokens you want to get the price for in USD.
         * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        price(network: number, amount?: number, address?: string, options?: any): AxiosPromise<Price200Response> {
            return localVarFp.price(network, amount, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Create purchase intent for stripe.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {PurchaseRequest} purchaseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchase(network: number, lockAddress: string, purchaseRequest: PurchaseRequest, options?: any): AxiosPromise<Purchase200Response> {
            return localVarFp.purchase(network, lockAddress, purchaseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * resubscribe emails from lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reSubscribeEmail(network: number, lockAddress: string, options?: any): AxiosPromise<RemovePaymentMethods200Response> {
            return localVarFp.reSubscribeEmail(network, lockAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove all payment methods for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePaymentMethods(options?: any): AxiosPromise<RemovePaymentMethods200Response> {
            return localVarFp.removePaymentMethods(options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidate a session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revoke(options?: any): AxiosPromise<GenericSuccess> {
            return localVarFp.revoke(options).then((request) => request(axios, basePath));
        },
        /**
         * Save custom email content for a specif lock.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} template Template id for email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCustomEmailContent(network: number, lockAddress: string, template: string, options?: any): AxiosPromise<GetCustomEmailContent200Response> {
            return localVarFp.saveCustomEmailContent(network, lockAddress, template, options).then((request) => request(axios, basePath));
        },
        /**
         * Save event data
         * @param {SaveEventDataRequest} [saveEventDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveEventData(saveEventDataRequest?: SaveEventDataRequest, options?: any): AxiosPromise<SaveEventDataRequest> {
            return localVarFp.saveEventData(saveEventDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Save lock settings
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {LockSettings} [lockSettings] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLockSetting(network: number, lockAddress: string, lockSettings?: LockSettings, options?: any): AxiosPromise<SaveLockSetting200Response> {
            return localVarFp.saveLockSetting(network, lockAddress, lockSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Create purchaser details
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} hash Hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveReceipt(network: number, lockAddress: string, hash: string, options?: any): AxiosPromise<SaveReceipt200Response> {
            return localVarFp.saveReceipt(network, lockAddress, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Create supplier details.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveReceiptsBase(network: number, lockAddress: string, options?: any): AxiosPromise<GetReceiptsBase200Response> {
            return localVarFp.saveReceiptsBase(network, lockAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Send custom email to recipients
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {SendCustomEmailRequest} [sendCustomEmailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCustomEmail(network: number, lockAddress: string, sendCustomEmailRequest?: SendCustomEmailRequest, options?: any): AxiosPromise<SendCustomEmail200Response> {
            return localVarFp.sendCustomEmail(network, lockAddress, sendCustomEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Setup a payment method for user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setupPayment(options?: any): AxiosPromise<SetupPayment200Response> {
            return localVarFp.setupPayment(options).then((request) => request(axios, basePath));
        },
        /**
         * Generate signature to prove validity of token.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signTicket(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<SignTicket200Response> {
            return localVarFp.signTicket(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get QR code for the key.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ticketQRCode(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<any> {
            return localVarFp.ticketQRCode(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the verification URL for the key.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ticketVerificationUrl(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<TicketVerificationUrl200Response> {
            return localVarFp.ticketVerificationUrl(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Finalize the transfer of a key to a recipient. This is to copy over any locksmith related data to the recipient\'s account.
         * @param {TransferDoneRequest} [transferDoneRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferDone(transferDoneRequest?: TransferDoneRequest, options?: any): AxiosPromise<CreateTransferCode404Response> {
            return localVarFp.transferDone(transferDoneRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Unsubscribe email from lock
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeEmail(network: number, lockAddress: string, options?: any): AxiosPromise<RemovePaymentMethods200Response> {
            return localVarFp.unsubscribeEmail(network, lockAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Update application by id.
         * @param {string} id Application id.
         * @param {ApplicationBody} [applicationBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication(id: string, applicationBody?: ApplicationBody, options?: any): AxiosPromise<Application> {
            return localVarFp.updateApplication(id, applicationBody, options).then((request) => request(axios, basePath));
        },
        /**
         * A new checkout config is created or updated if it already exists
         * @param {string} id This is optional. If you don\&#39;t pass an ID, a new config will be created. If you pass an ID, the config will be created.
         * @param {UpdateCheckoutConfigRequest} [updateCheckoutConfigRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckoutConfig(id: string, updateCheckoutConfigRequest?: UpdateCheckoutConfigRequest, options?: any): AxiosPromise<CheckoutConfig> {
            return localVarFp.updateCheckoutConfig(id, updateCheckoutConfigRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update or create metadata for key.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} keyId Key Id.
         * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKeyMetadata(network: number, lockAddress: string, keyId: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.updateKeyMetadata(network, lockAddress, keyId, updateLockMetadataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update or create metadata for lock address.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLockMetadata(network: number, lockAddress: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.updateLockMetadata(network, lockAddress, updateLockMetadataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update or create user metadata for lock.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} userAddress User address.
         * @param {UpdateUserMetadataRequest} updateUserMetadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserMetadata(network: number, lockAddress: string, userAddress: string, updateUserMetadataRequest: UpdateUserMetadataRequest, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.updateUserMetadata(network, lockAddress, userAddress, updateUserMetadataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update or create user metadata for lock.
         * @param {UpdateUsersMetadataRequest} updateUsersMetadataRequest users array containing user metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsersMetadata(updateUsersMetadataRequest: UpdateUsersMetadataRequest, options?: any): AxiosPromise<UpdateUsersMetadata201Response> {
            return localVarFp.updateUsersMetadata(updateUsersMetadataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload images to locksmith
         * @param {Array<any>} [images] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImages(images?: Array<any>, options?: any): AxiosPromise<UploadImages201Response> {
            return localVarFp.uploadImages(images, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        user(options?: any): AxiosPromise<Auth> {
            return localVarFp.user(options).then((request) => request(axios, basePath));
        },
        /**
         * Check if an address is a verifier of the lock.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {string} verifierAddress User address to use as verifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifier(network: number, lockAddress: string, verifierAddress: string, options?: any): AxiosPromise<Verifier200Response> {
            return localVarFp.verifier(network, lockAddress, verifierAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * List of verifiers for the lock address.
         * @param {number} network Network id.
         * @param {string} lockAddress Lock address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiers(network: number, lockAddress: string, options?: any): AxiosPromise<Verifiers200Response> {
            return localVarFp.verifiers(network, lockAddress, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * List applications created the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public applications(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).applications(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public balance(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).balance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a fiat subscription.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelSubscription(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cancelSubscription(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Setup an onramp session for the user.
     * @param {string} session The id of the onramp session
     * @param {string} transactionHash The transacttion hash for the deposit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public captureOnRampSession(session: string, transactionHash: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).captureOnRampSession(session, transactionHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Capture a purchase
     * @param {CapturePurchaseRequest} [capturePurchaseRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public capturePurchase(capturePurchaseRequest?: CapturePurchaseRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).capturePurchase(capturePurchaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if claim is possible for a given purchase
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CheckClaimRequest} [checkClaimRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public checkClaim(network: number, lockAddress: string, checkClaimRequest?: CheckClaimRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).checkClaim(network, lockAddress, checkClaimRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark a ticket as checked in.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public checkTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).checkTicket(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Claim a membership key for a lock. If not authenticated, requires an email in the body.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} captcha Recaptcha value to pass.
     * @param {ClaimRequest} claimRequest 
     * @param {string} [recipient] Recipient address for key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public claim(network: number, lockAddress: string, captcha: string, claimRequest: ClaimRequest, recipient?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).claim(network, lockAddress, captcha, claimRequest, recipient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Connect a stripe account to a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {ConnectStripeAccountRequest} [connectStripeAccountRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public connectStripeAccount(network: number, lockAddress: string, connectStripeAccountRequest?: ConnectStripeAccountRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).connectStripeAccount(network, lockAddress, connectStripeAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create application associated with user wallet.
     * @param {ApplicationBody} applicationBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createApplication(applicationBody: ApplicationBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createApplication(applicationBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} network Network id.
     * @param {string} captcha Recaptcha value to pass.
     * @param {LockContractOptions} lockContractOptions 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createLockContract(network: number, captcha: string, lockContractOptions: LockContractOptions, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createLockContract(network, captcha, lockContractOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Setup an onramp session for the user.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CreateOnRampSessionRequest} createOnRampSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createOnRampSession(network: number, lockAddress: string, createOnRampSessionRequest: CreateOnRampSessionRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createOnRampSession(network, lockAddress, createOnRampSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a transfer code to transfer an airdropped key to an email address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createTransferCode(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createTransferCode(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createVerifier(network: number, lockAddress: string, verifierAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createVerifier(network, lockAddress, verifierAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete application by id.
     * @param {string} id Application id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteApplication(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteApplication(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a checkout config
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteCheckoutConfig(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteCheckoutConfig(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteVerifier(network: number, lockAddress: string, verifierAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteVerifier(network, lockAddress, verifierAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disconnect stripe account.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public disconnectStripe(network: number, lockAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).disconnectStripe(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send QR code by email.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public emailTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).emailTicket(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate certificate for specific key
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public generateCertificate(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).generateCertificate(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public generateTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).generateTicket(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the price breakdown for recipients & total charges with fees for a specific lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getChargesForLock(network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getChargesForLock(network, lockAddress, purchaseData, recipients, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCheckoutConfig(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCheckoutConfig(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get custom email content for a specific template and lock details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCustomEmailContent(network: number, lockAddress: string, template: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCustomEmailContent(network, lockAddress, template, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the data for recipients and guild. This is to be used in conjunction with the Guild
     * @param {number} network The network the lock is on
     * @param {string} [lockAddress] The address of the lock
     * @param {Array<string>} [recipients] The list of recipients for the purchase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDataForRecipientsAndGuild(network: number, lockAddress?: string, recipients?: Array<string>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getDataForRecipientsAndGuild(network, lockAddress, recipients, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the event details from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEventDetails(network: number, lockAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEventDetails(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get saved lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLockSettings(network: number, lockAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLockSettings(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get lock setting by slug
     * @param {string} slug Slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLockSettingsBySlug(slug: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLockSettingsBySlug(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Stripe connection details
     * @param {string} lockAddress Lock address.
     * @param {number} chain Lock network
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLockStripeConnectionDetails(lockAddress: string, chain: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLockStripeConnectionDetails(lockAddress, chain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get receipt details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getReceipt(network: number, lockAddress: string, hash: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getReceipt(network, lockAddress, hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all receipts for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getReceipts(network: number, lockAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getReceipts(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supplier details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getReceiptsBase(network: number, lockAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getReceiptsBase(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the locks connected to Stripe for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStripeConnections(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStripeConnections(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an active subscription associated with the key. It can be fiat or crypto.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSubscription(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSubscription(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTicket(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the total price for a purchase (including fees)
     * @param {number} network The network the lock is on
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTotalPrice(network: number, amount?: number, address?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTotalPrice(network, amount, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the price breakdown for universal credit card
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUniversalCardPrice(network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUniversalCardPrice(network, lockAddress, purchaseData, recipients, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns if credit card payment are enable for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public isCardPaymentEnabledForLock(network: number, lockAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).isCardPaymentEnabledForLock(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get key and user metadata.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public keyMetadata(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).keyMetadata(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of lock keys by network with additional metadata if the caller is the lockManager
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} query Query you want to search for.
     * @param {string} filterKey The key you want to search on.
     * @param {string} [expiration] Expiration time
     * @param {number} [page] Page number when paginating
     * @param {number} [max] Maximum number of items to get by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public keys(network: number, lockAddress: string, query: string, filterKey: string, expiration?: string, page?: number, max?: number, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).keys(network, lockAddress, query, filterKey, expiration, page, max, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A list of all checkout configs created by the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listCheckoutConfigs(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listCheckoutConfigs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List payment methods for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listPaymentMethods(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listPaymentMethods(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lockMetadata(network: number, lockAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lockMetadata(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login as a user using Sign in with Ethereum message signed by the wallet address.
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public login(loginRequest: LoginRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout from locksmith. This will invalidate all your session tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public logout(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provide a unique nonce for using in sign in with ethereum
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public nonce(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).nonce(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} network Network id.
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public price(network: number, amount?: number, address?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).price(network, amount, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create purchase intent for stripe.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {PurchaseRequest} purchaseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public purchase(network: number, lockAddress: string, purchaseRequest: PurchaseRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).purchase(network, lockAddress, purchaseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * resubscribe emails from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public reSubscribeEmail(network: number, lockAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).reSubscribeEmail(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove all payment methods for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public removePaymentMethods(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).removePaymentMethods(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidate a session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public revoke(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).revoke(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Save custom email content for a specif lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public saveCustomEmailContent(network: number, lockAddress: string, template: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).saveCustomEmailContent(network, lockAddress, template, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Save event data
     * @param {SaveEventDataRequest} [saveEventDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public saveEventData(saveEventDataRequest?: SaveEventDataRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).saveEventData(saveEventDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Save lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {LockSettings} [lockSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public saveLockSetting(network: number, lockAddress: string, lockSettings?: LockSettings, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).saveLockSetting(network, lockAddress, lockSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create purchaser details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public saveReceipt(network: number, lockAddress: string, hash: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).saveReceipt(network, lockAddress, hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create supplier details.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public saveReceiptsBase(network: number, lockAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).saveReceiptsBase(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send custom email to recipients
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {SendCustomEmailRequest} [sendCustomEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sendCustomEmail(network: number, lockAddress: string, sendCustomEmailRequest?: SendCustomEmailRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sendCustomEmail(network, lockAddress, sendCustomEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Setup a payment method for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setupPayment(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setupPayment(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate signature to prove validity of token.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public signTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).signTicket(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get QR code for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public ticketQRCode(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).ticketQRCode(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the verification URL for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public ticketVerificationUrl(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).ticketVerificationUrl(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finalize the transfer of a key to a recipient. This is to copy over any locksmith related data to the recipient\'s account.
     * @param {TransferDoneRequest} [transferDoneRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transferDone(transferDoneRequest?: TransferDoneRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transferDone(transferDoneRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unsubscribe email from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public unsubscribeEmail(network: number, lockAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).unsubscribeEmail(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update application by id.
     * @param {string} id Application id.
     * @param {ApplicationBody} [applicationBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateApplication(id: string, applicationBody?: ApplicationBody, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateApplication(id, applicationBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new checkout config is created or updated if it already exists
     * @param {string} id This is optional. If you don\&#39;t pass an ID, a new config will be created. If you pass an ID, the config will be created.
     * @param {UpdateCheckoutConfigRequest} [updateCheckoutConfigRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateCheckoutConfig(id: string, updateCheckoutConfigRequest?: UpdateCheckoutConfigRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateCheckoutConfig(id, updateCheckoutConfigRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update or create metadata for key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateKeyMetadata(network: number, lockAddress: string, keyId: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateKeyMetadata(network, lockAddress, keyId, updateLockMetadataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update or create metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateLockMetadata(network: number, lockAddress: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateLockMetadata(network, lockAddress, updateLockMetadataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update or create user metadata for lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} userAddress User address.
     * @param {UpdateUserMetadataRequest} updateUserMetadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateUserMetadata(network: number, lockAddress: string, userAddress: string, updateUserMetadataRequest: UpdateUserMetadataRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateUserMetadata(network, lockAddress, userAddress, updateUserMetadataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update or create user metadata for lock.
     * @param {UpdateUsersMetadataRequest} updateUsersMetadataRequest users array containing user metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateUsersMetadata(updateUsersMetadataRequest: UpdateUsersMetadataRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateUsersMetadata(updateUsersMetadataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload images to locksmith
     * @param {Array<any>} [images] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadImages(images?: Array<any>, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadImages(images, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public user(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).user(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if an address is a verifier of the lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public verifier(network: number, lockAddress: string, verifierAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).verifier(network, lockAddress, verifierAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of verifiers for the lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public verifiers(network: number, lockAddress: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).verifiers(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
    }
}


