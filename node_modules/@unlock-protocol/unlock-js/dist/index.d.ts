import { ethers, ContractInterface } from 'ethers';
import { NetworkConfigs, UnlockUniswapRoute } from '@unlock-protocol/types';
import { Token, NativeCurrency } from '@uniswap/sdk-core';
import { SiweMessage } from 'siwe';
import * as axios from 'axios';
import { AxiosRequestConfig, AxiosInstance, AxiosPromise } from 'axios';
import * as graphql_request_build_cjs_types from 'graphql-request/build/cjs/types';

/**
 * UnlockService is class which implements shared behavior between web3Service and walletService.
 * It is not meant to be instantiated (only subclasses should)
 */
declare class UnlockService {
    networks: NetworkConfigs;
    versionForAddress: Record<string, any>;
    [key: string]: any;
    constructor(networks: NetworkConfigs);
    providerForNetwork(networkId: number): ethers.providers.Provider;
    /**
     * Checks if the contract has been deployed at the address.
     * Invokes the callback with the result.
     * Addresses which do not have a contract attached will return 0x
     */
    isUnlockContractDeployed(network: number): Promise<boolean>;
    /**
     * @param {string} address contract address
     * @param {string} versionRetrievalMethodName the method to call to retrieve the contract version
     */
    contractAbiVersion(address: string, versionRetrievalMethodName: any, provider: ethers.providers.Provider): Promise<any>;
    unlockContractAbiVersion(address: string, provider: ethers.providers.Provider): Promise<any>;
    /**
     * Returns the ABI for the Lock contract deployed at the provided address
     * @param {*} address
     */
    lockContractAbiVersion(address: string, provider: ethers.providers.Provider): Promise<any>;
    /**
     * Private method, which given an address will query the lock and return the version of the lock
     * @param {*} address
     */
    _getPublicLockVersionFromContract(address: string, provider: ethers.providers.Provider): Promise<number>;
    /**
     * Private method, which given an address will query the unlock contract to get its version
     * @param {*} address
     */
    _getUnlockVersionFromContract(address: string, provider: ethers.providers.Provider): Promise<number>;
    getContract(address: string, contract: ethers.Contract, provider: ethers.providers.Provider): ethers.Contract;
    getLockContract(lockAddress: string, provider: ethers.providers.Provider): Promise<ethers.Contract>;
    getUnlockContract(unlockAddress: string, provider: ethers.providers.Provider): Promise<ethers.Contract>;
    getHookContract({ network, address, abi, }: {
        network: number;
        address: string;
        abi: ContractInterface;
    }): Promise<ethers.Contract>;
}

type WalletServiceCallback = (_error: Error | null, _hash: string | null, _transaction?: any | null) => unknown;
interface TransactionOptions {
    nonce?: number;
    gasLimit?: ethers.BigNumberish;
    gasPrice?: ethers.BigNumberish;
    maxFeePerGas?: ethers.BigNumberish;
    maxPriorityFeePerGas?: ethers.BigNumberish;
    runEstimate?: boolean;
    value?: ethers.BigNumberish;
}

/**
 * This service reads data from the RPC endpoint.
 * All transactions should be sent via the WalletService.
 */
/**
 * Constructor is called with an object
 * {
 *    [networkId]: {
 *      provider: string,
 *      unlockAddress: string,
 *    },
 *    [networkId2]: {
 *      provider: string,
 *      unlockAddress: string,
 *    }
 *    [networkId3]: {
 *      provider: string,
 *      unlockAddress: string,
 *    }
 * }
 */
declare class Web3Service extends UnlockService {
    /**
     * Method which returns the create2 address based on the factory contract (unlock), the lock template,
     * the account and lock salt (both used to create a unique salt)
     * 0x3d602d80600a3d3981f3363d3d373d3d3d363d73 and 5af43d82803e903d91602b57fd5bf3 are the
     * bytecode for eip-1167 (which defines proxies for locks).
     * @private
     */
    _create2Address(unlockAddress: string, templateAddress: string, account: string, lockSalt: string): string;
    /**
     * Returns details about a transaction
     * @param {*} hash
     * @param {*} network
     * @returns
     */
    getTransaction(hash: string, network: number): Promise<ethers.providers.TransactionResponse>;
    /**
     * This retrieves the balance of an address (contract or account)
     * and formats it to a string of ether.
     * Returns a promise with the balance
     */
    getAddressBalance(address: string, network: number, tokenAddress?: string): Promise<string>;
    /**
     * Refresh the lock's data.
     * We use the block version
     * @return Promise<Lock>
     */
    getLock(address: string, network: number, options?: {
        fields: string[];
    }): Promise<any>;
    /**
     * Tell whether a user is a manager for the lock
     * @param {string} lockAddress
     * @param {string} manager
     * @return Promise<boolean>
     */
    isLockManager(lockAddress: string, manager: string, network: number): Promise<any>;
    /**
     * Returns the key to the lock by the token Id.
     * @param {PropTypes.string} lockAddress
     * @param {PropTypes.number} tokenId
     */
    getKeyByTokenId(lockAddress: string, tokenId: string, network: number): Promise<{
        tokenId: string;
        lock: string;
        owner: any;
        expiration: number;
    }>;
    /**
     * Returns the key expiration to the lock by the account.
     * @private
     * @param {PropTypes.string} lockAddress
     * @param {number} tokenId
     * @return Promise<>
     */
    getKeyExpirationByTokenId(lockAddress: string, tokenId: string, network: number): Promise<number>;
    /**
     * Returns the key to the lock by the account.
     * @param {PropTypes.string} lockAddress
     * @param {PropTypes.string} owner
     */
    getKeyByLockForOwner(lockAddress: string, owner: string, network: number): Promise<{
        lock: string;
        owner: string;
        expiration: number;
        tokenId: number;
    }>;
    /**
     * Returns true if the address has a valid key (will call the hook when applicable!)
     * @param lockAddress
     * @param owner
     * @param network
     */
    getHasValidKey(lockAddress: string, owner: string, network: number): Promise<any>;
    /**
     * Returns the key expiration to the lock by the account.
     * @private
     * @param {PropTypes.string} lockAddress
     * @param {PropTypes.string} owner
     * @return Promise<>
     */
    getKeyExpirationByLockForOwner(lockAddress: string, owner: string, network: number): Promise<any>;
    /**
     * Returns the key expiration to the lock by the account.
     * @private
     * @param {PropTypes.string} lockAddress
     * @param {PropTypes.string} owner
     * @return Promise<>
     */
    getTokenIdForOwner(lockAddress: string, owner: string, network: number): Promise<any>;
    /**
     * Given some data and a signed version of the same, returns the address of the account that signed it
     * @param data
     * @param signedData
     * @returns {Promise<*>}
     */
    recoverAccountFromSignedData<T extends string | ethers.Bytes>(data: T, signedData: ethers.Signature): Promise<string>;
    /**
     * Given an ERC20 token contract address, resolve with the symbol that identifies that token.
     * @param {string} contractAddress
     * @returns {Promise<string>}
     */
    getTokenSymbol(contractAddress: string, network: number): Promise<any>;
    /**
     * Given an ERC20 token contract address, resolve with the provided user's balance of that token.
     * @param {string} contractAddress
     * @param {string} userWalletAddress
     * @returns {Promise<string>}
     */
    getTokenBalance(contractAddress: string, userWalletAddress: string, network: number): Promise<string>;
    getTokenDecimals(contractAddress: string, network: number): Promise<number>;
    /**
     * Yields true if an address is key granter on a lock
     */
    isKeyGranter(lockAddress: string, address: string, network: number): Promise<any>;
    /**
     * Retrieves the key manager for a key
     * @param {*} lockAddress
     * @param {*} tokenId
     * @param {*} network
     */
    keyManagerOf(lockAddress: string, tokenId: string, network: number): Promise<any>;
    /**
     * Returns the owner of a key
     * @param {*} lockAddress
     * @param {*} tokenId
     * @param {*} network
     */
    ownerOf(lockAddress: string, tokenId: string, network: number): Promise<any>;
    /**
     * Returns id a key is valid or not
     * @param {*} lockAddress
     * @param {*} tokenId
     * @param {*} network
     */
    isValidKey(lockAddress: string, tokenId: string, network: number): Promise<any>;
    /**
     * Returns the Ethers contract 'connected' (should be used with care)
     * @param {*} lockAddress
     * @param {*} network
     */
    lockContract(lockAddress: string, network: number): Promise<ethers.Contract>;
    /**
     * Returns numbers of owners for a specific lock
     * @param {*} lockAddress
     * @param {*} network
     */
    numberOfOwners(lockAddress: string, network: number): Promise<number>;
    /**
     * Returns transfer fee for lock
     * @param {*} lockAddress
     * @param {*} network
     */
    transferFeeBasisPoints(lockAddress: string, network: number): Promise<number>;
    /**
     * Returns total of key for a specific address
     * @param {String} lockAddress
     * @param {String} address
     * @param {Number} network
     */
    totalKeys(lockAddress: string, owner: string, network: number): Promise<any>;
    /**
     * Returns lock version
     * @param {String} lockAddress
     * @param {Number} network
     */
    publicLockVersion(lockAddress: string, network: number): Promise<any>;
    tokenURI(lockAddress: string, tokenId: string, network: number): Promise<any>;
    /**
     * Returns the number of keys available for sale
     * @param lockAddress
     * @param network
     * @returns
     */
    keysAvailable(lockAddress: string, network: number): Promise<any>;
    /**
     * Returns how much of a refund a key owner would receive
     * @param lockAddress
     * @param network
     * @param owner
     * @param tokenAddress
     * @param tokenId
     * @returns
     */
    getCancelAndRefundValueFor(params: {
        lockAddress: string;
        owner: string;
        tokenAddress: string;
        network: number;
        tokenId: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    balanceOf(lockAddress: string, owner: string, network: number): Promise<any>;
    tokenOfOwnerByIndex(lockAddress: string, owner: string, index: number, network: number): Promise<any>;
    latestTokenOfOwner(lockAddress: string, owner: string, network: number): Promise<any>;
    /**
     * Returns the number of keys already sold
     * @param lockAddress
     * @param network
     * @returns
     */
    totalSupply(lockAddress: string, network: number): Promise<any>;
    /**
     * Returns the purchase price for the user on the lock
     */
    purchasePriceFor({ lockAddress, userAddress, data, referrer, network, }: {
        lockAddress: string;
        network: number;
        data: string;
        userAddress: string;
        referrer: string;
    }): Promise<any>;
    /**
     * Returns freeTrialLength value
     */
    freeTrialLength({ lockAddress, network, }: {
        lockAddress: string;
        network: number;
    }): Promise<number>;
    /**
     * Returns refundPenaltyBasisPoints value
     */
    refundPenaltyBasisPoints({ lockAddress, network, }: {
        lockAddress: string;
        network: number;
    }): Promise<number>;
    /**
     * Returns onKeyCancelHook value
     */
    onKeyCancelHook({ lockAddress, network, }: {
        lockAddress: string;
        network: number;
    }): Promise<any>;
    /**
     * Returns onKeyPurchaseHook value
     */
    onKeyPurchaseHook({ lockAddress, network, }: {
        lockAddress: string;
        network: number;
    }): Promise<any>;
    /**
     * Returns onKeyTransferHook value
     */
    onKeyTransferHook({ lockAddress, network, }: {
        lockAddress: string;
        network: number;
    }): Promise<any>;
    /**
     * Returns onTokenURIHook value
     */
    onTokenURIHook({ lockAddress, network, }: {
        lockAddress: string;
        network: number;
    }): Promise<any>;
    /**
     * Returns onValidKeyHook value
     */
    onValidKeyHook({ lockAddress, network, }: {
        lockAddress: string;
        network: number;
    }): Promise<any>;
    /**
     * Returns onKeyExtendHook value
     */
    onKeyExtendHook({ lockAddress, network, }: {
        lockAddress: string;
        network: number;
    }): Promise<any>;
    /**
     * Returns onKeyGrantHook value
     */
    onKeyGrantHook({ lockAddress, network, }: {
        lockAddress: string;
        network: number;
    }): Promise<any>;
    /**
     * Returns last lock version
     * @param {Number} network
     */
    publicLockLatestVersion(network: number): Promise<any>;
    /**
     * Returns referrer fees
     */
    referrerFees({ lockAddress, network, address, }: {
        lockAddress: string;
        network: number;
        address: string;
    }): Promise<number>;
    getBaseTokenURI({ lockAddress, network, }: {
        lockAddress: string;
        network: number;
    }): Promise<any>;
    /**
     * Returns an object the contains the resolved address or ens
     * name of the input address with it's type
     */
    resolveName(addressOrEns: string): Promise<"" | {
        input: string;
        name: string;
        address: string | null;
        type: string;
    }>;
    /**
     * Get signer for `Password hook contract`
     */
    getPasswordHookSigners(params: {
        lockAddress: string;
        contractAddress: string;
        network: number;
    }): Promise<any>;
    getUniswapRoute({ params: { tokenOut, amountOut, recipient, tokenIn, network }, }: {
        params: {
            tokenIn: Token | NativeCurrency;
            tokenOut: Token | NativeCurrency;
            amountOut: string;
            recipient: string;
            network: number;
        };
    }): Promise<UnlockUniswapRoute>;
    getTokenIdsFromTx({ params: { hash, network, lockAddress }, }: {
        params: {
            hash: string;
            network: number;
            lockAddress: string;
        };
    }): Promise<any[] | null>;
    getGasRefundValue({ network, lockAddress, }: {
        network: number;
        lockAddress: string;
    }): Promise<string>;
    /**
     * Get signer for `Password hook contract`
     */
    getDiscountHookValues(params: {
        lockAddress: string;
        contractAddress: string;
        network: number;
        signerAddress: string;
    }): Promise<number>;
}

interface CreateLockOptions {
    publicLockVersion?: number | string;
    name: string;
    expirationDuration?: number | string;
    maxNumberOfKeys?: number | string;
    currencyContractAddress?: string | null;
    keyPrice?: string | number;
    creator?: string;
}
interface PurchaseKeyParams {
    lockAddress: string;
    owner?: string;
    keyPrice?: string;
    data?: string | null;
    erc20Address?: string;
    decimals?: number;
    recurringPayments?: number;
    referrer?: string;
    totalApproval?: string;
    keyManager?: string;
    swap?: Omit<SwapOptions, 'callData'>;
}
interface PurchaseKeysParams {
    lockAddress: string;
    owners: string[];
    keyPrices?: string[];
    data?: string[] | null;
    erc20Address?: string;
    decimals?: number;
    referrers?: (string | null)[];
    recurringPayments?: number[] | string[];
    totalApproval?: string;
    keyManagers?: string[];
    swap?: Omit<SwapOptions, 'callData'>;
}
interface SwapOptions {
    srcTokenAddress?: string;
    amountInMax: ethers.BigNumberish;
    uniswapRouter: string;
    swapCallData: string;
    callData: string;
    value: ethers.BigNumberish;
}
interface ExtendKeyParams {
    lockAddress: string;
    tokenId?: string;
    owner?: string;
    referrer?: string;
    data?: string;
    decimals?: number;
    erc20Address?: string;
    keyPrice?: string;
    recurringPayment?: string | number;
    totalApproval?: string;
    swap?: Omit<SwapOptions, 'callData'>;
}
interface GetAndSignAuthorizationsForTransferAndPurchaseParams {
    amount: string;
    lockAddress: string;
    network: number;
}
interface PurchaseWithCardPurchaserParams {
    transfer: any;
    purchase: any;
    callData: string;
}
/**
 * This service interacts with the user's wallet.
 * The functionality is on purpose only about sending transaction and returning the corresponding
 * hashes. Another service (which does not depend on the user;s wallet) will be in charge of
 * actually retrieving the data from the chain/smart contracts
 */
declare class WalletService extends UnlockService {
    /**
     * This needs to be called with a ethers.providers which includes a signer or with a signer
     */
    connect(provider: ethers.providers.Provider, signer?: ethers.Signer): Promise<any>;
    /**
     * Function which yields the address of the account on the provider
     */
    getAccount(): Promise<any>;
    /**
     * This function submits a web3 transaction and will trigger an event as soon as it receives its
     * hash. We then use the web3Service to handle the ongoing transaction (watch for confirmation
     * receipt... etc)
     * A the moment the dispatcher relies on the strict emission, it is imperitive that the emission
     * of these fields not change for the time being!
     * @private
     * @param {Promise} the result of calling a contract method (ethersjs contract)
     * @param {string} the Unlock protocol transaction type
     * @param {Function} a standard node callback that accepts the transaction hash
     */
    _handleMethodCall(methodCall: any): Promise<any>;
    /**
     * Updates the key price on a lock
     * @param {PropTypes.address} lockAddress : address of the lock for which we update the price
     * @param {string} price : new price for the lock
     * @param {function} callback : callback invoked with the transaction hash
     * @return Promise<PropTypes.number> newKeyPrice
     */
    updateKeyPrice(params: {
        lockAddress: string;
        keyPrice: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Creates a lock on behalf of the user.
     * @param {PropTypes.lock} lock
     * @param {function} callback : callback invoked with the transaction hash
     * @return Promise<PropTypes.address> lockAddress
     */
    createLock(lock: CreateLockOptions, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<string>;
    unlockContractAbiVersion(): Promise<any>;
    lockContractAbiVersion(address: string): Promise<any>;
    getUnlockContract(): Promise<ethers.Contract>;
    getLockContract(address: string): Promise<ethers.Contract>;
    /**
     *  Then we need to call initialize on it. This is critical because otherwise anyone can claim it and then self-destruct it, killing all locks which use the same contract after this.
     * @param {*} params
     * @param {*} callback
     */
    initializeTemplate(params: {
        templateAddress: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Purchase a key to a lock by account.
     * The key object is passed so we can keep track of it from the application
     * - {PropTypes.address} lockAddress
     * - {PropTypes.address} owner
     * - {string} keyPrice
     * - {string} data
     * - {PropTypes.address} erc20Address
     * - {number} decimals
     * @param {function} callback : callback invoked with the transaction hash
     */
    purchaseKey(params: PurchaseKeyParams, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Purchase several keys to a lock by account.
     * The key object is passed so we can keep track of it from the application
     * - {PropTypes.address} lockAddress
     * - {PropTypes.arrayOf(PropTypes.address)} owners
     * - {PropTypes.arrayOf(string)} keyPrices
     * - {PropTypes.arrayOf(string)} data
     * - {PropTypes.address} erc20Address
     * - {number} decimals
     * @param {function} callback : callback invoked with the transaction hash
     */
    purchaseKeys(params: PurchaseKeysParams, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Function to renew a membership, callable by anyone.
     * This is only useful for ERC20 locks for which the key owner has approved
     * a large enough token amount!
     * @param params
     * @param callback
     * @returns
     */
    renewMembershipFor(params: {
        lockAddress: string;
        referrer: string | null;
        tokenId: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Extends an expired key
     * @param {*} params
     * @param {*} callback
     */
    extendKey(params: ExtendKeyParams, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Purchase key function. This implementation requires the following
     * @param {object} params:
     * - {PropTypes.address} lockAddress
     * - {number} tokenIdFrom
     * - {number} tokenIdTo
     * - {number} amount if null, will take the entire remaining time of the from key
     * @param {function} callback invoked with the transaction hash
     */
    mergeKeys(params: {
        lockAddress: string;
        tokenIdFrom: string;
        tokenIdTo: string;
        amount?: number;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Set ERC20 allowance to the beneficary
     * @param {object} params:
     * - {PropTypes.address} lockAddress
     * - {string} spender the address of the spender
     * - {number} amount the amount to approve
     * @param {function} callback invoked with the transaction hash
     */
    approveBeneficiary(params: {
        lockAddress: string;
        spender: string;
        amount: number;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Grants permission to grant keys to address
     * @param {*} params
     * @param {*} callback
     */
    addKeyGranter(params: {
        lockAddress: string;
        keyGranter: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Expire and refunds (optional) a key by lock manager
     * @param {*} params
     * @param {*} callback
     */
    expireAndRefundFor(params: {
        lockAddress: string;
        keyOwner: string;
        tokenId: string;
        amount?: string;
        decimals?: number;
        erc20Address?: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Cancels a membership and receive a refund (called by key manager)
     * @param {*} params
     * @param {*} callback
     */
    cancelAndRefund(params: {
        lockAddress: string;
        tokenId: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Shares a key by transfering time from key to another key
     * @param {*} params
     * - {PropTypes.address} lockAddress
     * - {PropTypes.address } recipient
     * - {string}: tokenId the token to share time from
     * - {string}: duration time to share in seconds
     * @param {*} callback
     */
    shareKey(params: {
        lockAddress: string;
        recipient: string;
        tokenId: string;
        duration?: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Grants a key to an address
     * @param {function} callback : callback invoked with the transaction hash
     */
    grantKey(params: {
        lockAddress: string;
        recipient: string;
        expiration?: string;
        transactionOptions?: unknown;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Grant keys to multiple recipient addresses with custom expiration
     * @param {function} callback : callback invoked with the transaction hash
     */
    grantKeys(params: {
        lockAddress: string;
        recipients: string[];
        expirations?: string[];
        keyManagers?: string[];
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Grant key extension. This implementation requires the following
     * @param {object} params:
     * - {PropTypes.address} lockAddress
     * - {number} tokenId
     * - {number} duration default to 0, which will extend the key by the
     *  default duration of the lock
     * @param {function} callback invoked with the transaction hash
     */
    grantKeyExtension(params: {
        lockAddress: string;
        tokenId: string;
        duration: number;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Update the name of a lock
     * @param {object} params:
     * - {PropTypes.address} lockAddress
     * - {string} name the new name of the lock
     * @param {function} callback invoked with the transaction hash
     */
    updateLockName(params: {
        lockAddress: string;
        name: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Update the symbol of a lock
     * @param {object} params:
     * - {PropTypes.address} lockAddress
     * - {string} symbol the new symbol of the lock
     * @param {function} callback invoked with the transaction hash
     */
    updateLockSymbol(params: {
        lockAddress: string;
        symbol: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Update the base URI used to parse the tokenURI
     * @param {object} params:
     * - {PropTypes.address} lockAddress
     * - {string} baseTokenURI the new baseTokenURI of the lock
     * @param {function} callback invoked with the transaction hash
     */
    setBaseTokenURI(params: {
        lockAddress: string;
        baseTokenURI: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Triggers a transaction to withdraw funds from the lock and assign them to the owner.
     * @param {object} params
     * - {PropTypes.address} lockAddress
     * - {string} amount the amount to withdraw (0 to withdraw the entire balance)
     * - {string} Erc20Address the address of the ERC20 currency to withdraw
     * - {number} decimals the number of decimals of the ERC20
     * - {string} beneficary the address that will receive the funds (only v12+)
     * @param {function} callback : callback invoked with the transaction hash
     */
    withdrawFromLock(params: {
        lockAddress: string;
        amount?: string;
        decimals?: number;
        erc20Address?: string;
        beneficiary?: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Tries multiple approaches for eth_signTypedData
     * @param {*} account
     * @param {*} data
     */
    unformattedSignTypedData(account: string, data: any): Promise<unknown>;
    signMessage(data: any, method: any): Promise<any>;
    setMaxNumberOfKeys(params: {
        lockAddress: string;
        maxNumberOfKeys: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    setMaxKeysPerAddress(params: {
        lockAddress: string;
        maxKeysPerAddress: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    setExpirationDuration(params: {
        lockAddress: string;
        expirationDuration: number | string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Add lock manager to Contact
     * @param {*} params
     * @param {*} callback
     */
    addLockManager(params: {
        lockAddress: string;
        userAddress: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Renounce lock manager status for Contract
     * @param {*} params
     * @param {*} callback
     */
    renounceLockManager(params: {
        lockAddress: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Update Refund Penalty: Allow the owner to change the refund penalty.
     * @param {*} params
     * @param {*} callback
     */
    updateRefundPenalty(params: {
        lockAddress: string;
        freeTrialLength: number;
        refundPenaltyBasisPoints: number;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Allows a Lock manager to update or remove an event hook
     * @param {*} params
     * @param {*} callback
     */
    setEventHooks(params: {
        lockAddress: string;
        keyPurchase?: string;
        keyCancel?: string;
        validKey?: string;
        tokenURI?: string;
        keyTransfer?: string;
        keyExtend?: string;
        keyGrant?: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Allow a Lock manager to change the transfer fee.
     * @param {*} params
     * @param {*} callback
     */
    updateTransferFee(params: {
        lockAddress: string;
        transferFeeBasisPoints: number;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    upgradeLock(params: {
        lockAddress: string;
        lockVersion: number;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<string>;
    /**
     * Update referrer fee
     * @param {*} params
     * @param {*} callback
     */
    setReferrerFee(params: {
        lockAddress: string;
        address: string;
        feeBasisPoint: number;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Set signer for `Password hook contract`
     */
    setPasswordHookSigner(params: {
        lockAddress: string;
        signerAddress: string;
        contractAddress: string;
        network: number;
    }, signer: ethers.Wallet | ethers.providers.JsonRpcSigner): Promise<any>;
    /**
     * Change lock manager for a specific key
     * @param {*} params
     * @param {*} callback
     */
    setKeyManagerOf(params: {
        lockAddress: string;
        managerAddress: string;
        tokenId: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Returns the ethers contract object for the UnlockSwapPurchaser contract
     * @param param0
     * @returns
     */
    getUnlockSwapPurchaserContract({ params: { network }, }: {
        params: {
            network: number;
        };
    }): ethers.Contract;
    /**
     * This yields the authorizations required to spend USDC on behalf of the user
     * to buy a key from a specific lock. This is mostly used for the universal
     * card support!
     * @param param0
     * @returns
     */
    getAndSignAuthorizationsForTransferAndPurchase({ amount, lockAddress, network, }: GetAndSignAuthorizationsForTransferAndPurchaseParams): Promise<{
        transferSignature: any;
        transferMessage: {
            from: any;
            to: string;
            value: string;
            validAfter: number;
            validBefore: number;
            nonce: string;
        };
        purchaseSignature: string;
        purchaseMessage: {
            sender: string;
            lock: string;
            expiration: number;
        };
    }>;
    /**
     * Performs a purchase using the CardPurchaser contract
     * @param param0
     * @returns
     */
    purchaseWithCardPurchaser({ transfer, purchase, callData, }: PurchaseWithCardPurchaserParams): Promise<any>;
    /**
     * Transfers a specific NFT  from one account to another
     * @returns
     */
    transferFrom(params: {
        keyOwner: string;
        to: string;
        tokenId: string;
        lockAddress: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    setGasRefund(params: {
        lockAddress: string;
        gasRefundValue: string;
    }, transactionOptions?: TransactionOptions, callback?: WalletServiceCallback): Promise<any>;
    /**
     * Set signer for `Discount code` hook contract
     */
    setDiscountCodeHookSigner(params: {
        lockAddress: string;
        signerAddress: string;
        contractAddress: string;
        network: number;
        discountPercentage: number;
    }): Promise<any>;
}

declare function getCurrentProvider(environment: any): "Opera" | "Metamask" | "Trust" | "Coinbase Wallet" | "Cipher" | "Mist" | "Parity" | "Infura" | "localhost" | "UnknownProvider";
declare function getWeb3Provider(url: string): string;

/**
 * Unlock Locksmith
 * Locksmith provides backend functionality for enabling ticketing, metadata storage, and notification hooks.
 *
 * The version of the OpenAPI document: 2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    baseOptions?: any;
    formDataCtor?: new () => any;
}
declare class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;
    constructor(param?: ConfigurationParameters);
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime: string): boolean;
}

/**
 * Unlock Locksmith
 * Locksmith provides backend functionality for enabling ticketing, metadata storage, and notification hooks.
 *
 * The version of the OpenAPI document: 2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/**
 *
 * @export
 * @interface RequestArgs
 */
interface RequestArgs {
    url: string;
    options: AxiosRequestConfig;
}
/**
 *
 * @export
 * @class BaseAPI
 */
declare class BaseAPI {
    protected basePath: string;
    protected axios: AxiosInstance;
    protected configuration: Configuration | undefined;
    constructor(configuration?: Configuration, basePath?: string, axios?: AxiosInstance);
}

/**
 *
 * @export
 * @interface Application
 */
interface Application {
    /**
     *
     * @type {number}
     * @memberof Application
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof Application
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof Application
     */
    'key'?: string | null;
    /**
     *
     * @type {string}
     * @memberof Application
     */
    'walletAddress'?: string;
}
/**
 *
 * @export
 * @interface ApplicationBody
 */
interface ApplicationBody {
    /**
     *
     * @type {string}
     * @memberof ApplicationBody
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof ApplicationBody
     */
    'key'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ApplicationBody
     */
    'walletAddress'?: string;
}
/**
 *
 * @export
 * @interface Applications200Response
 */
interface Applications200Response {
    /**
     *
     * @type {Array<Application>}
     * @memberof Applications200Response
     */
    'results'?: Array<Application>;
}
/**
 *
 * @export
 * @interface Auth
 */
interface Auth {
    /**
     *
     * @type {string}
     * @memberof Auth
     */
    'walletAddress': string;
}
/**
 *
 * @export
 * @interface AuthResult
 */
interface AuthResult {
    /**
     *
     * @type {string}
     * @memberof AuthResult
     */
    'walletAddress': string | null;
    /**
     *
     * @type {string}
     * @memberof AuthResult
     */
    'accessToken': string;
}
/**
 *
 * @export
 * @interface Balance200ResponseValue
 */
interface Balance200ResponseValue {
    /**
     *
     * @type {string}
     * @memberof Balance200ResponseValue
     */
    'address'?: string;
    /**
     *
     * @type {string}
     * @memberof Balance200ResponseValue
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof Balance200ResponseValue
     */
    'balance'?: string;
}
/**
 *
 * @export
 * @interface CaptureOnRampSession200Response
 */
interface CaptureOnRampSession200Response {
    /**
     *
     * @type {string}
     * @memberof CaptureOnRampSession200Response
     */
    'hash'?: string;
}
/**
 *
 * @export
 * @interface CapturePurchaseRequest
 */
interface CapturePurchaseRequest {
    /**
     *
     * @type {Array<string>}
     * @memberof CapturePurchaseRequest
     */
    'recipients'?: Array<string>;
    /**
     *
     * @type {number}
     * @memberof CapturePurchaseRequest
     */
    'network': number;
    /**
     *
     * @type {string}
     * @memberof CapturePurchaseRequest
     */
    'lock': string;
    /**
     *
     * @type {string}
     * @memberof CapturePurchaseRequest
     */
    'userAddress': string;
    /**
     *
     * @type {string}
     * @memberof CapturePurchaseRequest
     */
    'paymentIntent': string;
    /**
     *
     * @type {Array<string>}
     * @memberof CapturePurchaseRequest
     */
    'data'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof CapturePurchaseRequest
     */
    'referrers'?: Array<string>;
    /**
     * whether to extend or purchase membership for the recipient.
     * @type {string}
     * @memberof CapturePurchaseRequest
     */
    'purchaseType'?: CapturePurchaseRequestPurchaseTypeEnum;
}
declare const CapturePurchaseRequestPurchaseTypeEnum: {
    readonly Extend: "extend";
    readonly Purchase: "purchase";
};
type CapturePurchaseRequestPurchaseTypeEnum = typeof CapturePurchaseRequestPurchaseTypeEnum[keyof typeof CapturePurchaseRequestPurchaseTypeEnum];
/**
 *
 * @export
 * @interface CheckClaim200Response
 */
interface CheckClaim200Response {
    /**
     *
     * @type {boolean}
     * @memberof CheckClaim200Response
     */
    'canClaim'?: boolean;
}
/**
 *
 * @export
 * @interface CheckClaimRequest
 */
interface CheckClaimRequest {
    /**
     *
     * @type {Array<string>}
     * @memberof CheckClaimRequest
     */
    'recipients'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof CheckClaimRequest
     */
    'data'?: Array<string>;
}
/**
 *
 * @export
 * @interface CheckoutConfig
 */
interface CheckoutConfig {
    /**
     *
     * @type {string}
     * @memberof CheckoutConfig
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof CheckoutConfig
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CheckoutConfig
     */
    'by': string;
    /**
     *
     * @type {{ [key: string]: any; }}
     * @memberof CheckoutConfig
     */
    'config': {
        [key: string]: any;
    };
    /**
     *
     * @type {string}
     * @memberof CheckoutConfig
     */
    'createdAt'?: string;
    /**
     *
     * @type {string}
     * @memberof CheckoutConfig
     */
    'updatedAt'?: string;
}
/**
 *
 * @export
 * @interface Claim200Response
 */
interface Claim200Response {
    /**
     *
     * @type {string}
     * @memberof Claim200Response
     */
    'transactionHash'?: string;
    /**
     *
     * @type {string}
     * @memberof Claim200Response
     */
    'owner'?: string;
}
/**
 *
 * @export
 * @interface ClaimRequest
 */
interface ClaimRequest {
    /**
     *
     * @type {string}
     * @memberof ClaimRequest
     */
    'data'?: string;
    /**
     * Email address of the recipient
     * @type {string}
     * @memberof ClaimRequest
     */
    'email'?: string;
    /**
     * Recipient address for key
     * @type {string}
     * @memberof ClaimRequest
     */
    'recipient'?: string;
}
/**
 *
 * @export
 * @interface ConnectStripeAccount200Response
 */
interface ConnectStripeAccount200Response {
    /**
     *
     * @type {string}
     * @memberof ConnectStripeAccount200Response
     */
    'url'?: string;
    /**
     *
     * @type {number}
     * @memberof ConnectStripeAccount200Response
     */
    'created'?: number;
    /**
     *
     * @type {number}
     * @memberof ConnectStripeAccount200Response
     */
    'expiresAt'?: number;
    /**
     *
     * @type {string}
     * @memberof ConnectStripeAccount200Response
     */
    'object'?: string;
}
/**
 *
 * @export
 * @interface ConnectStripeAccountRequest
 */
interface ConnectStripeAccountRequest {
    /**
     *
     * @type {string}
     * @memberof ConnectStripeAccountRequest
     */
    'baseUrl': string;
    /**
     *
     * @type {string}
     * @memberof ConnectStripeAccountRequest
     */
    'stripeAccount'?: string;
}
/**
 *
 * @export
 * @interface CreateLockContract201Response
 */
interface CreateLockContract201Response {
    /**
     *
     * @type {string}
     * @memberof CreateLockContract201Response
     */
    'transactionHash'?: string;
}
/**
 *
 * @export
 * @interface CreateOnRampSessionRequest
 */
interface CreateOnRampSessionRequest {
    /**
     *
     * @type {string}
     * @memberof CreateOnRampSessionRequest
     */
    'transferSignature'?: string;
    /**
     *
     * @type {CreateOnRampSessionRequestTransferMessage}
     * @memberof CreateOnRampSessionRequest
     */
    'transferMessage'?: CreateOnRampSessionRequestTransferMessage;
    /**
     *
     * @type {string}
     * @memberof CreateOnRampSessionRequest
     */
    'purchaseSignature'?: string;
    /**
     *
     * @type {CreateOnRampSessionRequestPurchaseMessage}
     * @memberof CreateOnRampSessionRequest
     */
    'purchaseMessage'?: CreateOnRampSessionRequestPurchaseMessage;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateOnRampSessionRequest
     */
    'recipients'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateOnRampSessionRequest
     */
    'purchaseData'?: Array<string>;
}
/**
 *
 * @export
 * @interface CreateOnRampSessionRequestPurchaseMessage
 */
interface CreateOnRampSessionRequestPurchaseMessage {
    /**
     *
     * @type {string}
     * @memberof CreateOnRampSessionRequestPurchaseMessage
     */
    'lock': string;
    /**
     *
     * @type {string}
     * @memberof CreateOnRampSessionRequestPurchaseMessage
     */
    'sender': string;
    /**
     *
     * @type {number}
     * @memberof CreateOnRampSessionRequestPurchaseMessage
     */
    'expiration': number;
}
/**
 *
 * @export
 * @interface CreateOnRampSessionRequestTransferMessage
 */
interface CreateOnRampSessionRequestTransferMessage {
    /**
     *
     * @type {string}
     * @memberof CreateOnRampSessionRequestTransferMessage
     */
    'from': string;
    /**
     *
     * @type {string}
     * @memberof CreateOnRampSessionRequestTransferMessage
     */
    'nonce': string;
    /**
     *
     * @type {string}
     * @memberof CreateOnRampSessionRequestTransferMessage
     */
    'to': string;
    /**
     *
     * @type {number}
     * @memberof CreateOnRampSessionRequestTransferMessage
     */
    'validAfter': number;
    /**
     *
     * @type {number}
     * @memberof CreateOnRampSessionRequestTransferMessage
     */
    'validBefore': number;
    /**
     *
     * @type {string}
     * @memberof CreateOnRampSessionRequestTransferMessage
     */
    'value': string;
}
/**
 *
 * @export
 * @interface CreateTransferCode200Response
 */
interface CreateTransferCode200Response {
    /**
     *
     * @type {string}
     * @memberof CreateTransferCode200Response
     */
    'owner': string;
    /**
     *
     * @type {string}
     * @memberof CreateTransferCode200Response
     */
    'lock': string;
    /**
     *
     * @type {string}
     * @memberof CreateTransferCode200Response
     */
    'token': string;
    /**
     *
     * @type {number}
     * @memberof CreateTransferCode200Response
     */
    'deadline': number;
    /**
     * Part of the transfer code that is required to be used with the part sent to the recipient.
     * @type {string}
     * @memberof CreateTransferCode200Response
     */
    'transferCode': string;
}
/**
 *
 * @export
 * @interface CreateTransferCode404Response
 */
interface CreateTransferCode404Response {
    /**
     *
     * @type {string}
     * @memberof CreateTransferCode404Response
     */
    'message': string;
}
/**
 *
 * @export
 * @interface DeleteCheckoutConfig200Response
 */
interface DeleteCheckoutConfig200Response {
    /**
     *
     * @type {string}
     * @memberof DeleteCheckoutConfig200Response
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface EmailTicket200Response
 */
interface EmailTicket200Response {
    /**
     *
     * @type {boolean}
     * @memberof EmailTicket200Response
     */
    'sent'?: boolean;
}
/**
 *
 * @export
 * @interface EventDetails
 */
interface EventDetails {
    /**
     *
     * @type {string}
     * @memberof EventDetails
     */
    'eventName'?: string;
    /**
     *
     * @type {string}
     * @memberof EventDetails
     */
    'eventDescription'?: string;
    /**
     *
     * @type {string}
     * @memberof EventDetails
     */
    'eventDate'?: string;
    /**
     *
     * @type {string}
     * @memberof EventDetails
     */
    'eventTime'?: string;
    /**
     *
     * @type {string}
     * @memberof EventDetails
     */
    'eventAddress'?: string;
    /**
     *
     * @type {string}
     * @memberof EventDetails
     */
    'startDate'?: string;
    /**
     *
     * @type {string}
     * @memberof EventDetails
     */
    'endDate'?: string;
}
/**
 *
 * @export
 * @interface GenericInvalidBodyError
 */
interface GenericInvalidBodyError {
    /**
     *
     * @type {string}
     * @memberof GenericInvalidBodyError
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof GenericInvalidBodyError
     */
    'error'?: string | null;
}
/**
 *
 * @export
 * @interface GenericNotFound
 */
interface GenericNotFound {
    /**
     *
     * @type {string}
     * @memberof GenericNotFound
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface GenericServerError
 */
interface GenericServerError {
    /**
     *
     * @type {string}
     * @memberof GenericServerError
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface GenericSuccess
 */
interface GenericSuccess {
    /**
     *
     * @type {string}
     * @memberof GenericSuccess
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface GetChargesForLock200Response
 */
interface GetChargesForLock200Response {
    /**
     *
     * @type {number}
     * @memberof GetChargesForLock200Response
     */
    'total': number;
    /**
     *
     * @type {number}
     * @memberof GetChargesForLock200Response
     */
    'creditCardProcessingFee'?: number;
    /**
     *
     * @type {number}
     * @memberof GetChargesForLock200Response
     */
    'unlockServiceFee': number;
    /**
     *
     * @type {number}
     * @memberof GetChargesForLock200Response
     */
    'gasCost': number;
    /**
     *
     * @type {Array<GetChargesForLock200ResponsePricesInner>}
     * @memberof GetChargesForLock200Response
     */
    'prices'?: Array<GetChargesForLock200ResponsePricesInner>;
}
/**
 *
 * @export
 * @interface GetChargesForLock200ResponsePricesInner
 */
interface GetChargesForLock200ResponsePricesInner {
    /**
     *
     * @type {string}
     * @memberof GetChargesForLock200ResponsePricesInner
     */
    'userAddress': string;
    /**
     *
     * @type {string}
     * @memberof GetChargesForLock200ResponsePricesInner
     */
    'amount': string;
    /**
     *
     * @type {string}
     * @memberof GetChargesForLock200ResponsePricesInner
     */
    'symbol': string;
}
/**
 *
 * @export
 * @interface GetCustomEmailContent200Response
 */
interface GetCustomEmailContent200Response {
    /**
     *
     * @type {string}
     * @memberof GetCustomEmailContent200Response
     */
    'lockAddress'?: string;
    /**
     *
     * @type {number}
     * @memberof GetCustomEmailContent200Response
     */
    'network'?: number;
    /**
     *
     * @type {string}
     * @memberof GetCustomEmailContent200Response
     */
    'template'?: string;
    /**
     *
     * @type {string}
     * @memberof GetCustomEmailContent200Response
     */
    'content'?: string;
}
/**
 *
 * @export
 * @interface GetDataForRecipientsAndGuild200Response
 */
interface GetDataForRecipientsAndGuild200Response {
    /**
     *
     * @type {Array<string>}
     * @memberof GetDataForRecipientsAndGuild200Response
     */
    'result'?: Array<string>;
}
/**
 *
 * @export
 * @interface GetLockStripeConnectionDetails200Response
 */
interface GetLockStripeConnectionDetails200Response {
    /**
     *
     * @type {GetLockStripeConnectionDetails200ResponseCountrySpec}
     * @memberof GetLockStripeConnectionDetails200Response
     */
    'countrySpec'?: GetLockStripeConnectionDetails200ResponseCountrySpec;
    /**
     *
     * @type {GetLockStripeConnectionDetails200ResponseAccount}
     * @memberof GetLockStripeConnectionDetails200Response
     */
    'account'?: GetLockStripeConnectionDetails200ResponseAccount;
    /**
     *
     * @type {number}
     * @memberof GetLockStripeConnectionDetails200Response
     */
    'connected'?: number;
}
/**
 *
 * @export
 * @interface GetLockStripeConnectionDetails200ResponseAccount
 */
interface GetLockStripeConnectionDetails200ResponseAccount {
    /**
     *
     * @type {string}
     * @memberof GetLockStripeConnectionDetails200ResponseAccount
     */
    'id'?: string;
    /**
     *
     * @type {boolean}
     * @memberof GetLockStripeConnectionDetails200ResponseAccount
     */
    'charges_enabled'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof GetLockStripeConnectionDetails200ResponseAccount
     */
    'payouts_enabled'?: boolean;
    /**
     *
     * @type {GetLockStripeConnectionDetails200ResponseAccountRequirements}
     * @memberof GetLockStripeConnectionDetails200ResponseAccount
     */
    'requirements'?: GetLockStripeConnectionDetails200ResponseAccountRequirements;
}
/**
 *
 * @export
 * @interface GetLockStripeConnectionDetails200ResponseAccountRequirements
 */
interface GetLockStripeConnectionDetails200ResponseAccountRequirements {
    /**
     *
     * @type {string}
     * @memberof GetLockStripeConnectionDetails200ResponseAccountRequirements
     */
    'disabled_reason'?: string;
}
/**
 *
 * @export
 * @interface GetLockStripeConnectionDetails200ResponseCountrySpec
 */
interface GetLockStripeConnectionDetails200ResponseCountrySpec {
    /**
     *
     * @type {Array<string>}
     * @memberof GetLockStripeConnectionDetails200ResponseCountrySpec
     */
    'supported_payment_currencies'?: Array<string>;
}
/**
 *
 * @export
 * @interface GetReceipt200Response
 */
interface GetReceipt200Response {
    /**
     *
     * @type {GetReceipt200ResponsePurchaser}
     * @memberof GetReceipt200Response
     */
    'purchaser'?: GetReceipt200ResponsePurchaser;
    /**
     *
     * @type {GetReceipt200ResponseSupplier}
     * @memberof GetReceipt200Response
     */
    'supplier'?: GetReceipt200ResponseSupplier;
    /**
     *
     * @type {GetReceipt200ResponseReceipt}
     * @memberof GetReceipt200Response
     */
    'receipt'?: GetReceipt200ResponseReceipt;
}
/**
 *
 * @export
 * @interface GetReceipt200ResponsePurchaser
 */
interface GetReceipt200ResponsePurchaser {
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'email'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'fullname'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'businessName'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'addressLine1'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'addressLine2'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'city'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'state'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'zip'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponsePurchaser
     */
    'country'?: string;
}
/**
 *
 * @export
 * @interface GetReceipt200ResponseReceipt
 */
interface GetReceipt200ResponseReceipt {
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponseReceipt
     */
    'id'?: string;
    /**
     *
     * @type {number}
     * @memberof GetReceipt200ResponseReceipt
     */
    'timestamp'?: number;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponseReceipt
     */
    'sender'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponseReceipt
     */
    'payer'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponseReceipt
     */
    'lockAddress'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponseReceipt
     */
    'tokenAddress'?: string;
    /**
     *
     * @type {number}
     * @memberof GetReceipt200ResponseReceipt
     */
    'gasTotal'?: number;
    /**
     *
     * @type {number}
     * @memberof GetReceipt200ResponseReceipt
     */
    'amountTransferred'?: number;
}
/**
 *
 * @export
 * @interface GetReceipt200ResponseSupplier
 */
interface GetReceipt200ResponseSupplier {
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'supplierName'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'vat'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'servicePerformed'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'addressLine1'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'addressLine2'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'city'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'state'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'zip'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipt200ResponseSupplier
     */
    'country'?: string;
}
/**
 *
 * @export
 * @interface GetReceipts200Response
 */
interface GetReceipts200Response {
    /**
     *
     * @type {Array<GetReceipts200ResponseItemsInner>}
     * @memberof GetReceipts200Response
     */
    'items'?: Array<GetReceipts200ResponseItemsInner>;
}
/**
 *
 * @export
 * @interface GetReceipts200ResponseItemsInner
 */
interface GetReceipts200ResponseItemsInner {
    /**
     *
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'receiptNumber'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'timestamp'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'sender'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'payer'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'lockAddress'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'tokenAddress'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'gasTotal'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'amountTransferred'?: string;
    /**
     *
     * @type {number}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'network'?: number;
    /**
     *
     * @type {string}
     * @memberof GetReceipts200ResponseItemsInner
     */
    'supplierAddress'?: string;
}
/**
 *
 * @export
 * @interface GetReceiptsBase200Response
 */
interface GetReceiptsBase200Response {
    /**
     *
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'supplierName'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'vat'?: string;
    /**
     *
     * @type {number}
     * @memberof GetReceiptsBase200Response
     */
    'vatBasisPointsRate'?: number;
    /**
     *
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'servicePerformed'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'addressLine1'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'addressLine2'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'city'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'state'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'zip'?: string;
    /**
     *
     * @type {string}
     * @memberof GetReceiptsBase200Response
     */
    'country'?: string;
}
/**
 *
 * @export
 * @interface GetStripeConnections200Response
 */
interface GetStripeConnections200Response {
    /**
     *
     * @type {Array<object>}
     * @memberof GetStripeConnections200Response
     */
    'result'?: Array<object>;
    /**
     *
     * @type {string}
     * @memberof GetStripeConnections200Response
     */
    'error'?: string | null;
}
/**
 *
 * @export
 * @interface GetSubscription200Response
 */
interface GetSubscription200Response {
    /**
     *
     * @type {Array<GetSubscription200ResponseSubscriptionsInner>}
     * @memberof GetSubscription200Response
     */
    'subscriptions'?: Array<GetSubscription200ResponseSubscriptionsInner>;
}
/**
 *
 * @export
 * @interface GetSubscription200ResponseSubscriptionsInner
 */
interface GetSubscription200ResponseSubscriptionsInner {
    /**
     *
     * @type {number}
     * @memberof GetSubscription200ResponseSubscriptionsInner
     */
    'next'?: number | null;
    /**
     *
     * @type {GetSubscription200ResponseSubscriptionsInnerBalance}
     * @memberof GetSubscription200ResponseSubscriptionsInner
     */
    'balance'?: GetSubscription200ResponseSubscriptionsInnerBalance;
    /**
     *
     * @type {GetSubscription200ResponseSubscriptionsInnerBalance}
     * @memberof GetSubscription200ResponseSubscriptionsInner
     */
    'price'?: GetSubscription200ResponseSubscriptionsInnerBalance;
    /**
     * Approved number of renewals by user.
     * @type {string}
     * @memberof GetSubscription200ResponseSubscriptionsInner
     */
    'approvedRenewals'?: string;
    /**
     * Possible number of renewals based on the user account balance.
     * @type {string}
     * @memberof GetSubscription200ResponseSubscriptionsInner
     */
    'possibleRenewals'?: string;
    /**
     * The type of payment method used for the subscription.
     * @type {string}
     * @memberof GetSubscription200ResponseSubscriptionsInner
     */
    'type'?: GetSubscription200ResponseSubscriptionsInnerTypeEnum;
}
declare const GetSubscription200ResponseSubscriptionsInnerTypeEnum: {
    readonly Crypto: "crypto";
    readonly Fiat: "fiat";
};
type GetSubscription200ResponseSubscriptionsInnerTypeEnum = typeof GetSubscription200ResponseSubscriptionsInnerTypeEnum[keyof typeof GetSubscription200ResponseSubscriptionsInnerTypeEnum];
/**
 *
 * @export
 * @interface GetSubscription200ResponseSubscriptionsInnerBalance
 */
interface GetSubscription200ResponseSubscriptionsInnerBalance {
    /**
     *
     * @type {string}
     * @memberof GetSubscription200ResponseSubscriptionsInnerBalance
     */
    'symbol'?: string;
    /**
     *
     * @type {string}
     * @memberof GetSubscription200ResponseSubscriptionsInnerBalance
     */
    'amount'?: string;
    /**
     *
     * @type {number}
     * @memberof GetSubscription200ResponseSubscriptionsInnerBalance
     */
    'decimals'?: number;
}
/**
 *
 * @export
 * @interface GetTicket200Response
 */
interface GetTicket200Response {
    /**
     *
     * @type {string}
     * @memberof GetTicket200Response
     */
    'keyId': string;
    /**
     *
     * @type {string}
     * @memberof GetTicket200Response
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof GetTicket200Response
     */
    'owner': string;
    /**
     *
     * @type {string}
     * @memberof GetTicket200Response
     */
    'manager': string;
    /**
     *
     * @type {string}
     * @memberof GetTicket200Response
     */
    'lockAddress': string;
    /**
     *
     * @type {string}
     * @memberof GetTicket200Response
     */
    'image': string;
    /**
     *
     * @type {string}
     * @memberof GetTicket200Response
     */
    'description': string;
    /**
     *
     * @type {number}
     * @memberof GetTicket200Response
     */
    'checkedInAt'?: number;
    /**
     *
     * @type {{ [key: string]: any; }}
     * @memberof GetTicket200Response
     */
    'userMetadata': {
        [key: string]: any;
    };
    /**
     *
     * @type {string}
     * @memberof GetTicket200Response
     */
    'expiration': string;
    /**
     *
     * @type {Array<GetTicket200ResponseAttributesInner>}
     * @memberof GetTicket200Response
     */
    'attributes': Array<GetTicket200ResponseAttributesInner>;
    /**
     *
     * @type {string}
     * @memberof GetTicket200Response
     */
    'publicLockVersion': string;
    /**
     * Whether the user who requested the ticket can verify the ticket.
     * @type {boolean}
     * @memberof GetTicket200Response
     */
    'isVerifier': boolean;
}
/**
 *
 * @export
 * @interface GetTicket200ResponseAttributesInner
 */
interface GetTicket200ResponseAttributesInner {
    /**
     *
     * @type {string}
     * @memberof GetTicket200ResponseAttributesInner
     */
    'trait_type'?: string;
    /**
     *
     * @type {string}
     * @memberof GetTicket200ResponseAttributesInner
     */
    'value': string;
    /**
     *
     * @type {string}
     * @memberof GetTicket200ResponseAttributesInner
     */
    'display_type'?: string;
}
/**
 *
 * @export
 * @interface GetTotalPrice200Response
 */
interface GetTotalPrice200Response {
    /**
     *
     * @type {number}
     * @memberof GetTotalPrice200Response
     */
    'total': number;
    /**
     *
     * @type {number}
     * @memberof GetTotalPrice200Response
     */
    'subtotal': number;
    /**
     *
     * @type {number}
     * @memberof GetTotalPrice200Response
     */
    'gasCost': number;
    /**
     *
     * @type {number}
     * @memberof GetTotalPrice200Response
     */
    'unlockServiceFee': number;
    /**
     *
     * @type {number}
     * @memberof GetTotalPrice200Response
     */
    'creditCardProcessingFee': number;
    /**
     *
     * @type {boolean}
     * @memberof GetTotalPrice200Response
     */
    'isCreditCardPurchasable': boolean;
}
/**
 *
 * @export
 * @interface IsCardPaymentEnabledForLock200Response
 */
interface IsCardPaymentEnabledForLock200Response {
    /**
     *
     * @type {boolean}
     * @memberof IsCardPaymentEnabledForLock200Response
     */
    'creditCardEnabled'?: boolean;
}
/**
 *
 * @export
 * @interface KeyMetadata
 */
interface KeyMetadata {
    /**
     *
     * @type {string}
     * @memberof KeyMetadata
     */
    'token'?: string;
    /**
     *
     * @type {string}
     * @memberof KeyMetadata
     */
    'lockName'?: string;
    /**
     *
     * @type {string}
     * @memberof KeyMetadata
     */
    'lockAddress'?: string;
    /**
     *
     * @type {number}
     * @memberof KeyMetadata
     */
    'expiration'?: number;
    /**
     *
     * @type {string}
     * @memberof KeyMetadata
     */
    'keyHolderAddress'?: string;
}
/**
 *
 * @export
 * @interface KeyMetadata200Response
 */
interface KeyMetadata200Response {
    [key: string]: any;
    /**
     *
     * @type {string}
     * @memberof KeyMetadata200Response
     */
    'keyId'?: string;
    /**
     *
     * @type {string}
     * @memberof KeyMetadata200Response
     */
    'lockAddress'?: string;
    /**
     *
     * @type {number}
     * @memberof KeyMetadata200Response
     */
    'network'?: number;
}
/**
 *
 * @export
 * @interface ListCheckoutConfigs200Response
 */
interface ListCheckoutConfigs200Response {
    /**
     *
     * @type {Array<CheckoutConfig>}
     * @memberof ListCheckoutConfigs200Response
     */
    'results'?: Array<CheckoutConfig>;
}
/**
 *
 * @export
 * @interface ListPaymentMethods200Response
 */
interface ListPaymentMethods200Response {
    /**
     *
     * @type {Array<PaymentMethod>}
     * @memberof ListPaymentMethods200Response
     */
    'methods'?: Array<PaymentMethod>;
}
/**
 *
 * @export
 * @interface LockContractOptions
 */
interface LockContractOptions {
    /**
     *
     * @type {string}
     * @memberof LockContractOptions
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof LockContractOptions
     */
    'expirationDuration'?: string | null;
    /**
     *
     * @type {string}
     * @memberof LockContractOptions
     */
    'maxNumberOfKeys'?: string | null;
    /**
     *
     * @type {string}
     * @memberof LockContractOptions
     */
    'keyPrice'?: string;
    /**
     *
     * @type {string}
     * @memberof LockContractOptions
     */
    'creator'?: string | null;
    /**
     *
     * @type {string}
     * @memberof LockContractOptions
     */
    'currencyContractAddress'?: string | null;
    /**
     *
     * @type {number}
     * @memberof LockContractOptions
     */
    'publicLockVersion'?: number | null;
}
/**
 *
 * @export
 * @interface LockSettings
 */
interface LockSettings {
    /**
     *
     * @type {string}
     * @memberof LockSettings
     */
    'lockAddress'?: string;
    /**
     *
     * @type {number}
     * @memberof LockSettings
     */
    'network'?: number;
    /**
     *
     * @type {boolean}
     * @memberof LockSettings
     */
    'sendEmail'?: boolean;
    /**
     *
     * @type {string}
     * @memberof LockSettings
     */
    'slug'?: string;
    /**
     *
     * @type {string}
     * @memberof LockSettings
     */
    'replyTo'?: string | null;
    /**
     *
     * @type {number}
     * @memberof LockSettings
     */
    'creditCardPrice'?: number | null;
    /**
     *
     * @type {string}
     * @memberof LockSettings
     */
    'emailSender'?: string | null;
    /**
     *
     * @type {string}
     * @memberof LockSettings
     */
    'checkoutConfigId'?: string | null;
    /**
     *
     * @type {string}
     * @memberof LockSettings
     */
    'hookGuildId'?: string | null;
    /**
     *
     * @type {boolean}
     * @memberof LockSettings
     */
    'unlockFeeChargedToUser'?: boolean;
    /**
     *
     * @type {string}
     * @memberof LockSettings
     */
    'creditCardCurrency'?: string;
    /**
     *
     * @type {string}
     * @memberof LockSettings
     */
    'crossmintClientId'?: string | null;
}
/**
 *
 * @export
 * @interface LoginRequest
 */
interface LoginRequest {
    /**
     *
     * @type {string}
     * @memberof LoginRequest
     */
    'message'?: string;
    /**
     *
     * @type {string}
     * @memberof LoginRequest
     */
    'signature'?: string;
}
/**
 *
 * @export
 * @interface NotAuthenticated
 */
interface NotAuthenticated {
    /**
     *
     * @type {string}
     * @memberof NotAuthenticated
     */
    'message'?: string;
}
/**
 *
 * @export
 * @interface PaymentMethod
 */
interface PaymentMethod {
    /**
     *
     * @type {string}
     * @memberof PaymentMethod
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethod
     */
    'object'?: string;
    /**
     *
     * @type {PaymentMethodBillingDetails}
     * @memberof PaymentMethod
     */
    'billing_details'?: PaymentMethodBillingDetails;
    /**
     *
     * @type {PaymentMethodCard}
     * @memberof PaymentMethod
     */
    'card'?: PaymentMethodCard;
    /**
     *
     * @type {number}
     * @memberof PaymentMethod
     */
    'created'?: number;
    /**
     *
     * @type {string}
     * @memberof PaymentMethod
     */
    'customer'?: string;
    /**
     *
     * @type {boolean}
     * @memberof PaymentMethod
     */
    'livemode'?: boolean;
    /**
     *
     * @type {{ [key: string]: any; }}
     * @memberof PaymentMethod
     */
    'metadata'?: {
        [key: string]: any;
    };
    /**
     *
     * @type {string}
     * @memberof PaymentMethod
     */
    'type'?: string;
}
/**
 *
 * @export
 * @interface PaymentMethodBillingDetails
 */
interface PaymentMethodBillingDetails {
    /**
     *
     * @type {PaymentMethodBillingDetailsAddress}
     * @memberof PaymentMethodBillingDetails
     */
    'address'?: PaymentMethodBillingDetailsAddress;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodBillingDetails
     */
    'email'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodBillingDetails
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodBillingDetails
     */
    'phone'?: string;
}
/**
 *
 * @export
 * @interface PaymentMethodBillingDetailsAddress
 */
interface PaymentMethodBillingDetailsAddress {
    /**
     *
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'city'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'country'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'line1'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'line2'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'postal_code'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodBillingDetailsAddress
     */
    'state'?: string;
}
/**
 *
 * @export
 * @interface PaymentMethodCard
 */
interface PaymentMethodCard {
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'brand'?: string;
    /**
     *
     * @type {PaymentMethodCardChecks}
     * @memberof PaymentMethodCard
     */
    'checks'?: PaymentMethodCardChecks;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'country'?: string;
    /**
     *
     * @type {number}
     * @memberof PaymentMethodCard
     */
    'exp_month'?: number;
    /**
     *
     * @type {number}
     * @memberof PaymentMethodCard
     */
    'exp_year'?: number;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'fingerprint'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'funding'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'generated_from'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'last4'?: string;
    /**
     *
     * @type {PaymentMethodCardNetworks}
     * @memberof PaymentMethodCard
     */
    'networks'?: PaymentMethodCardNetworks;
    /**
     *
     * @type {PaymentMethodCardThreeDSecureUsage}
     * @memberof PaymentMethodCard
     */
    'three_d_secure_usage'?: PaymentMethodCardThreeDSecureUsage;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCard
     */
    'wallet'?: string;
}
/**
 *
 * @export
 * @interface PaymentMethodCardChecks
 */
interface PaymentMethodCardChecks {
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardChecks
     */
    'address_line1_check'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardChecks
     */
    'address_postal_code_check'?: string;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardChecks
     */
    'cvc_check'?: string;
}
/**
 *
 * @export
 * @interface PaymentMethodCardNetworks
 */
interface PaymentMethodCardNetworks {
    /**
     *
     * @type {Array<string>}
     * @memberof PaymentMethodCardNetworks
     */
    'available'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof PaymentMethodCardNetworks
     */
    'preferred'?: string;
}
/**
 *
 * @export
 * @interface PaymentMethodCardThreeDSecureUsage
 */
interface PaymentMethodCardThreeDSecureUsage {
    /**
     *
     * @type {boolean}
     * @memberof PaymentMethodCardThreeDSecureUsage
     */
    'supported'?: boolean;
}
/**
 *
 * @export
 * @interface Price200Response
 */
interface Price200Response {
    /**
     *
     * @type {Price200ResponseResult}
     * @memberof Price200Response
     */
    'result'?: Price200ResponseResult;
}
/**
 *
 * @export
 * @interface Price200ResponseResult
 */
interface Price200ResponseResult {
    /**
     *
     * @type {number}
     * @memberof Price200ResponseResult
     */
    'decimals'?: number | null;
    /**
     *
     * @type {number}
     * @memberof Price200ResponseResult
     */
    'price'?: number;
    /**
     *
     * @type {number}
     * @memberof Price200ResponseResult
     */
    'timestamp'?: number;
    /**
     *
     * @type {string}
     * @memberof Price200ResponseResult
     */
    'symbol'?: string;
    /**
     *
     * @type {number}
     * @memberof Price200ResponseResult
     */
    'confidence'?: number;
    /**
     *
     * @type {number}
     * @memberof Price200ResponseResult
     */
    'priceInAmount'?: number | null;
}
/**
 *
 * @export
 * @interface Purchase200Response
 */
interface Purchase200Response {
    /**
     *
     * @type {string}
     * @memberof Purchase200Response
     */
    'clientSecret'?: string;
    /**
     *
     * @type {string}
     * @memberof Purchase200Response
     */
    'stripeAccount'?: string;
    /**
     *
     * @type {number}
     * @memberof Purchase200Response
     */
    'totalPriceInDents'?: number;
    /**
     *
     * @type {Purchase200ResponsePricing}
     * @memberof Purchase200Response
     */
    'pricing'?: Purchase200ResponsePricing | null;
}
/**
 *
 * @export
 * @interface Purchase200ResponsePricing
 */
interface Purchase200ResponsePricing {
    /**
     *
     * @type {number}
     * @memberof Purchase200ResponsePricing
     */
    'keyPrice'?: number | null;
    /**
     *
     * @type {number}
     * @memberof Purchase200ResponsePricing
     */
    'unlockServiceFee'?: number | null;
    /**
     *
     * @type {number}
     * @memberof Purchase200ResponsePricing
     */
    'creditCardProcessing'?: number | null;
}
/**
 *
 * @export
 * @interface PurchaseRequest
 */
interface PurchaseRequest {
    /**
     *
     * @type {Array<string>}
     * @memberof PurchaseRequest
     */
    'recipients': Array<string>;
    /**
     *
     * @type {string}
     * @memberof PurchaseRequest
     */
    'stripeTokenId': string;
    /**
     *
     * @type {number}
     * @memberof PurchaseRequest
     */
    'pricing': number;
    /**
     *
     * @type {number}
     * @memberof PurchaseRequest
     */
    'recurring'?: number | null;
    /**
     *
     * @type {Array<string>}
     * @memberof PurchaseRequest
     */
    'data'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof PurchaseRequest
     */
    'referrers'?: Array<string>;
}
/**
 *
 * @export
 * @interface RemovePaymentMethods200Response
 */
interface RemovePaymentMethods200Response {
    /**
     *
     * @type {boolean}
     * @memberof RemovePaymentMethods200Response
     */
    'success'?: boolean;
}
/**
 *
 * @export
 * @interface SaveEventDataRequest
 */
interface SaveEventDataRequest {
    /**
     *
     * @type {number}
     * @memberof SaveEventDataRequest
     */
    'id'?: number;
    /**
     *
     * @type {string}
     * @memberof SaveEventDataRequest
     */
    'name'?: string;
    /**
     *
     * @type {object}
     * @memberof SaveEventDataRequest
     */
    'data'?: object;
    /**
     *
     * @type {Array<string>}
     * @memberof SaveEventDataRequest
     */
    'locks'?: Array<string>;
}
/**
 *
 * @export
 * @interface SaveLockSetting200Response
 */
interface SaveLockSetting200Response {
    /**
     *
     * @type {boolean}
     * @memberof SaveLockSetting200Response
     */
    'sendEmail'?: boolean;
}
/**
 *
 * @export
 * @interface SaveReceipt200Response
 */
interface SaveReceipt200Response {
    /**
     *
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'fullname'?: string;
    /**
     *
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'businessName'?: string;
    /**
     *
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'addressLine1'?: string;
    /**
     *
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'addressLine2'?: string;
    /**
     *
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'city'?: string;
    /**
     *
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'state'?: string;
    /**
     *
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'zip'?: string;
    /**
     *
     * @type {string}
     * @memberof SaveReceipt200Response
     */
    'country'?: string;
}
/**
 *
 * @export
 * @interface SendCustomEmail200Response
 */
interface SendCustomEmail200Response {
    /**
     *
     * @type {boolean}
     * @memberof SendCustomEmail200Response
     */
    'sent'?: boolean;
}
/**
 *
 * @export
 * @interface SendCustomEmailRequest
 */
interface SendCustomEmailRequest {
    /**
     *
     * @type {string}
     * @memberof SendCustomEmailRequest
     */
    'subject'?: string;
    /**
     *
     * @type {string}
     * @memberof SendCustomEmailRequest
     */
    'content'?: string;
}
/**
 *
 * @export
 * @interface SetupPayment200Response
 */
interface SetupPayment200Response {
    /**
     *
     * @type {string}
     * @memberof SetupPayment200Response
     */
    'clientSecret'?: string;
}
/**
 *
 * @export
 * @interface SignTicket200Response
 */
interface SignTicket200Response {
    /**
     *
     * @type {string}
     * @memberof SignTicket200Response
     */
    'payload'?: string;
    /**
     *
     * @type {string}
     * @memberof SignTicket200Response
     */
    'signature'?: string;
}
/**
 *
 * @export
 * @interface TicketVerificationUrl200Response
 */
interface TicketVerificationUrl200Response {
    /**
     *
     * @type {string}
     * @memberof TicketVerificationUrl200Response
     */
    'verificationUrl'?: string;
}
/**
 *
 * @export
 * @interface TransferDoneRequest
 */
interface TransferDoneRequest {
    /**
     * The signature of the transfer code sent to the recipient.
     * @type {string}
     * @memberof TransferDoneRequest
     */
    'transferSignature': string;
    /**
     *
     * @type {string}
     * @memberof TransferDoneRequest
     */
    'owner': string;
    /**
     *
     * @type {string}
     * @memberof TransferDoneRequest
     */
    'lock': string;
    /**
     *
     * @type {string}
     * @memberof TransferDoneRequest
     */
    'token': string;
    /**
     *
     * @type {number}
     * @memberof TransferDoneRequest
     */
    'network': number;
    /**
     *
     * @type {number}
     * @memberof TransferDoneRequest
     */
    'deadline': number;
}
/**
 *
 * @export
 * @interface UpdateCheckoutConfigRequest
 */
interface UpdateCheckoutConfigRequest {
    /**
     *
     * @type {string}
     * @memberof UpdateCheckoutConfigRequest
     */
    'name': string;
    /**
     *
     * @type {{ [key: string]: any; }}
     * @memberof UpdateCheckoutConfigRequest
     */
    'config': {
        [key: string]: any;
    };
}
/**
 * JSON metadata inside metadata field will be saved.
 * @export
 * @interface UpdateLockMetadataRequest
 */
interface UpdateLockMetadataRequest {
    /**
     *
     * @type {{ [key: string]: any; }}
     * @memberof UpdateLockMetadataRequest
     */
    'metadata'?: {
        [key: string]: any;
    };
}
/**
 *
 * @export
 * @interface UpdateUserMetadataRequest
 */
interface UpdateUserMetadataRequest {
    /**
     *
     * @type {UserMetadataInput}
     * @memberof UpdateUserMetadataRequest
     */
    'metadata'?: UserMetadataInput;
}
/**
 *
 * @export
 * @interface UpdateUsersMetadata201Response
 */
interface UpdateUsersMetadata201Response {
    /**
     *
     * @type {Array<UserMetadata>}
     * @memberof UpdateUsersMetadata201Response
     */
    'result'?: Array<UserMetadata>;
    /**
     * Array containing user addresses for which metadata was not created.
     * @type {Array<string>}
     * @memberof UpdateUsersMetadata201Response
     */
    'error'?: Array<string>;
}
/**
 *
 * @export
 * @interface UpdateUsersMetadataRequest
 */
interface UpdateUsersMetadataRequest {
    /**
     *
     * @type {Array<UserMetadata>}
     * @memberof UpdateUsersMetadataRequest
     */
    'users'?: Array<UserMetadata>;
}
/**
 *
 * @export
 * @interface UploadImages201Response
 */
interface UploadImages201Response {
    /**
     *
     * @type {Array<UploadImages201ResponseResultsInner>}
     * @memberof UploadImages201Response
     */
    'results'?: Array<UploadImages201ResponseResultsInner>;
}
/**
 *
 * @export
 * @interface UploadImages201ResponseResultsInner
 */
interface UploadImages201ResponseResultsInner {
    /**
     *
     * @type {string}
     * @memberof UploadImages201ResponseResultsInner
     */
    'url'?: string;
    /**
     *
     * @type {string}
     * @memberof UploadImages201ResponseResultsInner
     */
    'publicUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof UploadImages201ResponseResultsInner
     */
    'originamName'?: string;
    /**
     *
     * @type {string}
     * @memberof UploadImages201ResponseResultsInner
     */
    'mimetype'?: string;
    /**
     *
     * @type {string}
     * @memberof UploadImages201ResponseResultsInner
     */
    'contentType'?: string;
    /**
     *
     * @type {number}
     * @memberof UploadImages201ResponseResultsInner
     */
    'size'?: number;
    /**
     *
     * @type {string}
     * @memberof UploadImages201ResponseResultsInner
     */
    'key'?: string;
    /**
     *
     * @type {UploadImages201ResponseResultsInnerMetadata}
     * @memberof UploadImages201ResponseResultsInner
     */
    'metadata'?: UploadImages201ResponseResultsInnerMetadata;
    /**
     *
     * @type {string}
     * @memberof UploadImages201ResponseResultsInner
     */
    'encoding'?: string;
}
/**
 *
 * @export
 * @interface UploadImages201ResponseResultsInnerMetadata
 */
interface UploadImages201ResponseResultsInnerMetadata {
    /**
     *
     * @type {string}
     * @memberof UploadImages201ResponseResultsInnerMetadata
     */
    'fieldName'?: string;
    /**
     *
     * @type {string}
     * @memberof UploadImages201ResponseResultsInnerMetadata
     */
    'createdBy'?: string;
}
/**
 *
 * @export
 * @interface UserMetadata
 */
interface UserMetadata {
    /**
     *
     * @type {number}
     * @memberof UserMetadata
     */
    'network': number;
    /**
     *
     * @type {string}
     * @memberof UserMetadata
     */
    'lockAddress': string;
    /**
     *
     * @type {string}
     * @memberof UserMetadata
     */
    'userAddress': string;
    /**
     *
     * @type {UserMetadataInput}
     * @memberof UserMetadata
     */
    'metadata': UserMetadataInput;
}
/**
 *
 * @export
 * @interface UserMetadataInput
 */
interface UserMetadataInput {
    /**
     *
     * @type {{ [key: string]: any; }}
     * @memberof UserMetadataInput
     */
    'public'?: {
        [key: string]: any;
    } | null;
    /**
     *
     * @type {{ [key: string]: any; }}
     * @memberof UserMetadataInput
     */
    'protected'?: {
        [key: string]: any;
    } | null;
}
/**
 *
 * @export
 * @interface Verifier
 */
interface Verifier {
    /**
     *
     * @type {string}
     * @memberof Verifier
     */
    'address'?: string;
    /**
     *
     * @type {string}
     * @memberof Verifier
     */
    'lockAddress'?: string;
    /**
     *
     * @type {string}
     * @memberof Verifier
     */
    'lockManager'?: string;
    /**
     *
     * @type {number}
     * @memberof Verifier
     */
    'network'?: number;
}
/**
 *
 * @export
 * @interface Verifier200Response
 */
interface Verifier200Response {
    /**
     *
     * @type {boolean}
     * @memberof Verifier200Response
     */
    'enabled'?: boolean;
}
/**
 *
 * @export
 * @interface Verifiers200Response
 */
interface Verifiers200Response {
    /**
     *
     * @type {Array<Verifier>}
     * @memberof Verifiers200Response
     */
    'results'?: Array<Verifier>;
}
/**
 * DefaultApi - axios parameter creator
 * @export
 */
declare const DefaultApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * List applications created the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    applications: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    balance: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Cancel a fiat subscription.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelSubscription: (network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Setup an onramp session for the user.
     * @param {string} session The id of the onramp session
     * @param {string} transactionHash The transacttion hash for the deposit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    captureOnRampSession: (session: string, transactionHash: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Capture a purchase
     * @param {CapturePurchaseRequest} [capturePurchaseRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    capturePurchase: (capturePurchaseRequest?: CapturePurchaseRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Check if claim is possible for a given purchase
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CheckClaimRequest} [checkClaimRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkClaim: (network: number, lockAddress: string, checkClaimRequest?: CheckClaimRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Mark a ticket as checked in.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkTicket: (network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Claim a membership key for a lock. If not authenticated, requires an email in the body.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} captcha Recaptcha value to pass.
     * @param {ClaimRequest} claimRequest
     * @param {string} [recipient] Recipient address for key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    claim: (network: number, lockAddress: string, captcha: string, claimRequest: ClaimRequest, recipient?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Connect a stripe account to a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {ConnectStripeAccountRequest} [connectStripeAccountRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectStripeAccount: (network: number, lockAddress: string, connectStripeAccountRequest?: ConnectStripeAccountRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create application associated with user wallet.
     * @param {ApplicationBody} applicationBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApplication: (applicationBody: ApplicationBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @param {number} network Network id.
     * @param {string} captcha Recaptcha value to pass.
     * @param {LockContractOptions} lockContractOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLockContract: (network: number, captcha: string, lockContractOptions: LockContractOptions, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Setup an onramp session for the user.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CreateOnRampSessionRequest} createOnRampSessionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOnRampSession: (network: number, lockAddress: string, createOnRampSessionRequest: CreateOnRampSessionRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a transfer code to transfer an airdropped key to an email address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransferCode: (network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVerifier: (network: number, lockAddress: string, verifierAddress: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete application by id.
     * @param {string} id Application id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApplication: (id: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete a checkout config
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCheckoutConfig: (id: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Remove verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVerifier: (network: number, lockAddress: string, verifierAddress: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Disconnect stripe account.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disconnectStripe: (network: number, lockAddress: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Send QR code by email.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailTicket: (network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Generate certificate for specific key
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCertificate: (network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Generate a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateTicket: (network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the price breakdown for recipients & total charges with fees for a specific lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChargesForLock: (network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCheckoutConfig: (id: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get custom email content for a specific template and lock details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomEmailContent: (network: number, lockAddress: string, template: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the data for recipients and guild. This is to be used in conjunction with the Guild
     * @param {number} network The network the lock is on
     * @param {string} [lockAddress] The address of the lock
     * @param {Array<string>} [recipients] The list of recipients for the purchase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForRecipientsAndGuild: (network: number, lockAddress?: string, recipients?: Array<string>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the event details from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventDetails: (network: number, lockAddress: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get saved lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockSettings: (network: number, lockAddress: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get lock setting by slug
     * @param {string} slug Slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockSettingsBySlug: (slug: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns Stripe connection details
     * @param {string} lockAddress Lock address.
     * @param {number} chain Lock network
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockStripeConnectionDetails: (lockAddress: string, chain: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get receipt details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReceipt: (network: number, lockAddress: string, hash: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get all receipts for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReceipts: (network: number, lockAddress: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get supplier details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReceiptsBase: (network: number, lockAddress: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Lists the locks connected to Stripe for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStripeConnections: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get an active subscription associated with the key. It can be fiat or crypto.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscription: (network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * get a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicket: (network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the total price for a purchase (including fees)
     * @param {number} network The network the lock is on
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTotalPrice: (network: number, amount?: number, address?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the price breakdown for universal credit card
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniversalCardPrice: (network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns if credit card payment are enable for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isCardPaymentEnabledForLock: (network: number, lockAddress: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get key and user metadata.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keyMetadata: (network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List of lock keys by network with additional metadata if the caller is the lockManager
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} query Query you want to search for.
     * @param {string} filterKey The key you want to search on.
     * @param {string} [expiration] Expiration time
     * @param {number} [page] Page number when paginating
     * @param {number} [max] Maximum number of items to get by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keys: (network: number, lockAddress: string, query: string, filterKey: string, expiration?: string, page?: number, max?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * A list of all checkout configs created by the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCheckoutConfigs: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List payment methods for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentMethods: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lockMetadata: (network: number, lockAddress: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Login as a user using Sign in with Ethereum message signed by the wallet address.
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: (loginRequest: LoginRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Logout from locksmith. This will invalidate all your session tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Provide a unique nonce for using in sign in with ethereum
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nonce: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @param {number} network Network id.
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    price: (network: number, amount?: number, address?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create purchase intent for stripe.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {PurchaseRequest} purchaseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchase: (network: number, lockAddress: string, purchaseRequest: PurchaseRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * resubscribe emails from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reSubscribeEmail: (network: number, lockAddress: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Remove all payment methods for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePaymentMethods: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Invalidate a session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revoke: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Save custom email content for a specif lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveCustomEmailContent: (network: number, lockAddress: string, template: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Save event data
     * @param {SaveEventDataRequest} [saveEventDataRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveEventData: (saveEventDataRequest?: SaveEventDataRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Save lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {LockSettings} [lockSettings]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveLockSetting: (network: number, lockAddress: string, lockSettings?: LockSettings, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create purchaser details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveReceipt: (network: number, lockAddress: string, hash: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create supplier details.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveReceiptsBase: (network: number, lockAddress: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Send custom email to recipients
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {SendCustomEmailRequest} [sendCustomEmailRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendCustomEmail: (network: number, lockAddress: string, sendCustomEmailRequest?: SendCustomEmailRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Setup a payment method for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setupPayment: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Generate signature to prove validity of token.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signTicket: (network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get QR code for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketQRCode: (network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the verification URL for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketVerificationUrl: (network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Finalize the transfer of a key to a recipient. This is to copy over any locksmith related data to the recipient\'s account.
     * @param {TransferDoneRequest} [transferDoneRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferDone: (transferDoneRequest?: TransferDoneRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Unsubscribe email from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsubscribeEmail: (network: number, lockAddress: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update application by id.
     * @param {string} id Application id.
     * @param {ApplicationBody} [applicationBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApplication: (id: string, applicationBody?: ApplicationBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * A new checkout config is created or updated if it already exists
     * @param {string} id This is optional. If you don\&#39;t pass an ID, a new config will be created. If you pass an ID, the config will be created.
     * @param {UpdateCheckoutConfigRequest} [updateCheckoutConfigRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCheckoutConfig: (id: string, updateCheckoutConfigRequest?: UpdateCheckoutConfigRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update or create metadata for key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateKeyMetadata: (network: number, lockAddress: string, keyId: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update or create metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLockMetadata: (network: number, lockAddress: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update or create user metadata for lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} userAddress User address.
     * @param {UpdateUserMetadataRequest} updateUserMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserMetadata: (network: number, lockAddress: string, userAddress: string, updateUserMetadataRequest: UpdateUserMetadataRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update or create user metadata for lock.
     * @param {UpdateUsersMetadataRequest} updateUsersMetadataRequest users array containing user metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUsersMetadata: (updateUsersMetadataRequest: UpdateUsersMetadataRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Upload images to locksmith
     * @param {Array<any>} [images]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadImages: (images?: Array<any>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get user details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    user: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Check if an address is a verifier of the lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifier: (network: number, lockAddress: string, verifierAddress: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List of verifiers for the lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiers: (network: number, lockAddress: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * DefaultApi - functional programming interface
 * @export
 */
declare const DefaultApiFp: (configuration?: Configuration) => {
    /**
     * List applications created the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    applications(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Applications200Response>>;
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    balance(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{
        [key: string]: Balance200ResponseValue;
    }>>;
    /**
     * Cancel a fiat subscription.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelSubscription(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Setup an onramp session for the user.
     * @param {string} session The id of the onramp session
     * @param {string} transactionHash The transacttion hash for the deposit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    captureOnRampSession(session: string, transactionHash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaptureOnRampSession200Response>>;
    /**
     * Capture a purchase
     * @param {CapturePurchaseRequest} [capturePurchaseRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    capturePurchase(capturePurchaseRequest?: CapturePurchaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateLockContract201Response>>;
    /**
     * Check if claim is possible for a given purchase
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CheckClaimRequest} [checkClaimRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkClaim(network: number, lockAddress: string, checkClaimRequest?: CheckClaimRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckClaim200Response>>;
    /**
     * Mark a ticket as checked in.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccess>>;
    /**
     * Claim a membership key for a lock. If not authenticated, requires an email in the body.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} captcha Recaptcha value to pass.
     * @param {ClaimRequest} claimRequest
     * @param {string} [recipient] Recipient address for key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    claim(network: number, lockAddress: string, captcha: string, claimRequest: ClaimRequest, recipient?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Claim200Response>>;
    /**
     * Connect a stripe account to a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {ConnectStripeAccountRequest} [connectStripeAccountRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectStripeAccount(network: number, lockAddress: string, connectStripeAccountRequest?: ConnectStripeAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectStripeAccount200Response>>;
    /**
     * Create application associated with user wallet.
     * @param {ApplicationBody} applicationBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApplication(applicationBody: ApplicationBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>>;
    /**
     *
     * @param {number} network Network id.
     * @param {string} captcha Recaptcha value to pass.
     * @param {LockContractOptions} lockContractOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLockContract(network: number, captcha: string, lockContractOptions: LockContractOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateLockContract201Response>>;
    /**
     * Setup an onramp session for the user.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CreateOnRampSessionRequest} createOnRampSessionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOnRampSession(network: number, lockAddress: string, createOnRampSessionRequest: CreateOnRampSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetupPayment200Response>>;
    /**
     * Create a transfer code to transfer an airdropped key to an email address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransferCode(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransferCode200Response>>;
    /**
     * Create verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVerifier(network: number, lockAddress: string, verifierAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Verifier>>;
    /**
     * Delete application by id.
     * @param {string} id Application id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApplication(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccess>>;
    /**
     * Delete a checkout config
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCheckoutConfig(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCheckoutConfig200Response>>;
    /**
     * Remove verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVerifier(network: number, lockAddress: string, verifierAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Verifiers200Response>>;
    /**
     * Disconnect stripe account.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disconnectStripe(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Send QR code by email.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailTicket200Response>>;
    /**
     * Generate certificate for specific key
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCertificate(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Generate a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Get the price breakdown for recipients & total charges with fees for a specific lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChargesForLock(network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChargesForLock200Response>>;
    /**
     *
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCheckoutConfig(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutConfig>>;
    /**
     * Get custom email content for a specific template and lock details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomEmailContent(network: number, lockAddress: string, template: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomEmailContent200Response>>;
    /**
     * Get the data for recipients and guild. This is to be used in conjunction with the Guild
     * @param {number} network The network the lock is on
     * @param {string} [lockAddress] The address of the lock
     * @param {Array<string>} [recipients] The list of recipients for the purchase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForRecipientsAndGuild(network: number, lockAddress?: string, recipients?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDataForRecipientsAndGuild200Response>>;
    /**
     * Get the event details from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventDetails(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventDetails>>;
    /**
     * Get saved lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockSettings(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LockSettings>>;
    /**
     * Get lock setting by slug
     * @param {string} slug Slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockSettingsBySlug(slug: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LockSettings>>;
    /**
     * Returns Stripe connection details
     * @param {string} lockAddress Lock address.
     * @param {number} chain Lock network
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockStripeConnectionDetails(lockAddress: string, chain: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLockStripeConnectionDetails200Response>>;
    /**
     * Get receipt details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReceipt(network: number, lockAddress: string, hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReceipt200Response>>;
    /**
     * Get all receipts for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReceipts(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReceipts200Response>>;
    /**
     * Get supplier details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReceiptsBase(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReceiptsBase200Response>>;
    /**
     * Lists the locks connected to Stripe for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStripeConnections(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStripeConnections200Response>>;
    /**
     * Get an active subscription associated with the key. It can be fiat or crypto.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscription(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSubscription200Response>>;
    /**
     * get a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTicket200Response>>;
    /**
     * Get the total price for a purchase (including fees)
     * @param {number} network The network the lock is on
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTotalPrice(network: number, amount?: number, address?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTotalPrice200Response>>;
    /**
     * Get the price breakdown for universal credit card
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniversalCardPrice(network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChargesForLock200Response>>;
    /**
     * Returns if credit card payment are enable for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isCardPaymentEnabledForLock(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsCardPaymentEnabledForLock200Response>>;
    /**
     * Get key and user metadata.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keyMetadata(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyMetadata200Response>>;
    /**
     * List of lock keys by network with additional metadata if the caller is the lockManager
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} query Query you want to search for.
     * @param {string} filterKey The key you want to search on.
     * @param {string} [expiration] Expiration time
     * @param {number} [page] Page number when paginating
     * @param {number} [max] Maximum number of items to get by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keys(network: number, lockAddress: string, query: string, filterKey: string, expiration?: string, page?: number, max?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KeyMetadata>>>;
    /**
     * A list of all checkout configs created by the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCheckoutConfigs(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCheckoutConfigs200Response>>;
    /**
     * List payment methods for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentMethods(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaymentMethods200Response>>;
    /**
     * Get metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lockMetadata(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{
        [key: string]: any;
    }>>;
    /**
     * Login as a user using Sign in with Ethereum message signed by the wallet address.
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(loginRequest: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResult>>;
    /**
     * Logout from locksmith. This will invalidate all your session tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccess>>;
    /**
     * Provide a unique nonce for using in sign in with ethereum
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nonce(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     *
     * @param {number} network Network id.
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    price(network: number, amount?: number, address?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Price200Response>>;
    /**
     * Create purchase intent for stripe.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {PurchaseRequest} purchaseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchase(network: number, lockAddress: string, purchaseRequest: PurchaseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Purchase200Response>>;
    /**
     * resubscribe emails from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reSubscribeEmail(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemovePaymentMethods200Response>>;
    /**
     * Remove all payment methods for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePaymentMethods(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemovePaymentMethods200Response>>;
    /**
     * Invalidate a session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revoke(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericSuccess>>;
    /**
     * Save custom email content for a specif lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveCustomEmailContent(network: number, lockAddress: string, template: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomEmailContent200Response>>;
    /**
     * Save event data
     * @param {SaveEventDataRequest} [saveEventDataRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveEventData(saveEventDataRequest?: SaveEventDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveEventDataRequest>>;
    /**
     * Save lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {LockSettings} [lockSettings]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveLockSetting(network: number, lockAddress: string, lockSettings?: LockSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveLockSetting200Response>>;
    /**
     * Create purchaser details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveReceipt(network: number, lockAddress: string, hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveReceipt200Response>>;
    /**
     * Create supplier details.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveReceiptsBase(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReceiptsBase200Response>>;
    /**
     * Send custom email to recipients
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {SendCustomEmailRequest} [sendCustomEmailRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendCustomEmail(network: number, lockAddress: string, sendCustomEmailRequest?: SendCustomEmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendCustomEmail200Response>>;
    /**
     * Setup a payment method for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setupPayment(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetupPayment200Response>>;
    /**
     * Generate signature to prove validity of token.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignTicket200Response>>;
    /**
     * Get QR code for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketQRCode(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>>;
    /**
     * Get the verification URL for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketVerificationUrl(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketVerificationUrl200Response>>;
    /**
     * Finalize the transfer of a key to a recipient. This is to copy over any locksmith related data to the recipient\'s account.
     * @param {TransferDoneRequest} [transferDoneRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferDone(transferDoneRequest?: TransferDoneRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransferCode404Response>>;
    /**
     * Unsubscribe email from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsubscribeEmail(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemovePaymentMethods200Response>>;
    /**
     * Update application by id.
     * @param {string} id Application id.
     * @param {ApplicationBody} [applicationBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApplication(id: string, applicationBody?: ApplicationBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>>;
    /**
     * A new checkout config is created or updated if it already exists
     * @param {string} id This is optional. If you don\&#39;t pass an ID, a new config will be created. If you pass an ID, the config will be created.
     * @param {UpdateCheckoutConfigRequest} [updateCheckoutConfigRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCheckoutConfig(id: string, updateCheckoutConfigRequest?: UpdateCheckoutConfigRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutConfig>>;
    /**
     * Update or create metadata for key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateKeyMetadata(network: number, lockAddress: string, keyId: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{
        [key: string]: any;
    }>>;
    /**
     * Update or create metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLockMetadata(network: number, lockAddress: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{
        [key: string]: any;
    }>>;
    /**
     * Update or create user metadata for lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} userAddress User address.
     * @param {UpdateUserMetadataRequest} updateUserMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserMetadata(network: number, lockAddress: string, userAddress: string, updateUserMetadataRequest: UpdateUserMetadataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{
        [key: string]: any;
    }>>;
    /**
     * Update or create user metadata for lock.
     * @param {UpdateUsersMetadataRequest} updateUsersMetadataRequest users array containing user metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUsersMetadata(updateUsersMetadataRequest: UpdateUsersMetadataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUsersMetadata201Response>>;
    /**
     * Upload images to locksmith
     * @param {Array<any>} [images]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadImages(images?: Array<any>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadImages201Response>>;
    /**
     * Get user details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    user(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Auth>>;
    /**
     * Check if an address is a verifier of the lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifier(network: number, lockAddress: string, verifierAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Verifier200Response>>;
    /**
     * List of verifiers for the lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiers(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Verifiers200Response>>;
};
/**
 * DefaultApi - factory interface
 * @export
 */
declare const DefaultApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * List applications created the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    applications(options?: any): AxiosPromise<Applications200Response>;
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    balance(options?: any): AxiosPromise<{
        [key: string]: Balance200ResponseValue;
    }>;
    /**
     * Cancel a fiat subscription.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelSubscription(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<void>;
    /**
     * Setup an onramp session for the user.
     * @param {string} session The id of the onramp session
     * @param {string} transactionHash The transacttion hash for the deposit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    captureOnRampSession(session: string, transactionHash: string, options?: any): AxiosPromise<CaptureOnRampSession200Response>;
    /**
     * Capture a purchase
     * @param {CapturePurchaseRequest} [capturePurchaseRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    capturePurchase(capturePurchaseRequest?: CapturePurchaseRequest, options?: any): AxiosPromise<CreateLockContract201Response>;
    /**
     * Check if claim is possible for a given purchase
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CheckClaimRequest} [checkClaimRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkClaim(network: number, lockAddress: string, checkClaimRequest?: CheckClaimRequest, options?: any): AxiosPromise<CheckClaim200Response>;
    /**
     * Mark a ticket as checked in.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkTicket(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<GenericSuccess>;
    /**
     * Claim a membership key for a lock. If not authenticated, requires an email in the body.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} captcha Recaptcha value to pass.
     * @param {ClaimRequest} claimRequest
     * @param {string} [recipient] Recipient address for key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    claim(network: number, lockAddress: string, captcha: string, claimRequest: ClaimRequest, recipient?: string, options?: any): AxiosPromise<Claim200Response>;
    /**
     * Connect a stripe account to a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {ConnectStripeAccountRequest} [connectStripeAccountRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectStripeAccount(network: number, lockAddress: string, connectStripeAccountRequest?: ConnectStripeAccountRequest, options?: any): AxiosPromise<ConnectStripeAccount200Response>;
    /**
     * Create application associated with user wallet.
     * @param {ApplicationBody} applicationBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApplication(applicationBody: ApplicationBody, options?: any): AxiosPromise<Application>;
    /**
     *
     * @param {number} network Network id.
     * @param {string} captcha Recaptcha value to pass.
     * @param {LockContractOptions} lockContractOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLockContract(network: number, captcha: string, lockContractOptions: LockContractOptions, options?: any): AxiosPromise<CreateLockContract201Response>;
    /**
     * Setup an onramp session for the user.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CreateOnRampSessionRequest} createOnRampSessionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOnRampSession(network: number, lockAddress: string, createOnRampSessionRequest: CreateOnRampSessionRequest, options?: any): AxiosPromise<SetupPayment200Response>;
    /**
     * Create a transfer code to transfer an airdropped key to an email address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransferCode(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<CreateTransferCode200Response>;
    /**
     * Create verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVerifier(network: number, lockAddress: string, verifierAddress: string, options?: any): AxiosPromise<Verifier>;
    /**
     * Delete application by id.
     * @param {string} id Application id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApplication(id: string, options?: any): AxiosPromise<GenericSuccess>;
    /**
     * Delete a checkout config
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCheckoutConfig(id: string, options?: any): AxiosPromise<DeleteCheckoutConfig200Response>;
    /**
     * Remove verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVerifier(network: number, lockAddress: string, verifierAddress: string, options?: any): AxiosPromise<Verifiers200Response>;
    /**
     * Disconnect stripe account.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disconnectStripe(network: number, lockAddress: string, options?: any): AxiosPromise<void>;
    /**
     * Send QR code by email.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailTicket(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<EmailTicket200Response>;
    /**
     * Generate certificate for specific key
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCertificate(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<void>;
    /**
     * Generate a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateTicket(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<void>;
    /**
     * Get the price breakdown for recipients & total charges with fees for a specific lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChargesForLock(network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options?: any): AxiosPromise<GetChargesForLock200Response>;
    /**
     *
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCheckoutConfig(id: string, options?: any): AxiosPromise<CheckoutConfig>;
    /**
     * Get custom email content for a specific template and lock details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomEmailContent(network: number, lockAddress: string, template: string, options?: any): AxiosPromise<GetCustomEmailContent200Response>;
    /**
     * Get the data for recipients and guild. This is to be used in conjunction with the Guild
     * @param {number} network The network the lock is on
     * @param {string} [lockAddress] The address of the lock
     * @param {Array<string>} [recipients] The list of recipients for the purchase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForRecipientsAndGuild(network: number, lockAddress?: string, recipients?: Array<string>, options?: any): AxiosPromise<GetDataForRecipientsAndGuild200Response>;
    /**
     * Get the event details from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventDetails(network: number, lockAddress: string, options?: any): AxiosPromise<EventDetails>;
    /**
     * Get saved lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockSettings(network: number, lockAddress: string, options?: any): AxiosPromise<LockSettings>;
    /**
     * Get lock setting by slug
     * @param {string} slug Slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockSettingsBySlug(slug: string, options?: any): AxiosPromise<LockSettings>;
    /**
     * Returns Stripe connection details
     * @param {string} lockAddress Lock address.
     * @param {number} chain Lock network
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockStripeConnectionDetails(lockAddress: string, chain: number, options?: any): AxiosPromise<GetLockStripeConnectionDetails200Response>;
    /**
     * Get receipt details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReceipt(network: number, lockAddress: string, hash: string, options?: any): AxiosPromise<GetReceipt200Response>;
    /**
     * Get all receipts for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReceipts(network: number, lockAddress: string, options?: any): AxiosPromise<GetReceipts200Response>;
    /**
     * Get supplier details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReceiptsBase(network: number, lockAddress: string, options?: any): AxiosPromise<GetReceiptsBase200Response>;
    /**
     * Lists the locks connected to Stripe for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStripeConnections(options?: any): AxiosPromise<GetStripeConnections200Response>;
    /**
     * Get an active subscription associated with the key. It can be fiat or crypto.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscription(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<GetSubscription200Response>;
    /**
     * get a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicket(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<GetTicket200Response>;
    /**
     * Get the total price for a purchase (including fees)
     * @param {number} network The network the lock is on
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTotalPrice(network: number, amount?: number, address?: string, options?: any): AxiosPromise<GetTotalPrice200Response>;
    /**
     * Get the price breakdown for universal credit card
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniversalCardPrice(network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options?: any): AxiosPromise<GetChargesForLock200Response>;
    /**
     * Returns if credit card payment are enable for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isCardPaymentEnabledForLock(network: number, lockAddress: string, options?: any): AxiosPromise<IsCardPaymentEnabledForLock200Response>;
    /**
     * Get key and user metadata.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keyMetadata(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<KeyMetadata200Response>;
    /**
     * List of lock keys by network with additional metadata if the caller is the lockManager
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} query Query you want to search for.
     * @param {string} filterKey The key you want to search on.
     * @param {string} [expiration] Expiration time
     * @param {number} [page] Page number when paginating
     * @param {number} [max] Maximum number of items to get by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keys(network: number, lockAddress: string, query: string, filterKey: string, expiration?: string, page?: number, max?: number, options?: any): AxiosPromise<Array<KeyMetadata>>;
    /**
     * A list of all checkout configs created by the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCheckoutConfigs(options?: any): AxiosPromise<ListCheckoutConfigs200Response>;
    /**
     * List payment methods for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentMethods(options?: any): AxiosPromise<ListPaymentMethods200Response>;
    /**
     * Get metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lockMetadata(network: number, lockAddress: string, options?: any): AxiosPromise<{
        [key: string]: any;
    }>;
    /**
     * Login as a user using Sign in with Ethereum message signed by the wallet address.
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(loginRequest: LoginRequest, options?: any): AxiosPromise<AuthResult>;
    /**
     * Logout from locksmith. This will invalidate all your session tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: any): AxiosPromise<GenericSuccess>;
    /**
     * Provide a unique nonce for using in sign in with ethereum
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nonce(options?: any): AxiosPromise<string>;
    /**
     *
     * @param {number} network Network id.
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    price(network: number, amount?: number, address?: string, options?: any): AxiosPromise<Price200Response>;
    /**
     * Create purchase intent for stripe.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {PurchaseRequest} purchaseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchase(network: number, lockAddress: string, purchaseRequest: PurchaseRequest, options?: any): AxiosPromise<Purchase200Response>;
    /**
     * resubscribe emails from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reSubscribeEmail(network: number, lockAddress: string, options?: any): AxiosPromise<RemovePaymentMethods200Response>;
    /**
     * Remove all payment methods for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePaymentMethods(options?: any): AxiosPromise<RemovePaymentMethods200Response>;
    /**
     * Invalidate a session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revoke(options?: any): AxiosPromise<GenericSuccess>;
    /**
     * Save custom email content for a specif lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveCustomEmailContent(network: number, lockAddress: string, template: string, options?: any): AxiosPromise<GetCustomEmailContent200Response>;
    /**
     * Save event data
     * @param {SaveEventDataRequest} [saveEventDataRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveEventData(saveEventDataRequest?: SaveEventDataRequest, options?: any): AxiosPromise<SaveEventDataRequest>;
    /**
     * Save lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {LockSettings} [lockSettings]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveLockSetting(network: number, lockAddress: string, lockSettings?: LockSettings, options?: any): AxiosPromise<SaveLockSetting200Response>;
    /**
     * Create purchaser details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveReceipt(network: number, lockAddress: string, hash: string, options?: any): AxiosPromise<SaveReceipt200Response>;
    /**
     * Create supplier details.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveReceiptsBase(network: number, lockAddress: string, options?: any): AxiosPromise<GetReceiptsBase200Response>;
    /**
     * Send custom email to recipients
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {SendCustomEmailRequest} [sendCustomEmailRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendCustomEmail(network: number, lockAddress: string, sendCustomEmailRequest?: SendCustomEmailRequest, options?: any): AxiosPromise<SendCustomEmail200Response>;
    /**
     * Setup a payment method for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setupPayment(options?: any): AxiosPromise<SetupPayment200Response>;
    /**
     * Generate signature to prove validity of token.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signTicket(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<SignTicket200Response>;
    /**
     * Get QR code for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketQRCode(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<any>;
    /**
     * Get the verification URL for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketVerificationUrl(network: number, lockAddress: string, keyId: string, options?: any): AxiosPromise<TicketVerificationUrl200Response>;
    /**
     * Finalize the transfer of a key to a recipient. This is to copy over any locksmith related data to the recipient\'s account.
     * @param {TransferDoneRequest} [transferDoneRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferDone(transferDoneRequest?: TransferDoneRequest, options?: any): AxiosPromise<CreateTransferCode404Response>;
    /**
     * Unsubscribe email from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsubscribeEmail(network: number, lockAddress: string, options?: any): AxiosPromise<RemovePaymentMethods200Response>;
    /**
     * Update application by id.
     * @param {string} id Application id.
     * @param {ApplicationBody} [applicationBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApplication(id: string, applicationBody?: ApplicationBody, options?: any): AxiosPromise<Application>;
    /**
     * A new checkout config is created or updated if it already exists
     * @param {string} id This is optional. If you don\&#39;t pass an ID, a new config will be created. If you pass an ID, the config will be created.
     * @param {UpdateCheckoutConfigRequest} [updateCheckoutConfigRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCheckoutConfig(id: string, updateCheckoutConfigRequest?: UpdateCheckoutConfigRequest, options?: any): AxiosPromise<CheckoutConfig>;
    /**
     * Update or create metadata for key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateKeyMetadata(network: number, lockAddress: string, keyId: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options?: any): AxiosPromise<{
        [key: string]: any;
    }>;
    /**
     * Update or create metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLockMetadata(network: number, lockAddress: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options?: any): AxiosPromise<{
        [key: string]: any;
    }>;
    /**
     * Update or create user metadata for lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} userAddress User address.
     * @param {UpdateUserMetadataRequest} updateUserMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserMetadata(network: number, lockAddress: string, userAddress: string, updateUserMetadataRequest: UpdateUserMetadataRequest, options?: any): AxiosPromise<{
        [key: string]: any;
    }>;
    /**
     * Update or create user metadata for lock.
     * @param {UpdateUsersMetadataRequest} updateUsersMetadataRequest users array containing user metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUsersMetadata(updateUsersMetadataRequest: UpdateUsersMetadataRequest, options?: any): AxiosPromise<UpdateUsersMetadata201Response>;
    /**
     * Upload images to locksmith
     * @param {Array<any>} [images]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadImages(images?: Array<any>, options?: any): AxiosPromise<UploadImages201Response>;
    /**
     * Get user details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    user(options?: any): AxiosPromise<Auth>;
    /**
     * Check if an address is a verifier of the lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifier(network: number, lockAddress: string, verifierAddress: string, options?: any): AxiosPromise<Verifier200Response>;
    /**
     * List of verifiers for the lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiers(network: number, lockAddress: string, options?: any): AxiosPromise<Verifiers200Response>;
};
/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
declare class DefaultApi extends BaseAPI {
    /**
     * List applications created the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    applications(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Applications200Response, any>>;
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    balance(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<{
        [key: string]: Balance200ResponseValue;
    }, any>>;
    /**
     * Cancel a fiat subscription.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    cancelSubscription(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Setup an onramp session for the user.
     * @param {string} session The id of the onramp session
     * @param {string} transactionHash The transacttion hash for the deposit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    captureOnRampSession(session: string, transactionHash: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CaptureOnRampSession200Response, any>>;
    /**
     * Capture a purchase
     * @param {CapturePurchaseRequest} [capturePurchaseRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    capturePurchase(capturePurchaseRequest?: CapturePurchaseRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CreateLockContract201Response, any>>;
    /**
     * Check if claim is possible for a given purchase
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CheckClaimRequest} [checkClaimRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    checkClaim(network: number, lockAddress: string, checkClaimRequest?: CheckClaimRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CheckClaim200Response, any>>;
    /**
     * Mark a ticket as checked in.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    checkTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GenericSuccess, any>>;
    /**
     * Claim a membership key for a lock. If not authenticated, requires an email in the body.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} captcha Recaptcha value to pass.
     * @param {ClaimRequest} claimRequest
     * @param {string} [recipient] Recipient address for key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    claim(network: number, lockAddress: string, captcha: string, claimRequest: ClaimRequest, recipient?: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Claim200Response, any>>;
    /**
     * Connect a stripe account to a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {ConnectStripeAccountRequest} [connectStripeAccountRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    connectStripeAccount(network: number, lockAddress: string, connectStripeAccountRequest?: ConnectStripeAccountRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ConnectStripeAccount200Response, any>>;
    /**
     * Create application associated with user wallet.
     * @param {ApplicationBody} applicationBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createApplication(applicationBody: ApplicationBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Application, any>>;
    /**
     *
     * @param {number} network Network id.
     * @param {string} captcha Recaptcha value to pass.
     * @param {LockContractOptions} lockContractOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createLockContract(network: number, captcha: string, lockContractOptions: LockContractOptions, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CreateLockContract201Response, any>>;
    /**
     * Setup an onramp session for the user.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CreateOnRampSessionRequest} createOnRampSessionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createOnRampSession(network: number, lockAddress: string, createOnRampSessionRequest: CreateOnRampSessionRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<SetupPayment200Response, any>>;
    /**
     * Create a transfer code to transfer an airdropped key to an email address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createTransferCode(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CreateTransferCode200Response, any>>;
    /**
     * Create verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createVerifier(network: number, lockAddress: string, verifierAddress: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Verifier, any>>;
    /**
     * Delete application by id.
     * @param {string} id Application id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    deleteApplication(id: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GenericSuccess, any>>;
    /**
     * Delete a checkout config
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    deleteCheckoutConfig(id: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<DeleteCheckoutConfig200Response, any>>;
    /**
     * Remove verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    deleteVerifier(network: number, lockAddress: string, verifierAddress: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Verifiers200Response, any>>;
    /**
     * Disconnect stripe account.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    disconnectStripe(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Send QR code by email.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    emailTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<EmailTicket200Response, any>>;
    /**
     * Generate certificate for specific key
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    generateCertificate(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Generate a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    generateTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Get the price breakdown for recipients & total charges with fees for a specific lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getChargesForLock(network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetChargesForLock200Response, any>>;
    /**
     *
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getCheckoutConfig(id: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CheckoutConfig, any>>;
    /**
     * Get custom email content for a specific template and lock details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getCustomEmailContent(network: number, lockAddress: string, template: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetCustomEmailContent200Response, any>>;
    /**
     * Get the data for recipients and guild. This is to be used in conjunction with the Guild
     * @param {number} network The network the lock is on
     * @param {string} [lockAddress] The address of the lock
     * @param {Array<string>} [recipients] The list of recipients for the purchase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getDataForRecipientsAndGuild(network: number, lockAddress?: string, recipients?: Array<string>, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetDataForRecipientsAndGuild200Response, any>>;
    /**
     * Get the event details from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getEventDetails(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<EventDetails, any>>;
    /**
     * Get saved lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getLockSettings(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<LockSettings, any>>;
    /**
     * Get lock setting by slug
     * @param {string} slug Slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getLockSettingsBySlug(slug: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<LockSettings, any>>;
    /**
     * Returns Stripe connection details
     * @param {string} lockAddress Lock address.
     * @param {number} chain Lock network
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getLockStripeConnectionDetails(lockAddress: string, chain: number, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetLockStripeConnectionDetails200Response, any>>;
    /**
     * Get receipt details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getReceipt(network: number, lockAddress: string, hash: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetReceipt200Response, any>>;
    /**
     * Get all receipts for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getReceipts(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetReceipts200Response, any>>;
    /**
     * Get supplier details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getReceiptsBase(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetReceiptsBase200Response, any>>;
    /**
     * Lists the locks connected to Stripe for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getStripeConnections(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetStripeConnections200Response, any>>;
    /**
     * Get an active subscription associated with the key. It can be fiat or crypto.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getSubscription(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetSubscription200Response, any>>;
    /**
     * get a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetTicket200Response, any>>;
    /**
     * Get the total price for a purchase (including fees)
     * @param {number} network The network the lock is on
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getTotalPrice(network: number, amount?: number, address?: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetTotalPrice200Response, any>>;
    /**
     * Get the price breakdown for universal credit card
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getUniversalCardPrice(network: number, lockAddress: string, purchaseData: Array<string>, recipients: Array<string>, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetChargesForLock200Response, any>>;
    /**
     * Returns if credit card payment are enable for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    isCardPaymentEnabledForLock(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<IsCardPaymentEnabledForLock200Response, any>>;
    /**
     * Get key and user metadata.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    keyMetadata(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<KeyMetadata200Response, any>>;
    /**
     * List of lock keys by network with additional metadata if the caller is the lockManager
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} query Query you want to search for.
     * @param {string} filterKey The key you want to search on.
     * @param {string} [expiration] Expiration time
     * @param {number} [page] Page number when paginating
     * @param {number} [max] Maximum number of items to get by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    keys(network: number, lockAddress: string, query: string, filterKey: string, expiration?: string, page?: number, max?: number, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<KeyMetadata[], any>>;
    /**
     * A list of all checkout configs created by the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listCheckoutConfigs(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ListCheckoutConfigs200Response, any>>;
    /**
     * List payment methods for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listPaymentMethods(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<ListPaymentMethods200Response, any>>;
    /**
     * Get metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    lockMetadata(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<{
        [key: string]: any;
    }, any>>;
    /**
     * Login as a user using Sign in with Ethereum message signed by the wallet address.
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    login(loginRequest: LoginRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<AuthResult, any>>;
    /**
     * Logout from locksmith. This will invalidate all your session tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    logout(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GenericSuccess, any>>;
    /**
     * Provide a unique nonce for using in sign in with ethereum
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    nonce(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<string, any>>;
    /**
     *
     * @param {number} network Network id.
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    price(network: number, amount?: number, address?: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Price200Response, any>>;
    /**
     * Create purchase intent for stripe.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {PurchaseRequest} purchaseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    purchase(network: number, lockAddress: string, purchaseRequest: PurchaseRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Purchase200Response, any>>;
    /**
     * resubscribe emails from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    reSubscribeEmail(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<RemovePaymentMethods200Response, any>>;
    /**
     * Remove all payment methods for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    removePaymentMethods(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<RemovePaymentMethods200Response, any>>;
    /**
     * Invalidate a session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    revoke(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GenericSuccess, any>>;
    /**
     * Save custom email content for a specif lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    saveCustomEmailContent(network: number, lockAddress: string, template: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetCustomEmailContent200Response, any>>;
    /**
     * Save event data
     * @param {SaveEventDataRequest} [saveEventDataRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    saveEventData(saveEventDataRequest?: SaveEventDataRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<SaveEventDataRequest, any>>;
    /**
     * Save lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {LockSettings} [lockSettings]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    saveLockSetting(network: number, lockAddress: string, lockSettings?: LockSettings, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<SaveLockSetting200Response, any>>;
    /**
     * Create purchaser details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    saveReceipt(network: number, lockAddress: string, hash: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<SaveReceipt200Response, any>>;
    /**
     * Create supplier details.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    saveReceiptsBase(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetReceiptsBase200Response, any>>;
    /**
     * Send custom email to recipients
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {SendCustomEmailRequest} [sendCustomEmailRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    sendCustomEmail(network: number, lockAddress: string, sendCustomEmailRequest?: SendCustomEmailRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<SendCustomEmail200Response, any>>;
    /**
     * Setup a payment method for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    setupPayment(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<SetupPayment200Response, any>>;
    /**
     * Generate signature to prove validity of token.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    signTicket(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<SignTicket200Response, any>>;
    /**
     * Get QR code for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    ticketQRCode(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<any, any>>;
    /**
     * Get the verification URL for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    ticketVerificationUrl(network: number, lockAddress: string, keyId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<TicketVerificationUrl200Response, any>>;
    /**
     * Finalize the transfer of a key to a recipient. This is to copy over any locksmith related data to the recipient\'s account.
     * @param {TransferDoneRequest} [transferDoneRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    transferDone(transferDoneRequest?: TransferDoneRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CreateTransferCode404Response, any>>;
    /**
     * Unsubscribe email from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    unsubscribeEmail(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<RemovePaymentMethods200Response, any>>;
    /**
     * Update application by id.
     * @param {string} id Application id.
     * @param {ApplicationBody} [applicationBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    updateApplication(id: string, applicationBody?: ApplicationBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Application, any>>;
    /**
     * A new checkout config is created or updated if it already exists
     * @param {string} id This is optional. If you don\&#39;t pass an ID, a new config will be created. If you pass an ID, the config will be created.
     * @param {UpdateCheckoutConfigRequest} [updateCheckoutConfigRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    updateCheckoutConfig(id: string, updateCheckoutConfigRequest?: UpdateCheckoutConfigRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<CheckoutConfig, any>>;
    /**
     * Update or create metadata for key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    updateKeyMetadata(network: number, lockAddress: string, keyId: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<{
        [key: string]: any;
    }, any>>;
    /**
     * Update or create metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    updateLockMetadata(network: number, lockAddress: string, updateLockMetadataRequest: UpdateLockMetadataRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<{
        [key: string]: any;
    }, any>>;
    /**
     * Update or create user metadata for lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} userAddress User address.
     * @param {UpdateUserMetadataRequest} updateUserMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    updateUserMetadata(network: number, lockAddress: string, userAddress: string, updateUserMetadataRequest: UpdateUserMetadataRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<{
        [key: string]: any;
    }, any>>;
    /**
     * Update or create user metadata for lock.
     * @param {UpdateUsersMetadataRequest} updateUsersMetadataRequest users array containing user metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    updateUsersMetadata(updateUsersMetadataRequest: UpdateUsersMetadataRequest, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<UpdateUsersMetadata201Response, any>>;
    /**
     * Upload images to locksmith
     * @param {Array<any>} [images]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    uploadImages(images?: Array<any>, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<UploadImages201Response, any>>;
    /**
     * Get user details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    user(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Auth, any>>;
    /**
     * Check if an address is a verifier of the lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    verifier(network: number, lockAddress: string, verifierAddress: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Verifier200Response, any>>;
    /**
     * List of verifiers for the lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    verifiers(network: number, lockAddress: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Verifiers200Response, any>>;
}

declare class LocksmithService extends DefaultApi {
    /**
     * Helper static createSiweMessage method wrapping SIWE or sign in with ethereum standard message
     */
    static createSiweMessage(options: Partial<SiweMessage>): SiweMessage;
}

type Maybe<T> = T | null;
type InputMaybe<T> = Maybe<T>;
type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
/** All built-in and custom scalars, mapped to their actual values */
type Scalars = {
    ID: {
        input: string;
        output: string;
    };
    String: {
        input: string;
        output: string;
    };
    Boolean: {
        input: boolean;
        output: boolean;
    };
    Int: {
        input: number;
        output: number;
    };
    Float: {
        input: number;
        output: number;
    };
    BigDecimal: {
        input: any;
        output: any;
    };
    BigInt: {
        input: any;
        output: any;
    };
    Bytes: {
        input: any;
        output: any;
    };
    Int8: {
        input: any;
        output: any;
    };
};
type BlockChangedFilter = {
    number_gte: Scalars['Int']['input'];
};
type Key = {
    __typename?: 'Key';
    /** Invoked by a Lock manager to expire the user's key and perform a refund and cancellation of the key */
    cancelled?: Maybe<Scalars['Boolean']['output']>;
    /** Timestamp of the block in which the key was created */
    createdAt: Scalars['BigInt']['output'];
    /** Block key was created */
    createdAtBlock: Scalars['BigInt']['output'];
    /** Time the key expires */
    expiration: Scalars['BigInt']['output'];
    /** Unique identifier for a key (combination of lock address and token id) */
    id: Scalars['ID']['output'];
    /** In the Unlock ecosystem, a “Lock” is a smart contract that creates (or “mints”) NFTs */
    lock: Lock;
    /** An assigned title set on an Unlock key which gives a specific wallet address authorization to transfer, share or cancel */
    manager?: Maybe<Scalars['Bytes']['output']>;
    /** The address of the key owner */
    owner: Scalars['Bytes']['output'];
    /** TokenId for a given key */
    tokenId: Scalars['BigInt']['output'];
    /** The tokenURI on an NFT is a unique identifier */
    tokenURI?: Maybe<Scalars['String']['output']>;
    /** list of transaction hashes for purchase/extensions of a specific token */
    transactionsHash?: Maybe<Array<Scalars['String']['output']>>;
};
type Key_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    and?: InputMaybe<Array<InputMaybe<Key_Filter>>>;
    cancelled?: InputMaybe<Scalars['Boolean']['input']>;
    cancelled_in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
    cancelled_not?: InputMaybe<Scalars['Boolean']['input']>;
    cancelled_not_in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
    createdAt?: InputMaybe<Scalars['BigInt']['input']>;
    createdAtBlock?: InputMaybe<Scalars['BigInt']['input']>;
    createdAtBlock_gt?: InputMaybe<Scalars['BigInt']['input']>;
    createdAtBlock_gte?: InputMaybe<Scalars['BigInt']['input']>;
    createdAtBlock_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    createdAtBlock_lt?: InputMaybe<Scalars['BigInt']['input']>;
    createdAtBlock_lte?: InputMaybe<Scalars['BigInt']['input']>;
    createdAtBlock_not?: InputMaybe<Scalars['BigInt']['input']>;
    createdAtBlock_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    createdAt_gt?: InputMaybe<Scalars['BigInt']['input']>;
    createdAt_gte?: InputMaybe<Scalars['BigInt']['input']>;
    createdAt_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    createdAt_lt?: InputMaybe<Scalars['BigInt']['input']>;
    createdAt_lte?: InputMaybe<Scalars['BigInt']['input']>;
    createdAt_not?: InputMaybe<Scalars['BigInt']['input']>;
    createdAt_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    expiration?: InputMaybe<Scalars['BigInt']['input']>;
    expiration_gt?: InputMaybe<Scalars['BigInt']['input']>;
    expiration_gte?: InputMaybe<Scalars['BigInt']['input']>;
    expiration_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    expiration_lt?: InputMaybe<Scalars['BigInt']['input']>;
    expiration_lte?: InputMaybe<Scalars['BigInt']['input']>;
    expiration_not?: InputMaybe<Scalars['BigInt']['input']>;
    expiration_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    id?: InputMaybe<Scalars['ID']['input']>;
    id_gt?: InputMaybe<Scalars['ID']['input']>;
    id_gte?: InputMaybe<Scalars['ID']['input']>;
    id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
    id_lt?: InputMaybe<Scalars['ID']['input']>;
    id_lte?: InputMaybe<Scalars['ID']['input']>;
    id_not?: InputMaybe<Scalars['ID']['input']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
    lock?: InputMaybe<Scalars['String']['input']>;
    lock_?: InputMaybe<Lock_Filter>;
    lock_contains?: InputMaybe<Scalars['String']['input']>;
    lock_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    lock_ends_with?: InputMaybe<Scalars['String']['input']>;
    lock_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    lock_gt?: InputMaybe<Scalars['String']['input']>;
    lock_gte?: InputMaybe<Scalars['String']['input']>;
    lock_in?: InputMaybe<Array<Scalars['String']['input']>>;
    lock_lt?: InputMaybe<Scalars['String']['input']>;
    lock_lte?: InputMaybe<Scalars['String']['input']>;
    lock_not?: InputMaybe<Scalars['String']['input']>;
    lock_not_contains?: InputMaybe<Scalars['String']['input']>;
    lock_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    lock_not_ends_with?: InputMaybe<Scalars['String']['input']>;
    lock_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    lock_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
    lock_not_starts_with?: InputMaybe<Scalars['String']['input']>;
    lock_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    lock_starts_with?: InputMaybe<Scalars['String']['input']>;
    lock_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    manager?: InputMaybe<Scalars['Bytes']['input']>;
    manager_contains?: InputMaybe<Scalars['Bytes']['input']>;
    manager_gt?: InputMaybe<Scalars['Bytes']['input']>;
    manager_gte?: InputMaybe<Scalars['Bytes']['input']>;
    manager_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    manager_lt?: InputMaybe<Scalars['Bytes']['input']>;
    manager_lte?: InputMaybe<Scalars['Bytes']['input']>;
    manager_not?: InputMaybe<Scalars['Bytes']['input']>;
    manager_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
    manager_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    or?: InputMaybe<Array<InputMaybe<Key_Filter>>>;
    owner?: InputMaybe<Scalars['Bytes']['input']>;
    owner_contains?: InputMaybe<Scalars['Bytes']['input']>;
    owner_gt?: InputMaybe<Scalars['Bytes']['input']>;
    owner_gte?: InputMaybe<Scalars['Bytes']['input']>;
    owner_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    owner_lt?: InputMaybe<Scalars['Bytes']['input']>;
    owner_lte?: InputMaybe<Scalars['Bytes']['input']>;
    owner_not?: InputMaybe<Scalars['Bytes']['input']>;
    owner_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
    owner_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    tokenId?: InputMaybe<Scalars['BigInt']['input']>;
    tokenId_gt?: InputMaybe<Scalars['BigInt']['input']>;
    tokenId_gte?: InputMaybe<Scalars['BigInt']['input']>;
    tokenId_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    tokenId_lt?: InputMaybe<Scalars['BigInt']['input']>;
    tokenId_lte?: InputMaybe<Scalars['BigInt']['input']>;
    tokenId_not?: InputMaybe<Scalars['BigInt']['input']>;
    tokenId_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    tokenURI?: InputMaybe<Scalars['String']['input']>;
    tokenURI_contains?: InputMaybe<Scalars['String']['input']>;
    tokenURI_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    tokenURI_ends_with?: InputMaybe<Scalars['String']['input']>;
    tokenURI_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    tokenURI_gt?: InputMaybe<Scalars['String']['input']>;
    tokenURI_gte?: InputMaybe<Scalars['String']['input']>;
    tokenURI_in?: InputMaybe<Array<Scalars['String']['input']>>;
    tokenURI_lt?: InputMaybe<Scalars['String']['input']>;
    tokenURI_lte?: InputMaybe<Scalars['String']['input']>;
    tokenURI_not?: InputMaybe<Scalars['String']['input']>;
    tokenURI_not_contains?: InputMaybe<Scalars['String']['input']>;
    tokenURI_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    tokenURI_not_ends_with?: InputMaybe<Scalars['String']['input']>;
    tokenURI_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    tokenURI_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
    tokenURI_not_starts_with?: InputMaybe<Scalars['String']['input']>;
    tokenURI_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    tokenURI_starts_with?: InputMaybe<Scalars['String']['input']>;
    tokenURI_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    transactionsHash?: InputMaybe<Array<Scalars['String']['input']>>;
    transactionsHash_contains?: InputMaybe<Array<Scalars['String']['input']>>;
    transactionsHash_contains_nocase?: InputMaybe<Array<Scalars['String']['input']>>;
    transactionsHash_not?: InputMaybe<Array<Scalars['String']['input']>>;
    transactionsHash_not_contains?: InputMaybe<Array<Scalars['String']['input']>>;
    transactionsHash_not_contains_nocase?: InputMaybe<Array<Scalars['String']['input']>>;
};
declare enum Key_OrderBy {
    Cancelled = "cancelled",
    CreatedAt = "createdAt",
    CreatedAtBlock = "createdAtBlock",
    Expiration = "expiration",
    Id = "id",
    Lock = "lock",
    LockAddress = "lock__address",
    LockCreatedAtBlock = "lock__createdAtBlock",
    LockDeployer = "lock__deployer",
    LockExpirationDuration = "lock__expirationDuration",
    LockId = "lock__id",
    LockLastKeyMintedAt = "lock__lastKeyMintedAt",
    LockMaxKeysPerAddress = "lock__maxKeysPerAddress",
    LockMaxNumberOfKeys = "lock__maxNumberOfKeys",
    LockName = "lock__name",
    LockNumberOfReceipts = "lock__numberOfReceipts",
    LockPrice = "lock__price",
    LockSymbol = "lock__symbol",
    LockTokenAddress = "lock__tokenAddress",
    LockTotalKeys = "lock__totalKeys",
    LockVersion = "lock__version",
    Manager = "manager",
    Owner = "owner",
    TokenId = "tokenId",
    TokenUri = "tokenURI",
    TransactionsHash = "transactionsHash"
}
type Lock = {
    __typename?: 'Lock';
    /** Address of the lock */
    address: Scalars['Bytes']['output'];
    /** Which block the lock was created */
    createdAtBlock?: Maybe<Scalars['BigInt']['output']>;
    /** Address of the lock deployer */
    deployer: Scalars['Bytes']['output'];
    /** Duration is set the on the lock when you deploy and the expiration which is set on each key when they are minted */
    expirationDuration?: Maybe<Scalars['BigInt']['output']>;
    /** Unique ID for the Lock object (uses the lock address) */
    id: Scalars['ID']['output'];
    /** Refer to key entity */
    keys?: Maybe<Array<Key>>;
    /** The timestamp of the block in which the last key was minted */
    lastKeyMintedAt?: Maybe<Scalars['BigInt']['output']>;
    /** An assigned role set on a Lock contract which gives the highest level of permissions to the wallet address set to that role */
    lockManagers: Array<Scalars['Bytes']['output']>;
    /** The maximum number of keys allowed for a single address */
    maxKeysPerAddress?: Maybe<Scalars['BigInt']['output']>;
    /** Maximum number of keys for sale */
    maxNumberOfKeys?: Maybe<Scalars['BigInt']['output']>;
    /** A descriptive name for a collection of NFTs in this contract */
    name?: Maybe<Scalars['String']['output']>;
    /** Total number of receipts of lock */
    numberOfReceipts: Scalars['BigInt']['output'];
    /** Price of the keys sold by the lock */
    price: Scalars['BigInt']['output'];
    /** Referrers fees set per custom address */
    referrerFees: Array<ReferrerFee>;
    /** Token symbol */
    symbol?: Maybe<Scalars['String']['output']>;
    /** Address of the 'currency' ERC20 contract if the keys are priced using an ERC20 */
    tokenAddress: Scalars['Bytes']['output'];
    /** Number of keys minted (expired or not) */
    totalKeys: Scalars['BigInt']['output'];
    /** Unlock Protocol version of a minting contract */
    version: Scalars['BigInt']['output'];
};
type Lock_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    address?: InputMaybe<Scalars['Bytes']['input']>;
    address_contains?: InputMaybe<Scalars['Bytes']['input']>;
    address_gt?: InputMaybe<Scalars['Bytes']['input']>;
    address_gte?: InputMaybe<Scalars['Bytes']['input']>;
    address_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    address_lt?: InputMaybe<Scalars['Bytes']['input']>;
    address_lte?: InputMaybe<Scalars['Bytes']['input']>;
    address_not?: InputMaybe<Scalars['Bytes']['input']>;
    address_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
    address_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    and?: InputMaybe<Array<InputMaybe<Lock_Filter>>>;
    createdAtBlock?: InputMaybe<Scalars['BigInt']['input']>;
    createdAtBlock_gt?: InputMaybe<Scalars['BigInt']['input']>;
    createdAtBlock_gte?: InputMaybe<Scalars['BigInt']['input']>;
    createdAtBlock_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    createdAtBlock_lt?: InputMaybe<Scalars['BigInt']['input']>;
    createdAtBlock_lte?: InputMaybe<Scalars['BigInt']['input']>;
    createdAtBlock_not?: InputMaybe<Scalars['BigInt']['input']>;
    createdAtBlock_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    deployer?: InputMaybe<Scalars['Bytes']['input']>;
    deployer_contains?: InputMaybe<Scalars['Bytes']['input']>;
    deployer_gt?: InputMaybe<Scalars['Bytes']['input']>;
    deployer_gte?: InputMaybe<Scalars['Bytes']['input']>;
    deployer_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    deployer_lt?: InputMaybe<Scalars['Bytes']['input']>;
    deployer_lte?: InputMaybe<Scalars['Bytes']['input']>;
    deployer_not?: InputMaybe<Scalars['Bytes']['input']>;
    deployer_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
    deployer_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    expirationDuration?: InputMaybe<Scalars['BigInt']['input']>;
    expirationDuration_gt?: InputMaybe<Scalars['BigInt']['input']>;
    expirationDuration_gte?: InputMaybe<Scalars['BigInt']['input']>;
    expirationDuration_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    expirationDuration_lt?: InputMaybe<Scalars['BigInt']['input']>;
    expirationDuration_lte?: InputMaybe<Scalars['BigInt']['input']>;
    expirationDuration_not?: InputMaybe<Scalars['BigInt']['input']>;
    expirationDuration_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    id?: InputMaybe<Scalars['ID']['input']>;
    id_gt?: InputMaybe<Scalars['ID']['input']>;
    id_gte?: InputMaybe<Scalars['ID']['input']>;
    id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
    id_lt?: InputMaybe<Scalars['ID']['input']>;
    id_lte?: InputMaybe<Scalars['ID']['input']>;
    id_not?: InputMaybe<Scalars['ID']['input']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
    keys_?: InputMaybe<Key_Filter>;
    lastKeyMintedAt?: InputMaybe<Scalars['BigInt']['input']>;
    lastKeyMintedAt_gt?: InputMaybe<Scalars['BigInt']['input']>;
    lastKeyMintedAt_gte?: InputMaybe<Scalars['BigInt']['input']>;
    lastKeyMintedAt_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    lastKeyMintedAt_lt?: InputMaybe<Scalars['BigInt']['input']>;
    lastKeyMintedAt_lte?: InputMaybe<Scalars['BigInt']['input']>;
    lastKeyMintedAt_not?: InputMaybe<Scalars['BigInt']['input']>;
    lastKeyMintedAt_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    lockManagers?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    lockManagers_contains?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    lockManagers_contains_nocase?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    lockManagers_not?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    lockManagers_not_contains?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    lockManagers_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    maxKeysPerAddress?: InputMaybe<Scalars['BigInt']['input']>;
    maxKeysPerAddress_gt?: InputMaybe<Scalars['BigInt']['input']>;
    maxKeysPerAddress_gte?: InputMaybe<Scalars['BigInt']['input']>;
    maxKeysPerAddress_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    maxKeysPerAddress_lt?: InputMaybe<Scalars['BigInt']['input']>;
    maxKeysPerAddress_lte?: InputMaybe<Scalars['BigInt']['input']>;
    maxKeysPerAddress_not?: InputMaybe<Scalars['BigInt']['input']>;
    maxKeysPerAddress_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    maxNumberOfKeys?: InputMaybe<Scalars['BigInt']['input']>;
    maxNumberOfKeys_gt?: InputMaybe<Scalars['BigInt']['input']>;
    maxNumberOfKeys_gte?: InputMaybe<Scalars['BigInt']['input']>;
    maxNumberOfKeys_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    maxNumberOfKeys_lt?: InputMaybe<Scalars['BigInt']['input']>;
    maxNumberOfKeys_lte?: InputMaybe<Scalars['BigInt']['input']>;
    maxNumberOfKeys_not?: InputMaybe<Scalars['BigInt']['input']>;
    maxNumberOfKeys_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    name?: InputMaybe<Scalars['String']['input']>;
    name_contains?: InputMaybe<Scalars['String']['input']>;
    name_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    name_ends_with?: InputMaybe<Scalars['String']['input']>;
    name_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    name_gt?: InputMaybe<Scalars['String']['input']>;
    name_gte?: InputMaybe<Scalars['String']['input']>;
    name_in?: InputMaybe<Array<Scalars['String']['input']>>;
    name_lt?: InputMaybe<Scalars['String']['input']>;
    name_lte?: InputMaybe<Scalars['String']['input']>;
    name_not?: InputMaybe<Scalars['String']['input']>;
    name_not_contains?: InputMaybe<Scalars['String']['input']>;
    name_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    name_not_ends_with?: InputMaybe<Scalars['String']['input']>;
    name_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    name_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
    name_not_starts_with?: InputMaybe<Scalars['String']['input']>;
    name_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    name_starts_with?: InputMaybe<Scalars['String']['input']>;
    name_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    numberOfReceipts?: InputMaybe<Scalars['BigInt']['input']>;
    numberOfReceipts_gt?: InputMaybe<Scalars['BigInt']['input']>;
    numberOfReceipts_gte?: InputMaybe<Scalars['BigInt']['input']>;
    numberOfReceipts_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    numberOfReceipts_lt?: InputMaybe<Scalars['BigInt']['input']>;
    numberOfReceipts_lte?: InputMaybe<Scalars['BigInt']['input']>;
    numberOfReceipts_not?: InputMaybe<Scalars['BigInt']['input']>;
    numberOfReceipts_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    or?: InputMaybe<Array<InputMaybe<Lock_Filter>>>;
    price?: InputMaybe<Scalars['BigInt']['input']>;
    price_gt?: InputMaybe<Scalars['BigInt']['input']>;
    price_gte?: InputMaybe<Scalars['BigInt']['input']>;
    price_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    price_lt?: InputMaybe<Scalars['BigInt']['input']>;
    price_lte?: InputMaybe<Scalars['BigInt']['input']>;
    price_not?: InputMaybe<Scalars['BigInt']['input']>;
    price_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    referrerFees_?: InputMaybe<ReferrerFee_Filter>;
    symbol?: InputMaybe<Scalars['String']['input']>;
    symbol_contains?: InputMaybe<Scalars['String']['input']>;
    symbol_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    symbol_ends_with?: InputMaybe<Scalars['String']['input']>;
    symbol_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    symbol_gt?: InputMaybe<Scalars['String']['input']>;
    symbol_gte?: InputMaybe<Scalars['String']['input']>;
    symbol_in?: InputMaybe<Array<Scalars['String']['input']>>;
    symbol_lt?: InputMaybe<Scalars['String']['input']>;
    symbol_lte?: InputMaybe<Scalars['String']['input']>;
    symbol_not?: InputMaybe<Scalars['String']['input']>;
    symbol_not_contains?: InputMaybe<Scalars['String']['input']>;
    symbol_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    symbol_not_ends_with?: InputMaybe<Scalars['String']['input']>;
    symbol_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    symbol_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
    symbol_not_starts_with?: InputMaybe<Scalars['String']['input']>;
    symbol_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    symbol_starts_with?: InputMaybe<Scalars['String']['input']>;
    symbol_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    tokenAddress?: InputMaybe<Scalars['Bytes']['input']>;
    tokenAddress_contains?: InputMaybe<Scalars['Bytes']['input']>;
    tokenAddress_gt?: InputMaybe<Scalars['Bytes']['input']>;
    tokenAddress_gte?: InputMaybe<Scalars['Bytes']['input']>;
    tokenAddress_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    tokenAddress_lt?: InputMaybe<Scalars['Bytes']['input']>;
    tokenAddress_lte?: InputMaybe<Scalars['Bytes']['input']>;
    tokenAddress_not?: InputMaybe<Scalars['Bytes']['input']>;
    tokenAddress_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
    tokenAddress_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    totalKeys?: InputMaybe<Scalars['BigInt']['input']>;
    totalKeys_gt?: InputMaybe<Scalars['BigInt']['input']>;
    totalKeys_gte?: InputMaybe<Scalars['BigInt']['input']>;
    totalKeys_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    totalKeys_lt?: InputMaybe<Scalars['BigInt']['input']>;
    totalKeys_lte?: InputMaybe<Scalars['BigInt']['input']>;
    totalKeys_not?: InputMaybe<Scalars['BigInt']['input']>;
    totalKeys_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    version?: InputMaybe<Scalars['BigInt']['input']>;
    version_gt?: InputMaybe<Scalars['BigInt']['input']>;
    version_gte?: InputMaybe<Scalars['BigInt']['input']>;
    version_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    version_lt?: InputMaybe<Scalars['BigInt']['input']>;
    version_lte?: InputMaybe<Scalars['BigInt']['input']>;
    version_not?: InputMaybe<Scalars['BigInt']['input']>;
    version_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};
declare enum Lock_OrderBy {
    Address = "address",
    CreatedAtBlock = "createdAtBlock",
    Deployer = "deployer",
    ExpirationDuration = "expirationDuration",
    Id = "id",
    Keys = "keys",
    LastKeyMintedAt = "lastKeyMintedAt",
    LockManagers = "lockManagers",
    MaxKeysPerAddress = "maxKeysPerAddress",
    MaxNumberOfKeys = "maxNumberOfKeys",
    Name = "name",
    NumberOfReceipts = "numberOfReceipts",
    Price = "price",
    ReferrerFees = "referrerFees",
    Symbol = "symbol",
    TokenAddress = "tokenAddress",
    TotalKeys = "totalKeys",
    Version = "version"
}
/** Defines the order direction, either ascending or descending */
declare enum OrderDirection {
    Asc = "asc",
    Desc = "desc"
}
type Receipt_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    amountTransferred?: InputMaybe<Scalars['BigInt']['input']>;
    amountTransferred_gt?: InputMaybe<Scalars['BigInt']['input']>;
    amountTransferred_gte?: InputMaybe<Scalars['BigInt']['input']>;
    amountTransferred_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    amountTransferred_lt?: InputMaybe<Scalars['BigInt']['input']>;
    amountTransferred_lte?: InputMaybe<Scalars['BigInt']['input']>;
    amountTransferred_not?: InputMaybe<Scalars['BigInt']['input']>;
    amountTransferred_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    and?: InputMaybe<Array<InputMaybe<Receipt_Filter>>>;
    gasTotal?: InputMaybe<Scalars['BigInt']['input']>;
    gasTotal_gt?: InputMaybe<Scalars['BigInt']['input']>;
    gasTotal_gte?: InputMaybe<Scalars['BigInt']['input']>;
    gasTotal_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    gasTotal_lt?: InputMaybe<Scalars['BigInt']['input']>;
    gasTotal_lte?: InputMaybe<Scalars['BigInt']['input']>;
    gasTotal_not?: InputMaybe<Scalars['BigInt']['input']>;
    gasTotal_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    id?: InputMaybe<Scalars['ID']['input']>;
    id_gt?: InputMaybe<Scalars['ID']['input']>;
    id_gte?: InputMaybe<Scalars['ID']['input']>;
    id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
    id_lt?: InputMaybe<Scalars['ID']['input']>;
    id_lte?: InputMaybe<Scalars['ID']['input']>;
    id_not?: InputMaybe<Scalars['ID']['input']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
    lockAddress?: InputMaybe<Scalars['String']['input']>;
    lockAddress_contains?: InputMaybe<Scalars['String']['input']>;
    lockAddress_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    lockAddress_ends_with?: InputMaybe<Scalars['String']['input']>;
    lockAddress_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    lockAddress_gt?: InputMaybe<Scalars['String']['input']>;
    lockAddress_gte?: InputMaybe<Scalars['String']['input']>;
    lockAddress_in?: InputMaybe<Array<Scalars['String']['input']>>;
    lockAddress_lt?: InputMaybe<Scalars['String']['input']>;
    lockAddress_lte?: InputMaybe<Scalars['String']['input']>;
    lockAddress_not?: InputMaybe<Scalars['String']['input']>;
    lockAddress_not_contains?: InputMaybe<Scalars['String']['input']>;
    lockAddress_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    lockAddress_not_ends_with?: InputMaybe<Scalars['String']['input']>;
    lockAddress_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    lockAddress_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
    lockAddress_not_starts_with?: InputMaybe<Scalars['String']['input']>;
    lockAddress_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    lockAddress_starts_with?: InputMaybe<Scalars['String']['input']>;
    lockAddress_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    or?: InputMaybe<Array<InputMaybe<Receipt_Filter>>>;
    payer?: InputMaybe<Scalars['String']['input']>;
    payer_contains?: InputMaybe<Scalars['String']['input']>;
    payer_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    payer_ends_with?: InputMaybe<Scalars['String']['input']>;
    payer_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    payer_gt?: InputMaybe<Scalars['String']['input']>;
    payer_gte?: InputMaybe<Scalars['String']['input']>;
    payer_in?: InputMaybe<Array<Scalars['String']['input']>>;
    payer_lt?: InputMaybe<Scalars['String']['input']>;
    payer_lte?: InputMaybe<Scalars['String']['input']>;
    payer_not?: InputMaybe<Scalars['String']['input']>;
    payer_not_contains?: InputMaybe<Scalars['String']['input']>;
    payer_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    payer_not_ends_with?: InputMaybe<Scalars['String']['input']>;
    payer_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    payer_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
    payer_not_starts_with?: InputMaybe<Scalars['String']['input']>;
    payer_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    payer_starts_with?: InputMaybe<Scalars['String']['input']>;
    payer_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    receiptNumber?: InputMaybe<Scalars['BigInt']['input']>;
    receiptNumber_gt?: InputMaybe<Scalars['BigInt']['input']>;
    receiptNumber_gte?: InputMaybe<Scalars['BigInt']['input']>;
    receiptNumber_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    receiptNumber_lt?: InputMaybe<Scalars['BigInt']['input']>;
    receiptNumber_lte?: InputMaybe<Scalars['BigInt']['input']>;
    receiptNumber_not?: InputMaybe<Scalars['BigInt']['input']>;
    receiptNumber_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    sender?: InputMaybe<Scalars['String']['input']>;
    sender_contains?: InputMaybe<Scalars['String']['input']>;
    sender_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    sender_ends_with?: InputMaybe<Scalars['String']['input']>;
    sender_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    sender_gt?: InputMaybe<Scalars['String']['input']>;
    sender_gte?: InputMaybe<Scalars['String']['input']>;
    sender_in?: InputMaybe<Array<Scalars['String']['input']>>;
    sender_lt?: InputMaybe<Scalars['String']['input']>;
    sender_lte?: InputMaybe<Scalars['String']['input']>;
    sender_not?: InputMaybe<Scalars['String']['input']>;
    sender_not_contains?: InputMaybe<Scalars['String']['input']>;
    sender_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    sender_not_ends_with?: InputMaybe<Scalars['String']['input']>;
    sender_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    sender_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
    sender_not_starts_with?: InputMaybe<Scalars['String']['input']>;
    sender_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    sender_starts_with?: InputMaybe<Scalars['String']['input']>;
    sender_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    timestamp?: InputMaybe<Scalars['BigInt']['input']>;
    timestamp_gt?: InputMaybe<Scalars['BigInt']['input']>;
    timestamp_gte?: InputMaybe<Scalars['BigInt']['input']>;
    timestamp_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    timestamp_lt?: InputMaybe<Scalars['BigInt']['input']>;
    timestamp_lte?: InputMaybe<Scalars['BigInt']['input']>;
    timestamp_not?: InputMaybe<Scalars['BigInt']['input']>;
    timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    tokenAddress?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_contains?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_ends_with?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_gt?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_gte?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_in?: InputMaybe<Array<Scalars['String']['input']>>;
    tokenAddress_lt?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_lte?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_not?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_not_contains?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_not_ends_with?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
    tokenAddress_not_starts_with?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_starts_with?: InputMaybe<Scalars['String']['input']>;
    tokenAddress_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
};
declare enum Receipt_OrderBy {
    AmountTransferred = "amountTransferred",
    GasTotal = "gasTotal",
    Id = "id",
    LockAddress = "lockAddress",
    Payer = "payer",
    ReceiptNumber = "receiptNumber",
    Sender = "sender",
    Timestamp = "timestamp",
    TokenAddress = "tokenAddress"
}
type ReferrerFee = {
    __typename?: 'ReferrerFee';
    /** Fee attributed to the referrer. E.g., 200 represents 20%. */
    fee: Scalars['BigInt']['output'];
    /** Address of the Referrer */
    id: Scalars['ID']['output'];
    /** In the Unlock ecosystem, a “Lock” is a smart contract that creates (or “mints”) NFTs */
    lock: Lock;
    /** Address of the referrer. */
    referrer: Scalars['Bytes']['output'];
};
type ReferrerFee_Filter = {
    /** Filter for the block changed event. */
    _change_block?: InputMaybe<BlockChangedFilter>;
    and?: InputMaybe<Array<InputMaybe<ReferrerFee_Filter>>>;
    fee?: InputMaybe<Scalars['BigInt']['input']>;
    fee_gt?: InputMaybe<Scalars['BigInt']['input']>;
    fee_gte?: InputMaybe<Scalars['BigInt']['input']>;
    fee_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    fee_lt?: InputMaybe<Scalars['BigInt']['input']>;
    fee_lte?: InputMaybe<Scalars['BigInt']['input']>;
    fee_not?: InputMaybe<Scalars['BigInt']['input']>;
    fee_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
    id?: InputMaybe<Scalars['ID']['input']>;
    id_gt?: InputMaybe<Scalars['ID']['input']>;
    id_gte?: InputMaybe<Scalars['ID']['input']>;
    id_in?: InputMaybe<Array<Scalars['ID']['input']>>;
    id_lt?: InputMaybe<Scalars['ID']['input']>;
    id_lte?: InputMaybe<Scalars['ID']['input']>;
    id_not?: InputMaybe<Scalars['ID']['input']>;
    id_not_in?: InputMaybe<Array<Scalars['ID']['input']>>;
    lock?: InputMaybe<Scalars['String']['input']>;
    lock_?: InputMaybe<Lock_Filter>;
    lock_contains?: InputMaybe<Scalars['String']['input']>;
    lock_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    lock_ends_with?: InputMaybe<Scalars['String']['input']>;
    lock_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    lock_gt?: InputMaybe<Scalars['String']['input']>;
    lock_gte?: InputMaybe<Scalars['String']['input']>;
    lock_in?: InputMaybe<Array<Scalars['String']['input']>>;
    lock_lt?: InputMaybe<Scalars['String']['input']>;
    lock_lte?: InputMaybe<Scalars['String']['input']>;
    lock_not?: InputMaybe<Scalars['String']['input']>;
    lock_not_contains?: InputMaybe<Scalars['String']['input']>;
    lock_not_contains_nocase?: InputMaybe<Scalars['String']['input']>;
    lock_not_ends_with?: InputMaybe<Scalars['String']['input']>;
    lock_not_ends_with_nocase?: InputMaybe<Scalars['String']['input']>;
    lock_not_in?: InputMaybe<Array<Scalars['String']['input']>>;
    lock_not_starts_with?: InputMaybe<Scalars['String']['input']>;
    lock_not_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    lock_starts_with?: InputMaybe<Scalars['String']['input']>;
    lock_starts_with_nocase?: InputMaybe<Scalars['String']['input']>;
    or?: InputMaybe<Array<InputMaybe<ReferrerFee_Filter>>>;
    referrer?: InputMaybe<Scalars['Bytes']['input']>;
    referrer_contains?: InputMaybe<Scalars['Bytes']['input']>;
    referrer_gt?: InputMaybe<Scalars['Bytes']['input']>;
    referrer_gte?: InputMaybe<Scalars['Bytes']['input']>;
    referrer_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
    referrer_lt?: InputMaybe<Scalars['Bytes']['input']>;
    referrer_lte?: InputMaybe<Scalars['Bytes']['input']>;
    referrer_not?: InputMaybe<Scalars['Bytes']['input']>;
    referrer_not_contains?: InputMaybe<Scalars['Bytes']['input']>;
    referrer_not_in?: InputMaybe<Array<Scalars['Bytes']['input']>>;
};
type AllLocksQueryVariables = Exact<{
    first?: InputMaybe<Scalars['Int']['input']>;
    skip?: InputMaybe<Scalars['Int']['input']>;
    where?: InputMaybe<Lock_Filter>;
    orderBy?: InputMaybe<Lock_OrderBy>;
    orderDirection?: InputMaybe<OrderDirection>;
    referrerFeeSkip?: InputMaybe<Scalars['Int']['input']>;
}>;
type AllLocksQuery = {
    __typename?: 'Query';
    locks: Array<{
        __typename?: 'Lock';
        id: string;
        address: any;
        name?: string | null;
        expirationDuration?: any | null;
        tokenAddress: any;
        symbol?: string | null;
        price: any;
        lockManagers: Array<any>;
        version: any;
        maxNumberOfKeys?: any | null;
        maxKeysPerAddress?: any | null;
        createdAtBlock?: any | null;
        totalKeys: any;
        referrerFees: Array<{
            __typename?: 'ReferrerFee';
            id: string;
            referrer: any;
            fee: any;
        }>;
    }>;
};
type AllKeysQueryVariables = Exact<{
    first?: InputMaybe<Scalars['Int']['input']>;
    skip?: InputMaybe<Scalars['Int']['input']>;
    where?: InputMaybe<Key_Filter>;
    orderBy?: InputMaybe<Key_OrderBy>;
    orderDirection?: InputMaybe<OrderDirection>;
}>;
type AllKeysQuery = {
    __typename?: 'Query';
    keys: Array<{
        __typename?: 'Key';
        id: string;
        tokenId: any;
        owner: any;
        manager?: any | null;
        expiration: any;
        tokenURI?: string | null;
        createdAtBlock: any;
        cancelled?: boolean | null;
        transactionsHash?: Array<string> | null;
        lock: {
            __typename?: 'Lock';
            id: string;
            address: any;
            name?: string | null;
            expirationDuration?: any | null;
            tokenAddress: any;
            symbol?: string | null;
            price: any;
            lockManagers: Array<any>;
            version: any;
            maxNumberOfKeys?: any | null;
            maxKeysPerAddress?: any | null;
            createdAtBlock?: any | null;
            totalKeys: any;
        };
    }>;
};
type AllReceiptsQueryVariables = Exact<{
    first?: InputMaybe<Scalars['Int']['input']>;
    skip?: InputMaybe<Scalars['Int']['input']>;
    where?: InputMaybe<Receipt_Filter>;
    orderBy?: InputMaybe<Receipt_OrderBy>;
    orderDirection?: InputMaybe<OrderDirection>;
}>;
type AllReceiptsQuery = {
    __typename?: 'Query';
    receipts: Array<{
        __typename?: 'Receipt';
        id: string;
        receiptNumber: any;
        timestamp: any;
        sender: string;
        payer?: string | null;
        lockAddress: string;
        tokenAddress: string;
        gasTotal: any;
        amountTransferred: any;
    }>;
};
type AllLocksWithKeysQuery = {
    __typename?: 'Query';
    locks: Array<{
        __typename?: 'Lock';
        id: string;
        address: any;
        name?: string | null;
        expirationDuration?: any | null;
        tokenAddress: any;
        symbol?: string | null;
        price: any;
        lockManagers: Array<any>;
        version: any;
        maxNumberOfKeys?: any | null;
        maxKeysPerAddress?: any | null;
        createdAtBlock?: any | null;
        totalKeys: any;
        keys?: Array<{
            __typename?: 'Key';
            id: string;
            tokenId: any;
            owner: any;
            manager?: any | null;
            expiration: any;
            tokenURI?: string | null;
            createdAtBlock: any;
            cancelled?: boolean | null;
            transactionsHash?: Array<string> | null;
        }> | null;
    }>;
};

interface QueryOptions {
    networks?: number[] | string[];
}
declare class SubgraphService {
    networks: NetworkConfigs;
    constructor(networks?: NetworkConfigs);
    createSdk(networkId?: number): {
        allLocks(variables?: Exact<{
            first?: InputMaybe<number> | undefined;
            skip?: InputMaybe<number> | undefined;
            where?: InputMaybe<Lock_Filter> | undefined;
            orderBy?: InputMaybe<Lock_OrderBy> | undefined;
            orderDirection?: InputMaybe<OrderDirection> | undefined;
            referrerFeeSkip?: InputMaybe<number> | undefined;
        }> | undefined, requestHeaders?: graphql_request_build_cjs_types.GraphQLClientRequestHeaders | undefined): Promise<AllLocksQuery>;
        AllKeys(variables?: Exact<{
            first?: InputMaybe<number> | undefined;
            skip?: InputMaybe<number> | undefined;
            where?: InputMaybe<Key_Filter> | undefined;
            orderBy?: InputMaybe<Key_OrderBy> | undefined;
            orderDirection?: InputMaybe<OrderDirection> | undefined;
        }> | undefined, requestHeaders?: graphql_request_build_cjs_types.GraphQLClientRequestHeaders | undefined): Promise<AllKeysQuery>;
        AllReceipts(variables?: Exact<{
            first?: InputMaybe<number> | undefined;
            skip?: InputMaybe<number> | undefined;
            where?: InputMaybe<Receipt_Filter> | undefined;
            orderBy?: InputMaybe<Receipt_OrderBy> | undefined;
            orderDirection?: InputMaybe<OrderDirection> | undefined;
        }> | undefined, requestHeaders?: graphql_request_build_cjs_types.GraphQLClientRequestHeaders | undefined): Promise<AllReceiptsQuery>;
        allLocksWithKeys(variables?: Exact<{
            first?: InputMaybe<number> | undefined;
            skip?: InputMaybe<number> | undefined;
            where?: InputMaybe<Lock_Filter> | undefined;
            keyFilter?: InputMaybe<Key_Filter> | undefined;
            orderBy?: InputMaybe<Lock_OrderBy> | undefined;
            keyOrderBy?: InputMaybe<Key_OrderBy> | undefined;
            orderDirection?: InputMaybe<OrderDirection> | undefined;
        }> | undefined, requestHeaders?: graphql_request_build_cjs_types.GraphQLClientRequestHeaders | undefined): Promise<AllLocksWithKeysQuery>;
    };
    /**
     * Get locks from multiple networks. By default, all networks will be queried.
     * If you want to query only specific network, you can pass options as the second parameter with network ids array.
     * ```ts
     * const service = new SubgraphService()
     * const locksOnMainnetAndGoerli = await service.locks({ first: 100, skip: 50, where: {}}, { networks: [1, 5] })
     * const locksOnAllNetworks = await service.locks({ first: 1000 })
     * ```
     */
    locks(variables: AllLocksQueryVariables, options?: QueryOptions): Promise<{
        network: number;
        __typename?: "Lock" | undefined;
        id: string;
        address: any;
        name?: string | null | undefined;
        expirationDuration?: any;
        tokenAddress: any;
        symbol?: string | null | undefined;
        price: any;
        lockManagers: any[];
        version: any;
        maxNumberOfKeys?: any;
        maxKeysPerAddress?: any;
        createdAtBlock?: any;
        totalKeys: any;
        referrerFees: {
            __typename?: "ReferrerFee" | undefined;
            id: string;
            referrer: any;
            fee: any;
        }[];
    }[]>;
    /**
     * Get locks with keys from multiple networks. By default, all networks will be queried.
     * If you want to query only specific network, you can pass options as the second parameter with network ids array.
     * ```ts
     * const service = new SubgraphService()
     * const locksKeysOnMainnetAndGoerli = await service.locksKeys({ first: 100, skip: 50, where: {}}, { networks: [1, 5] })
     * const locksKeysOnAllNetworks = await service.locksKeys({ first: 1000 })
     * ```
     */
    locksKeys(variables: AllLocksQueryVariables & {
        keyFilter?: Key_Filter;
        keyOrderBy?: Key_OrderBy;
    }, options?: QueryOptions): Promise<{
        network: number;
        __typename?: "Lock" | undefined;
        id: string;
        address: any;
        name?: string | null | undefined;
        expirationDuration?: any;
        tokenAddress: any;
        symbol?: string | null | undefined;
        price: any;
        lockManagers: any[];
        version: any;
        maxNumberOfKeys?: any;
        maxKeysPerAddress?: any;
        createdAtBlock?: any;
        totalKeys: any;
        keys?: {
            __typename?: "Key" | undefined;
            id: string;
            tokenId: any;
            owner: any;
            manager?: any;
            expiration: any;
            tokenURI?: string | null | undefined;
            createdAtBlock: any;
            cancelled?: boolean | null | undefined;
            transactionsHash?: string[] | null | undefined;
        }[] | null | undefined;
    }[]>;
    /**
     * Get a single lock on a network. This is a helper provided on top of locks.
     */
    lock(variables: Omit<AllLocksQueryVariables, 'first'>, options: {
        network: number;
    }): Promise<{
        network: number;
        __typename?: "Lock" | undefined;
        id: string;
        address: any;
        name?: string | null | undefined;
        expirationDuration?: any;
        tokenAddress: any;
        symbol?: string | null | undefined;
        price: any;
        lockManagers: any[];
        version: any;
        maxNumberOfKeys?: any;
        maxKeysPerAddress?: any;
        createdAtBlock?: any;
        totalKeys: any;
        referrerFees: {
            __typename?: "ReferrerFee" | undefined;
            id: string;
            referrer: any;
            fee: any;
        }[];
    }>;
    /**
     * Get keys and associated lock data from multiple networks. By default, all networks will be queried.
     * If you want to query only specific network, you can pass options as the second parameter with network ids array.
     * ```ts
     * const service = new SubgraphService()
     * const keysOnMainnetAndGoerli = await service.keys({ first: 100, skip: 50, where: {}}, { networks: [1, 5] })
     * const keysOnAllNetworks = await service.keys({ first: 1000 })
     * ```
     */
    keys(variables: AllKeysQueryVariables, options?: QueryOptions): Promise<{
        network: number;
        __typename?: "Key" | undefined;
        id: string;
        tokenId: any;
        owner: any;
        manager?: any;
        expiration: any;
        tokenURI?: string | null | undefined;
        createdAtBlock: any;
        cancelled?: boolean | null | undefined;
        transactionsHash?: string[] | null | undefined;
        lock: {
            __typename?: "Lock" | undefined;
            id: string;
            address: any;
            name?: string | null | undefined;
            expirationDuration?: any;
            tokenAddress: any;
            symbol?: string | null | undefined;
            price: any;
            lockManagers: any[];
            version: any;
            maxNumberOfKeys?: any;
            maxKeysPerAddress?: any;
            createdAtBlock?: any;
            totalKeys: any;
        };
    }[]>;
    /**
     * Get a single key on a network. This is a helper provided on top of keys.
     */
    key(variables: Omit<AllKeysQueryVariables, 'first'>, options: Record<'network', number>): Promise<{
        network: number;
        __typename?: "Key" | undefined;
        id: string;
        tokenId: any;
        owner: any;
        manager?: any;
        expiration: any;
        tokenURI?: string | null | undefined;
        createdAtBlock: any;
        cancelled?: boolean | null | undefined;
        transactionsHash?: string[] | null | undefined;
        lock: {
            __typename?: "Lock" | undefined;
            id: string;
            address: any;
            name?: string | null | undefined;
            expirationDuration?: any;
            tokenAddress: any;
            symbol?: string | null | undefined;
            price: any;
            lockManagers: any[];
            version: any;
            maxNumberOfKeys?: any;
            maxKeysPerAddress?: any;
            createdAtBlock?: any;
            totalKeys: any;
        };
    }>;
    /** Get list or receipts from multiple networks */
    receipts(variables: AllReceiptsQueryVariables, options?: QueryOptions): Promise<{
        network: number;
        __typename?: "Receipt" | undefined;
        id: string;
        receiptNumber: any;
        timestamp: any;
        sender: string;
        payer?: string | null | undefined;
        lockAddress: string;
        tokenAddress: string;
        gasTotal: any;
        amountTransferred: any;
    }[]>;
    /** Get a single receipt for a specific network */
    receipt(variables: Omit<AllReceiptsQueryVariables, 'first'>, options: {
        network: number;
    }): Promise<{
        network: number;
        __typename?: "Receipt" | undefined;
        id: string;
        receiptNumber: any;
        timestamp: any;
        sender: string;
        payer?: string | null | undefined;
        lockAddress: string;
        tokenAddress: string;
        gasTotal: any;
        amountTransferred: any;
    }>;
}

declare const TransferWithAuthorizationTypes: {
    TransferWithAuthorization: {
        name: string;
        type: string;
    }[];
};
declare function getErc20BalanceForAddress(erc20ContractAddress: string, address: string, provider: ethers.providers.Provider): Promise<string>;
/**
 * Yiels the decimals for en ERC20 contract
 * @param {*} erc20ContractAddress
 * @param {*} provider
 */
declare function getErc20Decimals(erc20ContractAddress: string, provider: ethers.providers.Provider): Promise<number>;
/**
 * yields the symbole for the ERC20 contract
 * @param {*} erc20ContractAddress
 * @param {*} provider
 */
declare function getErc20TokenSymbol(erc20ContractAddress: string, provider: ethers.providers.Provider): Promise<any>;
/**
 * Yields the amount that a purchaser have approved a lock for
 * @param {*} erc20ContractAddress
 * @param {*} purchaser
 * @param {*} lockContractAddress
 * @param {*} provider
 */
declare function getAllowance(erc20ContractAddress: string, lockContractAddress: string, provider: ethers.providers.Provider, spenderAddress: string): Promise<ethers.BigNumber>;
declare function approveTransfer(erc20ContractAddress: string, lockContractAddress: string, value: unknown, provider: ethers.providers.Provider, signer: ethers.Signer): Promise<any>;
interface TransferAuthorizationMessage {
    from: string;
    to: string;
    value: any;
    validAfter: number;
    validBefore: number;
    nonce: string;
}
declare function signTransferAuthorization(erc20ContractAddress: string, message: TransferAuthorizationMessage, provider: ethers.providers.Provider, signer: ethers.Signer): Promise<any>;
declare function recoverTransferAuthorization(erc20ContractAddress: string, message: TransferAuthorizationMessage, chainId: number, signature: string, provider: any): Promise<string>;
declare function transferWithAuthorization(erc20ContractAddress: string, message: TransferAuthorizationMessage, signature: string, signer: ethers.Signer): Promise<any>;

declare const KeyManagerAbi: string[];
interface TransferObject {
    lock: string;
    token: string;
    owner: string;
    deadline: number;
}
type Signer = ethers.Signer | ethers.providers.JsonRpcSigner;
interface CreateTransferSignatureOptions {
    signer: Signer;
    params: TransferObject;
    network: number;
}
interface TransferOptions {
    params: TransferObject & {
        transferSignature: string;
    };
    network: number;
    signer: Signer;
}
interface CreateTransferAddressKey {
    params: {
        email: string;
        lockAddress: string;
    };
}
interface SetLocksmithOptions {
    params: {
        locksmith: string;
    };
    network: number;
    signer: Signer;
}
declare const TransferTypes: {
    Transfer: {
        name: string;
        type: string;
    }[];
};
interface GetContractOptions {
    network: number;
    signer?: Signer;
}
declare class KeyManager {
    networks: NetworkConfigs;
    constructor(networks?: NetworkConfigs);
    isSigner(network: number, signer: string): any;
    providerForNetwork(network: number): ethers.providers.JsonRpcBatchProvider;
    getDomain(network: number): {
        name: string;
        version: string;
        chainId: number;
        verifyingContract: string | undefined;
    };
    /**
     * This function returns the KeyManager contract for a given network.
     */
    getContract({ network, signer }: GetContractOptions): ethers.Contract;
    /**
     * This function creates a transfer signature.
     */
    createTransferSignature({ params, signer, network, }: CreateTransferSignatureOptions): Promise<any>;
    /**
     * This function transfers a key given a transfer signature.
     */
    transfer({ network, params: { lock, token, owner, deadline, transferSignature }, signer, }: TransferOptions): Promise<any>;
    /**
     * This function checks if a transfer is possible.
     */
    isTransferPossible({ network, params: { lock, token, owner, deadline, transferSignature }, signer, }: TransferOptions): Promise<any>;
    /**
     * This function creates a wallet address from a lock address and an email address.
     */
    createTransferAddress({ params }: CreateTransferAddressKey): string;
    /**
     * Return signer for the transfer signature provided in the params
     */
    getSignerForTransferSignature({ params: { lock, token, owner, deadline, transferSignature }, network, }: Omit<TransferOptions, 'signer'>): string;
}

export { Application, ApplicationBody, Applications200Response, Auth, AuthResult, Balance200ResponseValue, CaptureOnRampSession200Response, CapturePurchaseRequest, CapturePurchaseRequestPurchaseTypeEnum, CheckClaim200Response, CheckClaimRequest, CheckoutConfig, Claim200Response, ClaimRequest, Configuration, ConfigurationParameters, ConnectStripeAccount200Response, ConnectStripeAccountRequest, CreateLockContract201Response, CreateOnRampSessionRequest, CreateOnRampSessionRequestPurchaseMessage, CreateOnRampSessionRequestTransferMessage, CreateTransferAddressKey, CreateTransferCode200Response, CreateTransferCode404Response, CreateTransferSignatureOptions, DefaultApi, DefaultApiAxiosParamCreator, DefaultApiFactory, DefaultApiFp, DeleteCheckoutConfig200Response, EmailTicket200Response, EventDetails, GenericInvalidBodyError, GenericNotFound, GenericServerError, GenericSuccess, GetChargesForLock200Response, GetChargesForLock200ResponsePricesInner, GetContractOptions, GetCustomEmailContent200Response, GetDataForRecipientsAndGuild200Response, GetLockStripeConnectionDetails200Response, GetLockStripeConnectionDetails200ResponseAccount, GetLockStripeConnectionDetails200ResponseAccountRequirements, GetLockStripeConnectionDetails200ResponseCountrySpec, GetReceipt200Response, GetReceipt200ResponsePurchaser, GetReceipt200ResponseReceipt, GetReceipt200ResponseSupplier, GetReceipts200Response, GetReceipts200ResponseItemsInner, GetReceiptsBase200Response, GetStripeConnections200Response, GetSubscription200Response, GetSubscription200ResponseSubscriptionsInner, GetSubscription200ResponseSubscriptionsInnerBalance, GetSubscription200ResponseSubscriptionsInnerTypeEnum, GetTicket200Response, GetTicket200ResponseAttributesInner, GetTotalPrice200Response, IsCardPaymentEnabledForLock200Response, Key_Filter as KeyFilter, KeyManager, KeyManagerAbi, KeyMetadata, KeyMetadata200Response, Key_OrderBy as KeyOrderBy, ListCheckoutConfigs200Response, ListPaymentMethods200Response, LockContractOptions, Lock_Filter as LockFilter, Lock_OrderBy as LockOrderBy, LockSettings, LocksmithService, Configuration as LocksmithServiceConfiguration, LoginRequest, NotAuthenticated, OrderDirection, PaymentMethod, PaymentMethodBillingDetails, PaymentMethodBillingDetailsAddress, PaymentMethodCard, PaymentMethodCardChecks, PaymentMethodCardNetworks, PaymentMethodCardThreeDSecureUsage, Price200Response, Price200ResponseResult, Purchase200Response, Purchase200ResponsePricing, PurchaseRequest, RemovePaymentMethods200Response, SaveEventDataRequest, SaveLockSetting200Response, SaveReceipt200Response, SendCustomEmail200Response, SendCustomEmailRequest, SetLocksmithOptions, SetupPayment200Response, SignTicket200Response, Key as SubgraphKey, Lock as SubgraphLock, SubgraphService, TicketVerificationUrl200Response, TransferDoneRequest, TransferObject, TransferOptions, TransferTypes, TransferWithAuthorizationTypes, UpdateCheckoutConfigRequest, UpdateLockMetadataRequest, UpdateUserMetadataRequest, UpdateUsersMetadata201Response, UpdateUsersMetadataRequest, UploadImages201Response, UploadImages201ResponseResultsInner, UploadImages201ResponseResultsInnerMetadata, UserMetadata, UserMetadataInput, Verifier, Verifier200Response, Verifiers200Response, WalletService, Web3Service, approveTransfer, getAllowance, getCurrentProvider, getErc20BalanceForAddress, getErc20Decimals, getErc20TokenSymbol, getWeb3Provider, recoverTransferAuthorization, signTransferAuthorization, transferWithAuthorization };
