// src/web3Service.ts
import { ethers as ethers9 } from "ethers";

// src/utils.ts
import { ethers } from "ethers";
var utils_default = {
  toWei: (value, units) => ethers.utils.parseUnits(value, units),
  // This converts a string representation from a value to a number of units, based on the number of decimals passed in
  toDecimal: (value, decimals) => ethers.utils.parseUnits(value, decimals),
  hexlify: ethers.utils.hexlify,
  hexStripZeros: ethers.utils.hexStripZeros,
  bigNumberify: ethers.BigNumber.from,
  hexToNumberString: (num) => ethers.utils.formatUnits(ethers.BigNumber.from(num), "wei").replace(".0", ""),
  toChecksumAddress: ethers.utils.getAddress,
  fromWei: (num, units) => {
    return ethers.utils.formatUnits(ethers.BigNumber.from(num), units).replace(/\.0$/, "");
  },
  // This converts a string representation from a unit value to a higher base
  fromDecimal: (num, decimals) => {
    return ethers.utils.formatUnits(ethers.BigNumber.from(num), decimals).replace(/\.0$/, "");
  },
  isInfiniteKeys: (value) => {
    return ethers.BigNumber.from(value).eq(ethers.constants.MaxUint256);
  },
  isInfiniteDuration: (value) => {
    return ethers.BigNumber.from(value).eq(ethers.constants.MaxUint256);
  },
  toNumber: (value) => {
    return ethers.BigNumber.from(value).toNumber();
  },
  toRpcResultNumber: (value) => {
    const num = ethers.utils.hexlify(ethers.BigNumber.from(value));
    return ethers.utils.hexZeroPad(num, 32);
  },
  toRpcResultString: (str) => {
    return str;
  },
  utf8ToHex: (str) => ethers.utils.hexlify(str.length ? ethers.utils.toUtf8Bytes(str) : 0),
  sha3: ethers.utils.keccak256,
  verifyMessage: ethers.utils.verifyMessage,
  currencyAmountToBigNumber: (amount) => {
    const { decimals } = amount.currency;
    const fixed = ethers.FixedNumber.from(amount.toExact());
    const tokenScale = ethers.FixedNumber.from(
      ethers.BigNumber.from(10).pow(decimals)
    );
    return ethers.BigNumber.from(
      // have to remove trailing .0 "manually" :/
      fixed.mulUnsafe(tokenScale).floor().toString().split(".")[0]
    );
  }
};

// src/unlockService.ts
import { ethers as ethers8 } from "ethers";

// src/abis.ts
var abis = {
  "PublicLock": {
    "v4": {
      "contractName": "PublicLock",
      "abi": [
        "function supportsInterface(bytes4 interfaceId) constant view returns (bool)",
        "function owners(uint256) constant view returns (address)",
        "function name() constant view returns (string)",
        "function getApproved(uint256 _tokenId) constant view returns (address)",
        "function approve(address _approved,uint256 _tokenId) payable",
        "function updateBeneficiary(address _beneficiary)",
        "function refundPenaltyDenominator() constant view returns (uint256)",
        "function refundPenaltyNumerator() constant view returns (uint256)",
        "function unlockProtocol() constant view returns (address)",
        "function getOwnersByPage(uint256 _page,uint256 _pageSize) constant view returns (address[])",
        "function keyPrice() constant view returns (uint256)",
        "function expirationDuration() constant view returns (uint256)",
        "function onERC721Received(address,address,uint256,bytes) returns (bytes4)",
        "function totalSupply() constant view returns (uint256)",
        "function updateKeyPrice(uint256 _keyPrice)",
        "function cancelAndRefund()",
        "function transferFrom(address _from,address _recipient,uint256 _tokenId) payable",
        "function withdraw(uint256 _amount)",
        "function setBaseTokenURI(string _baseTokenURI)",
        "function beneficiary() constant view returns (address)",
        "function updateRefundPenalty(uint256 _refundPenaltyNumerator,uint256 _refundPenaltyDenominator)",
        "function numberOfKeysSold() constant view returns (uint256)",
        "function updateTransferFee(uint256 _transferFeeNumerator,uint256 _transferFeeDenominator)",
        "function isAlive() constant view returns (bool)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId) payable",
        "function strConcat(string _a,string _b,string _c,string _d) constant pure returns (string _concatenatedString)",
        "function keyOwnerToNonce(address) constant view returns (uint256)",
        "function uint2Str(uint256 _i) constant pure returns (string _uintAsString)",
        "function getCancelAndRefundValueFor(address _owner) constant view returns (uint256 refund)",
        "function updateLockName(string _lockName)",
        "function address2Str(address _addr) constant pure returns (string)",
        "function incrementNonce()",
        "function ownerOf(uint256 _tokenId) constant view returns (address)",
        "function getHasValidKey(address _owner) constant view returns (bool)",
        "function balanceOf(address _owner) constant view returns (uint256)",
        "function purchaseForFrom(address _recipient,address _referrer) payable",
        "function renounceOwnership()",
        "function maxNumberOfKeys() constant view returns (uint256)",
        "function updateLockSymbol(string _lockSymbol)",
        "function grantKeys(address[] _recipients,uint256[] _expirationTimestamps)",
        "function getTransferFee(address _owner) constant view returns (uint256)",
        "function getCancelAndRefundApprovalHash(address _keyOwner,address _txSender) constant view returns (bytes32 approvalHash)",
        "function owner() constant view returns (address)",
        "function isOwner() constant view returns (bool)",
        "function transferFeeNumerator() constant view returns (uint256)",
        "function numberOfOwners() constant view returns (uint256)",
        "function symbol() constant view returns (string)",
        "function getTokenIdFor(address _account) constant view returns (uint256)",
        "function isKeyOwner(uint256 _tokenId,address _owner) constant view returns (bool)",
        "function grantKey(address _recipient,uint256 _expirationTimestamp)",
        "function tokenAddress() constant view returns (address)",
        "function expireKeyFor(address _owner)",
        "function setApprovalForAll(address _to,bool _approved)",
        "function destroyLock()",
        "function keyExpirationTimestampFor(address _owner) constant view returns (uint256 timestamp)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId,bytes _data) payable",
        "function cancelAndRefundFor(address _keyOwner,bytes _signature)",
        "function disableLock()",
        "function initialize(address sender)",
        "function tokenURI(uint256 _tokenId) constant view returns (string)",
        "function transferFeeDenominator() constant view returns (uint256)",
        "function isApprovedForAll(address _owner,address _operator) constant view returns (bool)",
        "function transferOwnership(address newOwner)",
        "function purchaseFor(address _recipient) payable",
        "function getBalance(address _account) constant view returns (uint256)",
        "function grantKeys(address[] _recipients,uint256 _expirationTimestamp)",
        "event CancelKey (uint256 indexed tokenId,address indexed owner,address indexed sendTo,uint256 refund)",
        "event RefundPenaltyChanged (uint256 oldRefundPenaltyNumerator,uint256 oldRefundPenaltyDenominator,uint256 refundPenaltyNumerator,uint256 refundPenaltyDenominator)",
        "event TransferFeeChanged (uint256 oldTransferFeeNumerator,uint256 oldTransferFeeDenominator,uint256 transferFeeNumerator,uint256 transferFeeDenominator)",
        "event NewLockSymbol (string symbol)",
        "event ExpireKey (uint256 tokenId)",
        "event PriceChanged (uint256 oldKeyPrice,uint256 keyPrice)",
        "event Withdrawal (address indexed sender,address indexed beneficiary,uint256 amount)",
        "event Destroy (uint256 balance,address indexed owner)",
        "event Disable ()",
        "event OwnershipTransferred (address indexed previousOwner,address indexed newOwner)",
        "event Transfer (address indexed _from,address indexed _to,uint256 indexed _tokenId)",
        "event Approval (address indexed _owner,address indexed _approved,uint256 indexed _tokenId)",
        "event ApprovalForAll (address indexed _owner,address indexed _operator,bool _approved)",
        "function publicLockVersion() constant pure returns (uint16)"
      ],
      "bytecodeHash": "0x0d7ea1df12ab87024edd7add411416ee61a3f09cf41a0b6aa5499e1bc4277651"
    },
    "v6": {
      "contractName": "PublicLock",
      "abi": [
        "event Approval (address indexed owner,address indexed approved,uint256 indexed tokenId)",
        "event ApprovalForAll (address indexed owner,address indexed operator,bool approved)",
        "event CancelKey (uint256 indexed tokenId,address indexed owner,address indexed sendTo,uint256 refund)",
        "event Destroy (uint256 balance,address indexed owner)",
        "event Disable ()",
        "event ExpireKey (uint256 indexed tokenId)",
        "event LockManagerAdded (address indexed account)",
        "event LockManagerRemoved (address indexed account)",
        "event NewLockSymbol (string symbol)",
        "event NonceChanged (address indexed keyOwner,uint256 nextAvailableNonce)",
        "event OwnershipTransferred (address indexed previousOwner,address indexed newOwner)",
        "event PricingChanged (uint256 oldKeyPrice,uint256 keyPrice,address oldTokenAddress,address tokenAddress)",
        "event RefundPenaltyChanged (uint256 freeTrialLength,uint256 refundPenaltyBasisPoints)",
        "event TimestampChanged (uint256 indexed _tokenId,uint256 _amount,bool _timeAdded)",
        "event Transfer (address indexed from,address indexed to,uint256 indexed tokenId)",
        "event TransferFeeChanged (uint256 transferFeeBasisPoints)",
        "event Withdrawal (address indexed sender,address indexed tokenAddress,address indexed beneficiary,uint256 amount)",
        "function BASIS_POINTS_DEN() constant view returns (uint256)",
        "function CANCEL_TYPEHASH() constant view returns (bytes32)",
        "function addLockManager(address account)",
        "function approve(address _approved,uint256 _tokenId)",
        "function balanceOf(address _owner) constant view returns (uint256)",
        "function beneficiary() constant view returns (address)",
        "function cancelAndRefund()",
        "function cancelAndRefundFor(address _keyOwner,uint8 _v,bytes32 _r,bytes32 _s)",
        "function destroyLock()",
        "function disableLock()",
        "function erc1820() constant view returns (address)",
        "function expirationDuration() constant view returns (uint256)",
        "function expireKeyFor(address _owner)",
        "function freeTrialLength() constant view returns (uint256)",
        "function fullRefund(address _keyOwner,uint256 amount)",
        "function getApproved(uint256 _tokenId) constant view returns (address)",
        "function getBalance(address _tokenAddress,address _account) constant view returns (uint256)",
        "function getCancelAndRefundApprovalHash(address _keyOwner,address _txSender) constant view returns (bytes32 approvalHash)",
        "function getCancelAndRefundValueFor(address _owner) constant view returns (uint256 refund)",
        "function getHasValidKey(address _owner) constant view returns (bool)",
        "function getOwnersByPage(uint256 _page,uint256 _pageSize) constant view returns (address[])",
        "function getTokenIdFor(address _account) constant view returns (uint256)",
        "function getTransferFee(address _owner,uint256 _time) constant view returns (uint256)",
        "function grantKeys(address[] _recipients,uint256[] _expirationTimestamps)",
        "function invalidateOffchainApproval(uint256 _nextAvailableNonce)",
        "function isAlive() constant view returns (bool)",
        "function isApprovedForAll(address _owner,address _operator) constant view returns (bool)",
        "function isKeyOwner(uint256 _tokenId,address _owner) constant view returns (bool)",
        "function isLockManager(address account) constant view returns (bool)",
        "function isOwner() constant view returns (bool)",
        "function keyCancelInterfaceId() constant view returns (bytes32)",
        "function keyExpirationTimestampFor(address _owner) constant view returns (uint256 timestamp)",
        "function keyOwnerToNonce(address) constant view returns (uint256)",
        "function keyPrice() constant view returns (uint256)",
        "function keySoldInterfaceId() constant view returns (bytes32)",
        "function maxNumberOfKeys() constant view returns (uint256)",
        "function name() constant view returns (string)",
        "function numberOfOwners() constant view returns (uint256)",
        "function owner() constant view returns (address)",
        "function ownerOf(uint256 _tokenId) constant view returns (address)",
        "function owners(uint256) constant view returns (address)",
        "function publicLockVersion() constant pure returns (uint256)",
        "function purchase(uint256 _value,address _recipient,address _referrer,bytes _data) payable",
        "function refundPenaltyBasisPoints() constant view returns (uint256)",
        "function renounceLockManager()",
        "function renounceOwnership()",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId,bytes _data)",
        "function setApprovalForAll(address _to,bool _approved)",
        "function setBaseTokenURI(string _baseTokenURI)",
        "function shareKey(address _to,uint256 _tokenId,uint256 _timeShared)",
        "function supportsInterface(bytes4 interfaceId) constant view returns (bool)",
        "function symbol() constant view returns (string)",
        "function tokenAddress() constant view returns (address)",
        "function tokenByIndex(uint256 _index) constant view returns (uint256)",
        "function tokenOfOwnerByIndex(address _owner,uint256 _index) constant view returns (uint256)",
        "function tokenURI(uint256 _tokenId) constant view returns (string)",
        "function totalSupply() constant view returns (uint256)",
        "function transferFeeBasisPoints() constant view returns (uint256)",
        "function transferFrom(address _from,address _recipient,uint256 _tokenId)",
        "function transferOwnership(address newOwner)",
        "function unlockProtocol() constant view returns (address)",
        "function updateBeneficiary(address _beneficiary)",
        "function updateKeyPricing(uint256 _keyPrice,address _tokenAddress)",
        "function updateLockName(string _lockName)",
        "function updateLockSymbol(string _lockSymbol)",
        "function updateRefundPenalty(uint256 _freeTrialLength,uint256 _refundPenaltyBasisPoints)",
        "function updateTransferFee(uint256 _transferFeeBasisPoints)",
        "function withdraw(address _tokenAddress,uint256 _amount)",
        "function initialize(address _owner,uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName)",
        "function initialize()",
        "function initialize(address sender)"
      ],
      "bytecodeHash": "0x39260d0911736892b9a71a2c6b5fc69a98c58d297f8c4ca0bd7ee96c54244c69"
    },
    "v7": {
      "contractName": "PublicLock",
      "abi": [
        "event Approval (address indexed owner,address indexed approved,uint256 indexed tokenId)",
        "event ApprovalForAll (address indexed owner,address indexed operator,bool approved)",
        "event CancelKey (uint256 indexed tokenId,address indexed owner,address indexed sendTo,uint256 refund)",
        "event Disable ()",
        "event ExpirationChanged (uint256 indexed _tokenId,uint256 _amount,bool _timeAdded)",
        "event ExpireKey (uint256 indexed tokenId)",
        "event KeyGranterAdded (address indexed account)",
        "event KeyGranterRemoved (address indexed account)",
        "event KeyManagerChanged (uint256 indexed _tokenId,address indexed _newManager)",
        "event LockManagerAdded (address indexed account)",
        "event LockManagerRemoved (address indexed account)",
        "event NewLockSymbol (string symbol)",
        "event NonceChanged (address indexed keyManager,uint256 nextAvailableNonce)",
        "event PricingChanged (uint256 oldKeyPrice,uint256 keyPrice,address oldTokenAddress,address tokenAddress)",
        "event RefundPenaltyChanged (uint256 freeTrialLength,uint256 refundPenaltyBasisPoints)",
        "event RenewKeyPurchase (address indexed owner,uint256 newExpiration)",
        "event Transfer (address indexed from,address indexed to,uint256 indexed tokenId)",
        "event TransferFeeChanged (uint256 transferFeeBasisPoints)",
        "event Withdrawal (address indexed sender,address indexed tokenAddress,address indexed beneficiary,uint256 amount)",
        "function addKeyGranter(address account)",
        "function addLockManager(address account)",
        "function approve(address _approved,uint256 _tokenId)",
        "function balanceOf(address _keyOwner) constant view returns (uint256)",
        "function beneficiary() constant view returns (address)",
        "function cancelAndRefund(uint256 _tokenId)",
        "function cancelAndRefundFor(address _keyManager,uint8 _v,bytes32 _r,bytes32 _s,uint256 _tokenId)",
        "function disableLock()",
        "function expirationDuration() constant view returns (uint256)",
        "function expireAndRefundFor(address _keyOwner,uint256 amount)",
        "function freeTrialLength() constant view returns (uint256)",
        "function getApproved(uint256 _tokenId) constant view returns (address)",
        "function getBalance(address _tokenAddress,address _account) constant view returns (uint256)",
        "function getCancelAndRefundApprovalHash(address _keyManager,address _txSender) constant view returns (bytes32 approvalHash)",
        "function getCancelAndRefundValueFor(address _keyOwner) constant view returns (uint256 refund)",
        "function getHasValidKey(address _keyOwner) constant view returns (bool)",
        "function getOwnersByPage(uint256 _page,uint256 _pageSize) constant view returns (address[])",
        "function getTokenIdFor(address _account) constant view returns (uint256)",
        "function getTransferFee(address _keyOwner,uint256 _time) constant view returns (uint256)",
        "function grantKeys(address[] _recipients,uint256[] _expirationTimestamps,address[] _keyManagers)",
        "function invalidateOffchainApproval(uint256 _nextAvailableNonce)",
        "function isAlive() constant view returns (bool)",
        "function isApprovedForAll(address _owner,address _operator) constant view returns (bool)",
        "function isKeyGranter(address account) constant view returns (bool)",
        "function isKeyOwner(uint256 _tokenId,address _keyOwner) constant view returns (bool)",
        "function isLockManager(address account) constant view returns (bool)",
        "function keyExpirationTimestampFor(address _keyOwner) constant view returns (uint256)",
        "function keyManagerOf(uint256) constant view returns (address)",
        "function keyManagerToNonce(address) constant view returns (uint256)",
        "function keyPrice() constant view returns (uint256)",
        "function maxNumberOfKeys() constant view returns (uint256)",
        "function name() constant view returns (string)",
        "function numberOfOwners() constant view returns (uint256)",
        "function onKeyCancelHook() constant view returns (address)",
        "function onKeyPurchaseHook() constant view returns (address)",
        "function ownerOf(uint256 _tokenId) constant view returns (address)",
        "function owners(uint256) constant view returns (address)",
        "function publicLockVersion() constant pure returns (uint256)",
        "function purchase(uint256 _value,address _recipient,address _referrer,bytes _data) payable",
        "function purchasePriceFor(address _recipient,address _referrer,bytes _data) constant view returns (uint256 minKeyPrice)",
        "function refundPenaltyBasisPoints() constant view returns (uint256)",
        "function renounceLockManager()",
        "function revokeKeyGranter(address _granter)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId,bytes _data)",
        "function setApprovalForAll(address _to,bool _approved)",
        "function setBaseTokenURI(string _baseTokenURI)",
        "function setEventHooks(address _onKeyPurchaseHook,address _onKeyCancelHook)",
        "function setKeyManagerOf(uint256 _tokenId,address _keyManager)",
        "function shareKey(address _to,uint256 _tokenId,uint256 _timeShared)",
        "function supportsInterface(bytes4 interfaceId) constant view returns (bool)",
        "function symbol() constant view returns (string)",
        "function tokenAddress() constant view returns (address)",
        "function tokenByIndex(uint256 _index) constant view returns (uint256)",
        "function tokenOfOwnerByIndex(address _keyOwner,uint256 _index) constant view returns (uint256)",
        "function tokenURI(uint256 _tokenId) constant view returns (string)",
        "function totalSupply() constant view returns (uint256)",
        "function transferFeeBasisPoints() constant view returns (uint256)",
        "function transferFrom(address _from,address _recipient,uint256 _tokenId)",
        "function unlockProtocol() constant view returns (address)",
        "function updateBeneficiary(address _beneficiary)",
        "function updateKeyPricing(uint256 _keyPrice,address _tokenAddress)",
        "function updateLockName(string _lockName)",
        "function updateLockSymbol(string _lockSymbol)",
        "function updateRefundPenalty(uint256 _freeTrialLength,uint256 _refundPenaltyBasisPoints)",
        "function updateTransferFee(uint256 _transferFeeBasisPoints)",
        "function withdraw(address _tokenAddress,uint256 _amount)",
        "function initialize(address _lockCreator,uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName)",
        "function initialize()"
      ],
      "bytecodeHash": "0xd66a672853995b93eff7fc1ea6eb09bac55fb58da34a8132703844b6b0837c32"
    },
    "v8": {
      "contractName": "PublicLock",
      "abi": [
        "event Approval (address indexed owner,address indexed approved,uint256 indexed tokenId)",
        "event ApprovalForAll (address indexed owner,address indexed operator,bool approved)",
        "event CancelKey (uint256 indexed tokenId,address indexed owner,address indexed sendTo,uint256 refund)",
        "event Disable ()",
        "event ExpirationChanged (uint256 indexed _tokenId,uint256 _amount,bool _timeAdded)",
        "event ExpireKey (uint256 indexed tokenId)",
        "event KeyGranterAdded (address indexed account)",
        "event KeyGranterRemoved (address indexed account)",
        "event KeyManagerChanged (uint256 indexed _tokenId,address indexed _newManager)",
        "event LockManagerAdded (address indexed account)",
        "event LockManagerRemoved (address indexed account)",
        "event NewLockSymbol (string symbol)",
        "event NonceChanged (address indexed keyManager,uint256 nextAvailableNonce)",
        "event PricingChanged (uint256 oldKeyPrice,uint256 keyPrice,address oldTokenAddress,address tokenAddress)",
        "event RefundPenaltyChanged (uint256 freeTrialLength,uint256 refundPenaltyBasisPoints)",
        "event RenewKeyPurchase (address indexed owner,uint256 newExpiration)",
        "event Transfer (address indexed from,address indexed to,uint256 indexed tokenId)",
        "event TransferFeeChanged (uint256 transferFeeBasisPoints)",
        "event Withdrawal (address indexed sender,address indexed tokenAddress,address indexed beneficiary,uint256 amount)",
        "function addKeyGranter(address account)",
        "function addLockManager(address account)",
        "function approve(address _approved,uint256 _tokenId)",
        "function approveBeneficiary(address _spender,uint256 _amount) returns (bool)",
        "function balanceOf(address _keyOwner) constant view returns (uint256)",
        "function beneficiary() constant view returns (address)",
        "function cancelAndRefund(uint256 _tokenId)",
        "function cancelAndRefundFor(address _keyManager,uint8 _v,bytes32 _r,bytes32 _s,uint256 _tokenId)",
        "function disableLock()",
        "function expirationDuration() constant view returns (uint256)",
        "function expireAndRefundFor(address _keyOwner,uint256 amount)",
        "function freeTrialLength() constant view returns (uint256)",
        "function getApproved(uint256 _tokenId) constant view returns (address)",
        "function getBalance(address _tokenAddress,address _account) constant view returns (uint256)",
        "function getCancelAndRefundApprovalHash(address _keyManager,address _txSender) constant view returns (bytes32 approvalHash)",
        "function getCancelAndRefundValueFor(address _keyOwner) constant view returns (uint256 refund)",
        "function getHasValidKey(address _keyOwner) constant view returns (bool)",
        "function getOwnersByPage(uint256 _page,uint256 _pageSize) constant view returns (address[])",
        "function getTokenIdFor(address _account) constant view returns (uint256)",
        "function getTransferFee(address _keyOwner,uint256 _time) constant view returns (uint256)",
        "function grantKeys(address[] _recipients,uint256[] _expirationTimestamps,address[] _keyManagers)",
        "function invalidateOffchainApproval(uint256 _nextAvailableNonce)",
        "function isAlive() constant view returns (bool)",
        "function isApprovedForAll(address _owner,address _operator) constant view returns (bool)",
        "function isKeyGranter(address account) constant view returns (bool)",
        "function isKeyOwner(uint256 _tokenId,address _keyOwner) constant view returns (bool)",
        "function isLockManager(address account) constant view returns (bool)",
        "function keyExpirationTimestampFor(address _keyOwner) constant view returns (uint256)",
        "function keyManagerOf(uint256) constant view returns (address)",
        "function keyManagerToNonce(address) constant view returns (uint256)",
        "function keyPrice() constant view returns (uint256)",
        "function maxNumberOfKeys() constant view returns (uint256)",
        "function name() constant view returns (string)",
        "function numberOfOwners() constant view returns (uint256)",
        "function onKeyCancelHook() constant view returns (address)",
        "function onKeyPurchaseHook() constant view returns (address)",
        "function ownerOf(uint256 _tokenId) constant view returns (address)",
        "function owners(uint256) constant view returns (address)",
        "function publicLockVersion() constant pure returns (uint256)",
        "function purchase(uint256 _value,address _recipient,address _referrer,bytes _data) payable",
        "function purchasePriceFor(address _recipient,address _referrer,bytes _data) constant view returns (uint256 minKeyPrice)",
        "function refundPenaltyBasisPoints() constant view returns (uint256)",
        "function renounceLockManager()",
        "function revokeKeyGranter(address _granter)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId,bytes _data)",
        "function setApprovalForAll(address _to,bool _approved)",
        "function setBaseTokenURI(string _baseTokenURI)",
        "function setEventHooks(address _onKeyPurchaseHook,address _onKeyCancelHook)",
        "function setKeyManagerOf(uint256 _tokenId,address _keyManager)",
        "function shareKey(address _to,uint256 _tokenId,uint256 _timeShared)",
        "function supportsInterface(bytes4 interfaceId) constant view returns (bool)",
        "function symbol() constant view returns (string)",
        "function tokenAddress() constant view returns (address)",
        "function tokenByIndex(uint256 _index) constant view returns (uint256)",
        "function tokenOfOwnerByIndex(address _keyOwner,uint256 _index) constant view returns (uint256)",
        "function tokenURI(uint256 _tokenId) constant view returns (string)",
        "function totalSupply() constant view returns (uint256)",
        "function transfer(address _to,uint256 _value) returns (bool success)",
        "function transferFeeBasisPoints() constant view returns (uint256)",
        "function transferFrom(address _from,address _recipient,uint256 _tokenId)",
        "function unlockProtocol() constant view returns (address)",
        "function updateBeneficiary(address _beneficiary)",
        "function updateKeyPricing(uint256 _keyPrice,address _tokenAddress)",
        "function updateLockName(string _lockName)",
        "function updateLockSymbol(string _lockSymbol)",
        "function updateRefundPenalty(uint256 _freeTrialLength,uint256 _refundPenaltyBasisPoints)",
        "function updateTransferFee(uint256 _transferFeeBasisPoints)",
        "function withdraw(address _tokenAddress,uint256 _amount)",
        "function initialize(address _lockCreator,uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName)",
        "function initialize()"
      ],
      "bytecodeHash": "0x04782fb9f4650646c8db40744d69e4bf68845d1e7164884afb6ba95eb04e1a41"
    },
    "v9": {
      "contractName": "PublicLock",
      "abi": [
        "event Approval (address indexed owner,address indexed approved,uint256 indexed tokenId)",
        "event ApprovalForAll (address indexed owner,address indexed operator,bool approved)",
        "event CancelKey (uint256 indexed tokenId,address indexed owner,address indexed sendTo,uint256 refund)",
        "event Disable ()",
        "event ExpirationChanged (uint256 indexed _tokenId,uint256 _amount,bool _timeAdded)",
        "event ExpireKey (uint256 indexed tokenId)",
        "event GasRefunded (address indexed receiver,uint256 refundedAmount,address tokenAddress)",
        "event KeyGranterAdded (address indexed account)",
        "event KeyGranterRemoved (address indexed account)",
        "event KeyManagerChanged (uint256 indexed _tokenId,address indexed _newManager)",
        "event LockManagerAdded (address indexed account)",
        "event LockManagerRemoved (address indexed account)",
        "event NewLockSymbol (string symbol)",
        "event PricingChanged (uint256 oldKeyPrice,uint256 keyPrice,address oldTokenAddress,address tokenAddress)",
        "event RefundPenaltyChanged (uint256 freeTrialLength,uint256 refundPenaltyBasisPoints)",
        "event RenewKeyPurchase (address indexed owner,uint256 newExpiration)",
        "event RoleAdminChanged (bytes32 indexed role,bytes32 indexed previousAdminRole,bytes32 indexed newAdminRole)",
        "event RoleGranted (bytes32 indexed role,address indexed account,address indexed sender)",
        "event RoleRevoked (bytes32 indexed role,address indexed account,address indexed sender)",
        "event Transfer (address indexed from,address indexed to,uint256 indexed tokenId)",
        "event TransferFeeChanged (uint256 transferFeeBasisPoints)",
        "event UnlockCallFailed (address indexed lockAddress,address unlockAddress)",
        "event Withdrawal (address indexed sender,address indexed tokenAddress,address indexed beneficiary,uint256 amount)",
        "function DEFAULT_ADMIN_ROLE() view returns (bytes32)",
        "function KEY_GRANTER_ROLE() view returns (bytes32)",
        "function LOCK_MANAGER_ROLE() view returns (bytes32)",
        "function addKeyGranter(address account)",
        "function addLockManager(address account)",
        "function approve(address _approved,uint256 _tokenId)",
        "function approveBeneficiary(address _spender,uint256 _amount) returns (bool)",
        "function balanceOf(address _keyOwner) view returns (uint256)",
        "function beneficiary() view returns (address)",
        "function cancelAndRefund(uint256 _tokenId)",
        "function disableLock()",
        "function expirationDuration() view returns (uint256)",
        "function expireAndRefundFor(address _keyOwner,uint256 amount)",
        "function freeTrialLength() view returns (uint256)",
        "function gasRefundValue() view returns (uint256 _refundValue)",
        "function getApproved(uint256 _tokenId) view returns (address)",
        "function getCancelAndRefundValueFor(address _keyOwner) view returns (uint256 refund)",
        "function getHasValidKey(address _keyOwner) view returns (bool isValid)",
        "function getRoleAdmin(bytes32 role) view returns (bytes32)",
        "function getTokenIdFor(address _account) view returns (uint256)",
        "function getTransferFee(address _keyOwner,uint256 _time) view returns (uint256)",
        "function grantKeys(address[] _recipients,uint256[] _expirationTimestamps,address[] _keyManagers)",
        "function grantRole(bytes32 role,address account)",
        "function hasRole(bytes32 role,address account) view returns (bool)",
        "function initialize(address _lockCreator,uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName)",
        "function isAlive() view returns (bool)",
        "function isApprovedForAll(address _owner,address _operator) view returns (bool)",
        "function isKeyGranter(address account) view returns (bool)",
        "function isLockManager(address account) view returns (bool)",
        "function keyExpirationTimestampFor(address _keyOwner) view returns (uint256)",
        "function keyManagerOf(uint256) view returns (address)",
        "function keyPrice() view returns (uint256)",
        "function maxNumberOfKeys() view returns (uint256)",
        "function name() view returns (string)",
        "function numberOfOwners() view returns (uint256)",
        "function onKeyCancelHook() view returns (address)",
        "function onKeyPurchaseHook() view returns (address)",
        "function onTokenURIHook() view returns (address)",
        "function onValidKeyHook() view returns (address)",
        "function ownerOf(uint256 _tokenId) view returns (address)",
        "function publicLockVersion() pure returns (uint16)",
        "function purchase(uint256 _value,address _recipient,address _referrer,address _keyManager,bytes _data) payable",
        "function purchasePriceFor(address _recipient,address _referrer,bytes _data) view returns (uint256 minKeyPrice)",
        "function refundPenaltyBasisPoints() view returns (uint256)",
        "function renounceLockManager()",
        "function renounceRole(bytes32 role,address account)",
        "function revokeKeyGranter(address _granter)",
        "function revokeRole(bytes32 role,address account)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId,bytes _data)",
        "function setApprovalForAll(address _to,bool _approved)",
        "function setBaseTokenURI(string _baseTokenURI)",
        "function setEventHooks(address _onKeyPurchaseHook,address _onKeyCancelHook,address _onValidKeyHook,address _onTokenURIHook)",
        "function setExpirationDuration(uint256 _newExpirationDuration)",
        "function setGasRefundValue(uint256 _refundValue)",
        "function setKeyManagerOf(uint256 _tokenId,address _keyManager)",
        "function setMaxNumberOfKeys(uint256 _maxNumberOfKeys)",
        "function shareKey(address _to,uint256 _tokenId,uint256 _timeShared)",
        "function supportsInterface(bytes4 interfaceId) view returns (bool)",
        "function symbol() view returns (string)",
        "function tokenAddress() view returns (address)",
        "function tokenByIndex(uint256 _index) view returns (uint256)",
        "function tokenOfOwnerByIndex(address _keyOwner,uint256 _index) view returns (uint256)",
        "function tokenURI(uint256 _tokenId) view returns (string)",
        "function totalSupply() view returns (uint256)",
        "function transfer(address _to,uint256 _value) returns (bool success)",
        "function transferFeeBasisPoints() view returns (uint256)",
        "function transferFrom(address _from,address _recipient,uint256 _tokenId)",
        "function unlockProtocol() view returns (address)",
        "function updateBeneficiary(address _beneficiary)",
        "function updateKeyPricing(uint256 _keyPrice,address _tokenAddress)",
        "function updateLockName(string _lockName)",
        "function updateLockSymbol(string _lockSymbol)",
        "function updateRefundPenalty(uint256 _freeTrialLength,uint256 _refundPenaltyBasisPoints)",
        "function updateTransferFee(uint256 _transferFeeBasisPoints)",
        "function withdraw(address _tokenAddress,uint256 _amount)"
      ],
      "bytecodeHash": "0x0cf7c1b77621773fd65811a23143e5e49946d2de75c18934b495940cab871397"
    },
    "v10": {
      "contractName": "PublicLock",
      "abi": [
        "event Approval (address indexed owner,address indexed approved,uint256 indexed tokenId)",
        "event ApprovalForAll (address indexed owner,address indexed operator,bool approved)",
        "event CancelKey (uint256 indexed tokenId,address indexed owner,address indexed sendTo,uint256 refund)",
        "event ExpirationChanged (uint256 indexed _tokenId,uint256 _amount,bool _timeAdded)",
        "event ExpireKey (uint256 indexed tokenId)",
        "event GasRefunded (address indexed receiver,uint256 refundedAmount,address tokenAddress)",
        "event KeyExtended (uint256 indexed tokenId,uint256 newTimestamp)",
        "event KeyGranterAdded (address indexed account)",
        "event KeyGranterRemoved (address indexed account)",
        "event KeyManagerChanged (uint256 indexed _tokenId,address indexed _newManager)",
        "event KeysMigrated (uint256 updatedRecordsCount)",
        "event LockManagerAdded (address indexed account)",
        "event LockManagerRemoved (address indexed account)",
        "event NewLockSymbol (string symbol)",
        "event OwnershipTransferred (address previousOwner,address newOwner)",
        "event PricingChanged (uint256 oldKeyPrice,uint256 keyPrice,address oldTokenAddress,address tokenAddress)",
        "event RefundPenaltyChanged (uint256 freeTrialLength,uint256 refundPenaltyBasisPoints)",
        "event RenewKeyPurchase (address indexed owner,uint256 newExpiration)",
        "event RoleAdminChanged (bytes32 indexed role,bytes32 indexed previousAdminRole,bytes32 indexed newAdminRole)",
        "event RoleGranted (bytes32 indexed role,address indexed account,address indexed sender)",
        "event RoleRevoked (bytes32 indexed role,address indexed account,address indexed sender)",
        "event Transfer (address indexed from,address indexed to,uint256 indexed tokenId)",
        "event TransferFeeChanged (uint256 transferFeeBasisPoints)",
        "event UnlockCallFailed (address indexed lockAddress,address unlockAddress)",
        "event Withdrawal (address indexed sender,address indexed tokenAddress,address indexed beneficiary,uint256 amount)",
        "function DEFAULT_ADMIN_ROLE() view returns (bytes32)",
        "function KEY_GRANTER_ROLE() view returns (bytes32)",
        "function LOCK_MANAGER_ROLE() view returns (bytes32)",
        "function addKeyGranter(address account)",
        "function addLockManager(address account)",
        "function approve(address _approved,uint256 _tokenId)",
        "function approveBeneficiary(address _spender,uint256 _amount) returns (bool)",
        "function balanceOf(address _keyOwner) view returns (uint256)",
        "function beneficiary() view returns (address)",
        "function burn(uint256 _tokenId)",
        "function cancelAndRefund(uint256 _tokenId)",
        "function expirationDuration() view returns (uint256)",
        "function expireAndRefundFor(uint256 _tokenId,uint256 _amount)",
        "function extend(uint256 _value,uint256 _tokenId,address _referrer,bytes _data) payable",
        "function freeTrialLength() view returns (uint256)",
        "function gasRefundValue() view returns (uint256 _refundValue)",
        "function getApproved(uint256 _tokenId) view returns (address)",
        "function getCancelAndRefundValue(uint256 _tokenId) view returns (uint256 refund)",
        "function getHasValidKey(address _keyOwner) view returns (bool isValid)",
        "function getRoleAdmin(bytes32 role) view returns (bytes32)",
        "function getTransferFee(uint256 _tokenId,uint256 _time) view returns (uint256)",
        "function grantKeys(address[] _recipients,uint256[] _expirationTimestamps,address[] _keyManagers)",
        "function grantRole(bytes32 role,address account)",
        "function hasRole(bytes32 role,address account) view returns (bool)",
        "function initialize(address _lockCreator,uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName)",
        "function isApprovedForAll(address _owner,address _operator) view returns (bool)",
        "function isKeyGranter(address account) view returns (bool)",
        "function isLockManager(address account) view returns (bool)",
        "function isOwner(address account) view returns (bool)",
        "function isValidKey(uint256 _tokenId) view returns (bool)",
        "function keyExpirationTimestampFor(uint256 _tokenId) view returns (uint256)",
        "function keyManagerOf(uint256) view returns (address)",
        "function keyPrice() view returns (uint256)",
        "function maxKeysPerAddress() view returns (uint256)",
        "function maxNumberOfKeys() view returns (uint256)",
        "function mergeKeys(uint256 _tokenIdFrom,uint256 _tokenIdTo,uint256 _amount)",
        "function migrate(bytes _calldata)",
        "function name() view returns (string)",
        "function numberOfOwners() view returns (uint256)",
        "function onKeyCancelHook() view returns (address)",
        "function onKeyPurchaseHook() view returns (address)",
        "function onTokenURIHook() view returns (address)",
        "function onValidKeyHook() view returns (address)",
        "function owner() view returns (address)",
        "function ownerOf(uint256 _tokenId) view returns (address)",
        "function publicLockVersion() pure returns (uint16)",
        "function purchase(uint256[] _values,address[] _recipients,address[] _referrers,address[] _keyManagers,bytes[] _data) payable",
        "function purchasePriceFor(address _recipient,address _referrer,bytes _data) view returns (uint256 minKeyPrice)",
        "function refundPenaltyBasisPoints() view returns (uint256)",
        "function renewMembershipFor(uint256 _tokenId,address _referrer)",
        "function renounceLockManager()",
        "function renounceRole(bytes32 role,address account)",
        "function revokeKeyGranter(address _granter)",
        "function revokeRole(bytes32 role,address account)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId,bytes _data)",
        "function schemaVersion() view returns (uint256)",
        "function setApprovalForAll(address _to,bool _approved)",
        "function setBaseTokenURI(string _baseTokenURI)",
        "function setEventHooks(address _onKeyPurchaseHook,address _onKeyCancelHook,address _onValidKeyHook,address _onTokenURIHook)",
        "function setExpirationDuration(uint256 _newExpirationDuration)",
        "function setGasRefundValue(uint256 _refundValue)",
        "function setKeyManagerOf(uint256 _tokenId,address _keyManager)",
        "function setMaxKeysPerAddress(uint256 _maxKeys)",
        "function setMaxNumberOfKeys(uint256 _maxNumberOfKeys)",
        "function setOwner(address account)",
        "function shareKey(address _to,uint256 _tokenIdFrom,uint256 _timeShared)",
        "function supportsInterface(bytes4 interfaceId) view returns (bool)",
        "function symbol() view returns (string)",
        "function tokenAddress() view returns (address)",
        "function tokenByIndex(uint256 _index) view returns (uint256)",
        "function tokenOfOwnerByIndex(address _keyOwner,uint256 _index) view returns (uint256)",
        "function tokenURI(uint256 _tokenId) view returns (string)",
        "function totalSupply() view returns (uint256)",
        "function transfer(uint256 _tokenId,address _to,uint256 _valueBasisPoint) returns (bool success)",
        "function transferFeeBasisPoints() view returns (uint256)",
        "function transferFrom(address _from,address _recipient,uint256 _tokenId)",
        "function unlockProtocol() view returns (address)",
        "function updateBeneficiary(address _beneficiary)",
        "function updateKeyPricing(uint256 _keyPrice,address _tokenAddress)",
        "function updateLockName(string _lockName)",
        "function updateLockSymbol(string _lockSymbol)",
        "function updateRefundPenalty(uint256 _freeTrialLength,uint256 _refundPenaltyBasisPoints)",
        "function updateSchemaVersion()",
        "function updateTransferFee(uint256 _transferFeeBasisPoints)",
        "function withdraw(address _tokenAddress,uint256 _amount)"
      ],
      "bytecodeHash": "0xab13b065214b7b56d27e5a3626bcb8ba4c691b34b8ebb01e1ab0fb93165fa40a"
    },
    "v11": {
      "contractName": "PublicLock",
      "abi": [
        "error CANNOT_APPROVE_SELF()",
        "error CANT_BE_SMALLER_THAN_SUPPLY()",
        "error CANT_EXTEND_NON_EXPIRING_KEY()",
        "error GAS_REFUND_FAILED()",
        "error INSUFFICIENT_ERC20_VALUE()",
        "error INSUFFICIENT_VALUE()",
        "error INVALID_ADDRESS()",
        "error INVALID_HOOK(uint8 hookIndex)",
        "error INVALID_LENGTH()",
        "error INVALID_TOKEN()",
        "error KEY_NOT_VALID()",
        "error KEY_TRANSFERS_DISABLED()",
        "error LOCK_HAS_CHANGED()",
        "error LOCK_SOLD_OUT()",
        "error MAX_KEYS_REACHED()",
        "error MIGRATION_REQUIRED()",
        "error NON_COMPLIANT_ERC721_RECEIVER()",
        "error NON_RENEWABLE_LOCK()",
        "error NOT_ENOUGH_FUNDS()",
        "error NOT_ENOUGH_TIME()",
        "error NOT_READY_FOR_RENEWAL()",
        "error NO_SUCH_KEY()",
        "error NULL_VALUE()",
        "error ONLY_KEY_MANAGER_OR_APPROVED()",
        "error ONLY_LOCK_MANAGER()",
        "error ONLY_LOCK_MANAGER_OR_BENEFICIARY()",
        "error ONLY_LOCK_MANAGER_OR_KEY_GRANTER()",
        "error OUT_OF_RANGE()",
        "error OWNER_CANT_BE_ADDRESS_ZERO()",
        "error SCHEMA_VERSION_NOT_CORRECT()",
        "error TRANSFER_TO_SELF()",
        "error UNAUTHORIZED()",
        "error UNAUTHORIZED_KEY_MANAGER_UPDATE()",
        "event Approval (address indexed owner,address indexed approved,uint256 indexed tokenId)",
        "event ApprovalForAll (address indexed owner,address indexed operator,bool approved)",
        "event CancelKey (uint256 indexed tokenId,address indexed owner,address indexed sendTo,uint256 refund)",
        "event ExpirationChanged (uint256 indexed _tokenId,uint256 _amount,bool _timeAdded)",
        "event ExpireKey (uint256 indexed tokenId)",
        "event GasRefunded (address indexed receiver,uint256 refundedAmount,address tokenAddress)",
        "event Initialized (uint8 version)",
        "event KeyExtended (uint256 indexed tokenId,uint256 newTimestamp)",
        "event KeyGranterAdded (address indexed account)",
        "event KeyGranterRemoved (address indexed account)",
        "event KeyManagerChanged (uint256 indexed _tokenId,address indexed _newManager)",
        "event KeysMigrated (uint256 updatedRecordsCount)",
        "event LockManagerAdded (address indexed account)",
        "event LockManagerRemoved (address indexed account)",
        "event NewLockSymbol (string symbol)",
        "event OwnershipTransferred (address previousOwner,address newOwner)",
        "event PricingChanged (uint256 oldKeyPrice,uint256 keyPrice,address oldTokenAddress,address tokenAddress)",
        "event RefundPenaltyChanged (uint256 freeTrialLength,uint256 refundPenaltyBasisPoints)",
        "event RoleAdminChanged (bytes32 indexed role,bytes32 indexed previousAdminRole,bytes32 indexed newAdminRole)",
        "event RoleGranted (bytes32 indexed role,address indexed account,address indexed sender)",
        "event RoleRevoked (bytes32 indexed role,address indexed account,address indexed sender)",
        "event Transfer (address indexed from,address indexed to,uint256 indexed tokenId)",
        "event TransferFeeChanged (uint256 transferFeeBasisPoints)",
        "event UnlockCallFailed (address indexed lockAddress,address unlockAddress)",
        "event Withdrawal (address indexed sender,address indexed tokenAddress,address indexed beneficiary,uint256 amount)",
        "function DEFAULT_ADMIN_ROLE() view returns (bytes32)",
        "function KEY_GRANTER_ROLE() view returns (bytes32)",
        "function LOCK_MANAGER_ROLE() view returns (bytes32)",
        "function addKeyGranter(address account)",
        "function addLockManager(address account)",
        "function approve(address _approved,uint256 _tokenId)",
        "function approveBeneficiary(address _spender,uint256 _amount) returns (bool)",
        "function balanceOf(address _keyOwner) view returns (uint256 balance)",
        "function beneficiary() view returns (address)",
        "function burn(uint256 _tokenId)",
        "function cancelAndRefund(uint256 _tokenId)",
        "function expirationDuration() view returns (uint256)",
        "function expireAndRefundFor(uint256 _tokenId,uint256 _amount)",
        "function extend(uint256 _value,uint256 _tokenId,address _referrer,bytes _data) payable",
        "function freeTrialLength() view returns (uint256)",
        "function gasRefundValue() view returns (uint256 _refundValue)",
        "function getApproved(uint256 _tokenId) view returns (address)",
        "function getCancelAndRefundValue(uint256 _tokenId) view returns (uint256 refund)",
        "function getHasValidKey(address _keyOwner) view returns (bool isValid)",
        "function getRoleAdmin(bytes32 role) view returns (bytes32)",
        "function getTransferFee(uint256 _tokenId,uint256 _time) view returns (uint256)",
        "function grantKeyExtension(uint256 _tokenId,uint256 _duration)",
        "function grantKeys(address[] _recipients,uint256[] _expirationTimestamps,address[] _keyManagers) returns (uint256[])",
        "function grantRole(bytes32 role,address account)",
        "function hasRole(bytes32 role,address account) view returns (bool)",
        "function initialize(address _lockCreator,uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName)",
        "function isApprovedForAll(address _owner,address _operator) view returns (bool)",
        "function isKeyGranter(address account) view returns (bool)",
        "function isLockManager(address account) view returns (bool)",
        "function isOwner(address account) view returns (bool)",
        "function isValidKey(uint256 _tokenId) view returns (bool)",
        "function keyExpirationTimestampFor(uint256 _tokenId) view returns (uint256)",
        "function keyManagerOf(uint256) view returns (address)",
        "function keyPrice() view returns (uint256)",
        "function lendKey(address _from,address _recipient,uint256 _tokenId)",
        "function maxKeysPerAddress() view returns (uint256)",
        "function maxNumberOfKeys() view returns (uint256)",
        "function mergeKeys(uint256 _tokenIdFrom,uint256 _tokenIdTo,uint256 _amount)",
        "function migrate(bytes)",
        "function name() view returns (string)",
        "function numberOfOwners() view returns (uint256)",
        "function onKeyCancelHook() view returns (address)",
        "function onKeyPurchaseHook() view returns (address)",
        "function onKeyTransferHook() view returns (address)",
        "function onTokenURIHook() view returns (address)",
        "function onValidKeyHook() view returns (address)",
        "function owner() view returns (address)",
        "function ownerOf(uint256 _tokenId) view returns (address)",
        "function publicLockVersion() pure returns (uint16)",
        "function purchase(uint256[] _values,address[] _recipients,address[] _referrers,address[] _keyManagers,bytes[] _data) payable returns (uint256[])",
        "function purchasePriceFor(address _recipient,address _referrer,bytes _data) view returns (uint256 minKeyPrice)",
        "function referrerFees(address) view returns (uint256)",
        "function refundPenaltyBasisPoints() view returns (uint256)",
        "function renewMembershipFor(uint256 _tokenId,address _referrer)",
        "function renounceLockManager()",
        "function renounceRole(bytes32 role,address account)",
        "function revokeKeyGranter(address _granter)",
        "function revokeRole(bytes32 role,address account)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId,bytes _data)",
        "function schemaVersion() view returns (uint256)",
        "function setApprovalForAll(address _to,bool _approved)",
        "function setBaseTokenURI(string _baseTokenURI)",
        "function setEventHooks(address _onKeyPurchaseHook,address _onKeyCancelHook,address _onValidKeyHook,address _onTokenURIHook,address _onKeyTransferHook)",
        "function setExpirationDuration(uint256 _newExpirationDuration)",
        "function setGasRefundValue(uint256 _refundValue)",
        "function setKeyManagerOf(uint256 _tokenId,address _keyManager)",
        "function setMaxKeysPerAddress(uint256 _maxKeys)",
        "function setMaxNumberOfKeys(uint256 _maxNumberOfKeys)",
        "function setOwner(address account)",
        "function setReferrerFee(address _referrer,uint256 _feeBasisPoint)",
        "function shareKey(address _to,uint256 _tokenIdFrom,uint256 _timeShared)",
        "function supportsInterface(bytes4 interfaceId) view returns (bool)",
        "function symbol() view returns (string)",
        "function tokenAddress() view returns (address)",
        "function tokenByIndex(uint256 _index) view returns (uint256)",
        "function tokenOfOwnerByIndex(address _keyOwner,uint256 _index) view returns (uint256)",
        "function tokenURI(uint256 _tokenId) view returns (string)",
        "function totalKeys(address _keyOwner) view returns (uint256)",
        "function totalSupply() view returns (uint256)",
        "function transfer(uint256 _tokenId,address _to,uint256 _valueBasisPoint) returns (bool success)",
        "function transferFeeBasisPoints() view returns (uint256)",
        "function transferFrom(address _from,address _recipient,uint256 _tokenId)",
        "function unlendKey(address _recipient,uint256 _tokenId)",
        "function unlockProtocol() view returns (address)",
        "function updateBeneficiary(address _beneficiary)",
        "function updateKeyPricing(uint256 _keyPrice,address _tokenAddress)",
        "function updateLockName(string _lockName)",
        "function updateLockSymbol(string _lockSymbol)",
        "function updateRefundPenalty(uint256 _freeTrialLength,uint256 _refundPenaltyBasisPoints)",
        "function updateSchemaVersion()",
        "function updateTransferFee(uint256 _transferFeeBasisPoints)",
        "function withdraw(address _tokenAddress,uint256 _amount)"
      ],
      "bytecodeHash": "0x2cc5097486050fd8d352e6f0bb5e5044510093b9c71879538bb182699c12cd88"
    },
    "v12": {
      "contractName": "PublicLock",
      "abi": [
        "error CANNOT_APPROVE_SELF()",
        "error CANT_BE_SMALLER_THAN_SUPPLY()",
        "error CANT_EXTEND_NON_EXPIRING_KEY()",
        "error GAS_REFUND_FAILED()",
        "error INSUFFICIENT_ERC20_VALUE()",
        "error INSUFFICIENT_VALUE()",
        "error INVALID_ADDRESS()",
        "error INVALID_HOOK(uint8 hookIndex)",
        "error INVALID_LENGTH()",
        "error INVALID_TOKEN()",
        "error KEY_NOT_VALID()",
        "error KEY_TRANSFERS_DISABLED()",
        "error LOCK_HAS_CHANGED()",
        "error LOCK_SOLD_OUT()",
        "error MAX_KEYS_REACHED()",
        "error MIGRATION_REQUIRED()",
        "error NON_COMPLIANT_ERC721_RECEIVER()",
        "error NON_RENEWABLE_LOCK()",
        "error NOT_ENOUGH_FUNDS()",
        "error NOT_ENOUGH_TIME()",
        "error NOT_READY_FOR_RENEWAL()",
        "error NO_SUCH_KEY()",
        "error NULL_VALUE()",
        "error ONLY_KEY_MANAGER_OR_APPROVED()",
        "error ONLY_LOCK_MANAGER()",
        "error ONLY_LOCK_MANAGER_OR_KEY_GRANTER()",
        "error OUT_OF_RANGE()",
        "error OWNER_CANT_BE_ADDRESS_ZERO()",
        "error SCHEMA_VERSION_NOT_CORRECT()",
        "error TRANSFER_TO_SELF()",
        "error UNAUTHORIZED()",
        "error UNAUTHORIZED_KEY_MANAGER_UPDATE()",
        "event Approval (address indexed owner,address indexed approved,uint256 indexed tokenId)",
        "event ApprovalForAll (address indexed owner,address indexed operator,bool approved)",
        "event CancelKey (uint256 indexed tokenId,address indexed owner,address indexed sendTo,uint256 refund)",
        "event ExpirationChanged (uint256 indexed tokenId,uint256 newExpiration,uint256 amount,bool timeAdded)",
        "event ExpireKey (uint256 indexed tokenId)",
        "event GasRefunded (address indexed receiver,uint256 refundedAmount,address tokenAddress)",
        "event Initialized (uint8 version)",
        "event KeyExtended (uint256 indexed tokenId,uint256 newTimestamp)",
        "event KeyGranterAdded (address indexed account)",
        "event KeyGranterRemoved (address indexed account)",
        "event KeyManagerChanged (uint256 indexed _tokenId,address indexed _newManager)",
        "event KeysMigrated (uint256 updatedRecordsCount)",
        "event LockConfig (uint256 expirationDuration,uint256 maxNumberOfKeys,uint256 maxKeysPerAcccount)",
        "event LockManagerAdded (address indexed account)",
        "event LockManagerRemoved (address indexed account)",
        "event LockMetadata (string name,string symbol,string baseTokenURI)",
        "event OwnershipTransferred (address previousOwner,address newOwner)",
        "event PricingChanged (uint256 oldKeyPrice,uint256 keyPrice,address oldTokenAddress,address tokenAddress)",
        "event RefundPenaltyChanged (uint256 freeTrialLength,uint256 refundPenaltyBasisPoints)",
        "event RoleAdminChanged (bytes32 indexed role,bytes32 indexed previousAdminRole,bytes32 indexed newAdminRole)",
        "event RoleGranted (bytes32 indexed role,address indexed account,address indexed sender)",
        "event RoleRevoked (bytes32 indexed role,address indexed account,address indexed sender)",
        "event Transfer (address indexed from,address indexed to,uint256 indexed tokenId)",
        "event TransferFeeChanged (uint256 transferFeeBasisPoints)",
        "event UnlockCallFailed (address indexed lockAddress,address unlockAddress)",
        "event Withdrawal (address indexed sender,address indexed tokenAddress,address indexed recipient,uint256 amount)",
        "function DEFAULT_ADMIN_ROLE() view returns (bytes32)",
        "function KEY_GRANTER_ROLE() view returns (bytes32)",
        "function LOCK_MANAGER_ROLE() view returns (bytes32)",
        "function addKeyGranter(address account)",
        "function addLockManager(address account)",
        "function approve(address _approved,uint256 _tokenId)",
        "function balanceOf(address _keyOwner) view returns (uint256 balance)",
        "function burn(uint256 _tokenId)",
        "function cancelAndRefund(uint256 _tokenId)",
        "function expirationDuration() view returns (uint256)",
        "function expireAndRefundFor(uint256 _tokenId,uint256 _amount)",
        "function extend(uint256 _value,uint256 _tokenId,address _referrer,bytes _data) payable",
        "function freeTrialLength() view returns (uint256)",
        "function gasRefundValue() view returns (uint256 _refundValue)",
        "function getApproved(uint256 _tokenId) view returns (address)",
        "function getCancelAndRefundValue(uint256 _tokenId) view returns (uint256 refund)",
        "function getHasValidKey(address _keyOwner) view returns (bool isValid)",
        "function getRoleAdmin(bytes32 role) view returns (bytes32)",
        "function getTransferFee(uint256 _tokenId,uint256 _time) view returns (uint256)",
        "function grantKeyExtension(uint256 _tokenId,uint256 _duration)",
        "function grantKeys(address[] _recipients,uint256[] _expirationTimestamps,address[] _keyManagers) returns (uint256[])",
        "function grantRole(bytes32 role,address account)",
        "function hasRole(bytes32 role,address account) view returns (bool)",
        "function initialize(address _lockCreator,uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName)",
        "function isApprovedForAll(address _owner,address _operator) view returns (bool)",
        "function isKeyGranter(address account) view returns (bool)",
        "function isLockManager(address account) view returns (bool)",
        "function isOwner(address account) view returns (bool)",
        "function isValidKey(uint256 _tokenId) view returns (bool)",
        "function keyExpirationTimestampFor(uint256 _tokenId) view returns (uint256)",
        "function keyManagerOf(uint256) view returns (address)",
        "function keyPrice() view returns (uint256)",
        "function lendKey(address _from,address _recipient,uint256 _tokenId)",
        "function maxKeysPerAddress() view returns (uint256)",
        "function maxNumberOfKeys() view returns (uint256)",
        "function mergeKeys(uint256 _tokenIdFrom,uint256 _tokenIdTo,uint256 _amount)",
        "function migrate(bytes)",
        "function name() view returns (string)",
        "function numberOfOwners() view returns (uint256)",
        "function onKeyCancelHook() view returns (address)",
        "function onKeyExtendHook() view returns (address)",
        "function onKeyGrantHook() view returns (address)",
        "function onKeyPurchaseHook() view returns (address)",
        "function onKeyTransferHook() view returns (address)",
        "function onTokenURIHook() view returns (address)",
        "function onValidKeyHook() view returns (address)",
        "function owner() view returns (address)",
        "function ownerOf(uint256 _tokenId) view returns (address)",
        "function publicLockVersion() pure returns (uint16)",
        "function purchase(uint256[] _values,address[] _recipients,address[] _referrers,address[] _keyManagers,bytes[] _data) payable returns (uint256[])",
        "function purchasePriceFor(address _recipient,address _referrer,bytes _data) view returns (uint256 minKeyPrice)",
        "function referrerFees(address) view returns (uint256)",
        "function refundPenaltyBasisPoints() view returns (uint256)",
        "function renewMembershipFor(uint256 _tokenId,address _referrer)",
        "function renounceLockManager()",
        "function renounceRole(bytes32 role,address account)",
        "function revokeKeyGranter(address _granter)",
        "function revokeRole(bytes32 role,address account)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId,bytes _data)",
        "function schemaVersion() view returns (uint256)",
        "function setApprovalForAll(address _to,bool _approved)",
        "function setEventHooks(address _onKeyPurchaseHook,address _onKeyCancelHook,address _onValidKeyHook,address _onTokenURIHook,address _onKeyTransferHook,address _onKeyExtendHook,address _onKeyGrantHook)",
        "function setGasRefundValue(uint256 _refundValue)",
        "function setKeyManagerOf(uint256 _tokenId,address _keyManager)",
        "function setLockMetadata(string _lockName,string _lockSymbol,string _baseTokenURI)",
        "function setOwner(address account)",
        "function setReferrerFee(address _referrer,uint256 _feeBasisPoint)",
        "function shareKey(address _to,uint256 _tokenIdFrom,uint256 _timeShared)",
        "function supportsInterface(bytes4 interfaceId) view returns (bool)",
        "function symbol() view returns (string)",
        "function tokenAddress() view returns (address)",
        "function tokenByIndex(uint256 _index) view returns (uint256)",
        "function tokenOfOwnerByIndex(address _keyOwner,uint256 _index) view returns (uint256)",
        "function tokenURI(uint256 _tokenId) view returns (string)",
        "function totalKeys(address _keyOwner) view returns (uint256)",
        "function totalSupply() view returns (uint256)",
        "function transfer(uint256 _tokenId,address _to,uint256 _valueBasisPoint) returns (bool success)",
        "function transferFeeBasisPoints() view returns (uint256)",
        "function transferFrom(address _from,address _recipient,uint256 _tokenId)",
        "function unlendKey(address _recipient,uint256 _tokenId)",
        "function unlockProtocol() view returns (address)",
        "function updateKeyPricing(uint256 _keyPrice,address _tokenAddress)",
        "function updateLockConfig(uint256 _newExpirationDuration,uint256 _maxNumberOfKeys,uint256 _maxKeysPerAcccount)",
        "function updateRefundPenalty(uint256 _freeTrialLength,uint256 _refundPenaltyBasisPoints)",
        "function updateSchemaVersion()",
        "function updateTransferFee(uint256 _transferFeeBasisPoints)",
        "function withdraw(address _tokenAddress,address _recipient,uint256 _amount)"
      ],
      "bytecodeHash": "0xdd005f4fe02b48a06215a3996da43da9689a5638d00ec714d19d6aae81f9dbf6"
    },
    "v13": {
      "contractName": "PublicLock",
      "abi": [
        "error CANNOT_APPROVE_SELF()",
        "error CANT_BE_SMALLER_THAN_SUPPLY()",
        "error CANT_EXTEND_NON_EXPIRING_KEY()",
        "error GAS_REFUND_FAILED()",
        "error INSUFFICIENT_ERC20_VALUE()",
        "error INSUFFICIENT_VALUE()",
        "error INVALID_ADDRESS()",
        "error INVALID_HOOK(uint8 hookIndex)",
        "error INVALID_LENGTH()",
        "error INVALID_TOKEN()",
        "error KEY_NOT_VALID()",
        "error KEY_TRANSFERS_DISABLED()",
        "error LOCK_HAS_CHANGED()",
        "error LOCK_SOLD_OUT()",
        "error MAX_KEYS_REACHED()",
        "error MIGRATION_REQUIRED()",
        "error NON_COMPLIANT_ERC721_RECEIVER()",
        "error NON_RENEWABLE_LOCK()",
        "error NOT_ENOUGH_FUNDS()",
        "error NOT_ENOUGH_TIME()",
        "error NOT_READY_FOR_RENEWAL()",
        "error NO_SUCH_KEY()",
        "error NULL_VALUE()",
        "error ONLY_KEY_MANAGER_OR_APPROVED()",
        "error ONLY_LOCK_MANAGER()",
        "error ONLY_LOCK_MANAGER_OR_KEY_GRANTER()",
        "error OUT_OF_RANGE()",
        "error OWNER_CANT_BE_ADDRESS_ZERO()",
        "error SCHEMA_VERSION_NOT_CORRECT()",
        "error TRANSFER_TO_SELF()",
        "error TransferFailed()",
        "error UNAUTHORIZED()",
        "error UNAUTHORIZED_KEY_MANAGER_UPDATE()",
        "event Approval (address indexed owner,address indexed approved,uint256 indexed tokenId)",
        "event ApprovalForAll (address indexed owner,address indexed operator,bool approved)",
        "event CancelKey (uint256 indexed tokenId,address indexed owner,address indexed sendTo,uint256 refund)",
        "event EventHooksUpdated (address onKeyPurchaseHook,address onKeyCancelHook,address onValidKeyHook,address onTokenURIHook,address onKeyTransferHook,address onKeyExtendHook,address onKeyGrantHook)",
        "event ExpirationChanged (uint256 indexed tokenId,uint256 newExpiration,uint256 amount,bool timeAdded)",
        "event ExpireKey (uint256 indexed tokenId)",
        "event GasRefundValueChanged (uint256 refundValue)",
        "event GasRefunded (address indexed receiver,uint256 refundedAmount,address tokenAddress)",
        "event Initialized (uint8 version)",
        "event KeyExtended (uint256 indexed tokenId,uint256 newTimestamp)",
        "event KeyGranterAdded (address indexed account)",
        "event KeyGranterRemoved (address indexed account)",
        "event KeyManagerChanged (uint256 indexed _tokenId,address indexed _newManager)",
        "event KeysMigrated (uint256 updatedRecordsCount)",
        "event LockConfig (uint256 expirationDuration,uint256 maxNumberOfKeys,uint256 maxKeysPerAcccount)",
        "event LockManagerAdded (address indexed account)",
        "event LockManagerRemoved (address indexed account)",
        "event LockMetadata (string name,string symbol,string baseTokenURI)",
        "event OwnershipTransferred (address previousOwner,address newOwner)",
        "event PricingChanged (uint256 oldKeyPrice,uint256 keyPrice,address oldTokenAddress,address tokenAddress)",
        "event ReferrerFee (address indexed referrer,uint256 fee)",
        "event RefundPenaltyChanged (uint256 freeTrialLength,uint256 refundPenaltyBasisPoints)",
        "event RoleAdminChanged (bytes32 indexed role,bytes32 indexed previousAdminRole,bytes32 indexed newAdminRole)",
        "event RoleGranted (bytes32 indexed role,address indexed account,address indexed sender)",
        "event RoleRevoked (bytes32 indexed role,address indexed account,address indexed sender)",
        "event Transfer (address indexed from,address indexed to,uint256 indexed tokenId)",
        "event TransferFeeChanged (uint256 transferFeeBasisPoints)",
        "event UnlockCallFailed (address indexed lockAddress,address unlockAddress)",
        "event Withdrawal (address indexed sender,address indexed tokenAddress,address indexed recipient,uint256 amount)",
        "function DEFAULT_ADMIN_ROLE() view returns (bytes32)",
        "function addLockManager(address account)",
        "function approve(address _approved,uint256 _tokenId)",
        "function balanceOf(address _keyOwner) view returns (uint256 balance)",
        "function burn(uint256 _tokenId)",
        "function cancelAndRefund(uint256 _tokenId)",
        "function expirationDuration() view returns (uint256)",
        "function expireAndRefundFor(uint256 _tokenId,uint256 _amount)",
        "function extend(uint256 _value,uint256 _tokenId,address _referrer,bytes _data) payable",
        "function freeTrialLength() view returns (uint256)",
        "function gasRefundValue() view returns (uint256 _refundValue)",
        "function getApproved(uint256 _tokenId) view returns (address)",
        "function getCancelAndRefundValue(uint256 _tokenId) view returns (uint256 refund)",
        "function getHasValidKey(address _keyOwner) view returns (bool isValid)",
        "function getRoleAdmin(bytes32 role) view returns (bytes32)",
        "function getTransferFee(uint256 _tokenId,uint256 _time) view returns (uint256)",
        "function grantKeyExtension(uint256 _tokenId,uint256 _duration)",
        "function grantKeys(address[] _recipients,uint256[] _expirationTimestamps,address[] _keyManagers) returns (uint256[])",
        "function grantRole(bytes32 role,address account)",
        "function hasRole(bytes32 role,address account) view returns (bool)",
        "function initialize(address _lockCreator,uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName)",
        "function isApprovedForAll(address _owner,address _operator) view returns (bool)",
        "function isLockManager(address account) view returns (bool)",
        "function isOwner(address account) view returns (bool)",
        "function isRenewable(uint256 _tokenId,address _referrer) view returns (bool)",
        "function isValidKey(uint256 _tokenId) view returns (bool)",
        "function keyExpirationTimestampFor(uint256 _tokenId) view returns (uint256)",
        "function keyManagerOf(uint256) view returns (address)",
        "function keyPrice() view returns (uint256)",
        "function lendKey(address _from,address _recipient,uint256 _tokenId)",
        "function maxKeysPerAddress() view returns (uint256)",
        "function maxNumberOfKeys() view returns (uint256)",
        "function mergeKeys(uint256 _tokenIdFrom,uint256 _tokenIdTo,uint256 _amount)",
        "function migrate(bytes)",
        "function name() view returns (string)",
        "function numberOfOwners() view returns (uint256)",
        "function onKeyCancelHook() view returns (address)",
        "function onKeyExtendHook() view returns (address)",
        "function onKeyGrantHook() view returns (address)",
        "function onKeyPurchaseHook() view returns (address)",
        "function onKeyTransferHook() view returns (address)",
        "function onTokenURIHook() view returns (address)",
        "function onValidKeyHook() view returns (address)",
        "function owner() view returns (address)",
        "function ownerOf(uint256 _tokenId) view returns (address)",
        "function publicLockVersion() pure returns (uint16)",
        "function purchase(uint256[] _values,address[] _recipients,address[] _referrers,address[] _keyManagers,bytes[] _data) payable returns (uint256[])",
        "function purchasePriceFor(address _recipient,address _referrer,bytes _data) view returns (uint256 minKeyPrice)",
        "function referrerFees(address) view returns (uint256)",
        "function refundPenaltyBasisPoints() view returns (uint256)",
        "function renewMembershipFor(uint256 _tokenId,address _referrer)",
        "function renounceLockManager()",
        "function renounceRole(bytes32 role,address account)",
        "function revokeRole(bytes32 role,address account)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId)",
        "function safeTransferFrom(address _from,address _to,uint256 _tokenId,bytes _data)",
        "function schemaVersion() view returns (uint256)",
        "function setApprovalForAll(address _to,bool _approved)",
        "function setEventHooks(address _onKeyPurchaseHook,address _onKeyCancelHook,address _onValidKeyHook,address _onTokenURIHook,address _onKeyTransferHook,address _onKeyExtendHook,address _onKeyGrantHook)",
        "function setGasRefundValue(uint256 _refundValue)",
        "function setKeyManagerOf(uint256 _tokenId,address _keyManager)",
        "function setLockMetadata(string _lockName,string _lockSymbol,string _baseTokenURI)",
        "function setOwner(address account)",
        "function setReferrerFee(address _referrer,uint256 _feeBasisPoint)",
        "function shareKey(address _to,uint256 _tokenIdFrom,uint256 _timeShared)",
        "function supportsInterface(bytes4 interfaceId) view returns (bool)",
        "function symbol() view returns (string)",
        "function tokenAddress() view returns (address)",
        "function tokenByIndex(uint256 _index) view returns (uint256)",
        "function tokenOfOwnerByIndex(address _keyOwner,uint256 _index) view returns (uint256)",
        "function tokenURI(uint256 _tokenId) view returns (string)",
        "function totalKeys(address _keyOwner) view returns (uint256)",
        "function totalSupply() view returns (uint256 _totalKeysCreated)",
        "function transferFeeBasisPoints() view returns (uint256)",
        "function transferFrom(address _from,address _recipient,uint256 _tokenId)",
        "function unlendKey(address _recipient,uint256 _tokenId)",
        "function unlockProtocol() view returns (address)",
        "function updateKeyPricing(uint256 _keyPrice,address _tokenAddress)",
        "function updateLockConfig(uint256 _newExpirationDuration,uint256 _maxNumberOfKeys,uint256 _maxKeysPerAcccount)",
        "function updateRefundPenalty(uint256 _freeTrialLength,uint256 _refundPenaltyBasisPoints)",
        "function updateSchemaVersion()",
        "function updateTransferFee(uint256 _transferFeeBasisPoints)",
        "function withdraw(address _tokenAddress,address _recipient,uint256 _amount)"
      ],
      "bytecodeHash": "0x80041134ce431f1adb2b2dfe00df82753d269761cbf9bac1232e0523fa787ed2"
    }
  },
  "Unlock": {
    "v4": {
      "contractName": "Unlock",
      "abi": [
        "function locks(address) constant view returns (bool deployed,uint256 totalSales,uint256 yieldedDiscountTokens)",
        "function renounceOwnership()",
        "function owner() constant view returns (address)",
        "function isOwner() constant view returns (bool)",
        "function totalDiscountGranted() constant view returns (uint256)",
        "function grossNetworkProduct() constant view returns (uint256)",
        "function transferOwnership(address newOwner)",
        "event NewLock (address indexed lockOwner,address indexed newLockAddress)",
        "event NewTokenURI (string tokenURI)",
        "event NewGlobalTokenSymbol (string tokenSymbol)",
        "event OwnershipTransferred (address indexed previousOwner,address indexed newOwner)",
        "function initialize(address _owner)",
        "function createLock(uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName)",
        "function computeAvailableDiscountFor(address _purchaser,uint256 _keyPrice) constant view returns (uint256 discount,uint256 tokens)",
        "function recordKeyPurchase(uint256 _value,address _referrer)",
        "function recordConsumedDiscount(uint256 _discount,uint256 _tokens)",
        "function unlockVersion() constant pure returns (uint16)",
        "function getGlobalBaseTokenURI() constant view returns (string)",
        "function setGlobalBaseTokenURI(string _URI)",
        "function getGlobalTokenSymbol() constant view returns (string)",
        "function setGlobalTokenSymbol(string _symbol)"
      ],
      "bytecodeHash": "0xa1e7ddfa6d9183443aca067a96bd252f3ffa72a55ce36564ab77e79ce6527ac3"
    },
    "v6": {
      "contractName": "Unlock",
      "abi": [
        "event ConfigUnlock (address publicLockAddress,string globalTokenSymbol,string globalTokenURI)",
        "event NewLock (address indexed lockOwner,address indexed newLockAddress)",
        "event OwnershipTransferred (address indexed previousOwner,address indexed newOwner)",
        "event ResetTrackedValue (uint256 grossNetworkProduct,uint256 totalDiscountGranted)",
        "function globalBaseTokenURI() constant view returns (string)",
        "function globalTokenSymbol() constant view returns (string)",
        "function grossNetworkProduct() constant view returns (uint256)",
        "function isOwner() constant view returns (bool)",
        "function locks(address) constant view returns (bool deployed,uint256 totalSales,uint256 yieldedDiscountTokens)",
        "function owner() constant view returns (address)",
        "function publicLockAddress() constant view returns (address)",
        "function renounceOwnership()",
        "function totalDiscountGranted() constant view returns (uint256)",
        "function transferOwnership(address newOwner)",
        "function uniswapExchanges(address) constant view returns (address)",
        "function initialize(address _owner)",
        "function createLock(uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName,bytes12 _salt)",
        "function computeAvailableDiscountFor(address _purchaser,uint256 _keyPrice) constant view returns (uint256 discount,uint256 tokens)",
        "function recordKeyPurchase(uint256 _value,address _referrer)",
        "function recordConsumedDiscount(uint256 _discount,uint256 _tokens)",
        "function unlockVersion() constant pure returns (uint16)",
        "function configUnlock(address _publicLockAddress,string _symbol,string _URI)",
        "function setExchange(address _tokenAddress,address _exchangeAddress)",
        "function resetTrackedValue(uint256 _grossNetworkProduct,uint256 _totalDiscountGranted)"
      ],
      "bytecodeHash": "0x7b0e23742d9e4cbda29162687b753336c14d9afa6372385323f3a32a1365f535"
    },
    "v7": {
      "contractName": "Unlock",
      "abi": [
        "event ConfigUnlock (string globalTokenSymbol,string globalTokenURI)",
        "event NewLock (address indexed lockOwner,address indexed newLockAddress)",
        "event OwnershipTransferred (address indexed previousOwner,address indexed newOwner)",
        "event ResetTrackedValue (uint256 grossNetworkProduct,uint256 totalDiscountGranted)",
        "event SetLockTemplate (address publicLockAddress)",
        "function globalBaseTokenURI() constant view returns (string)",
        "function globalTokenSymbol() constant view returns (string)",
        "function grossNetworkProduct() constant view returns (uint256)",
        "function isOwner() constant view returns (bool)",
        "function locks(address) constant view returns (bool deployed,uint256 totalSales,uint256 yieldedDiscountTokens)",
        "function owner() constant view returns (address)",
        "function publicLockAddress() constant view returns (address)",
        "function renounceOwnership()",
        "function totalDiscountGranted() constant view returns (uint256)",
        "function transferOwnership(address newOwner)",
        "function uniswapExchanges(address) constant view returns (address)",
        "function initialize(address _unlockOwner)",
        "function createLock(uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName,bytes12 _salt)",
        "function computeAvailableDiscountFor(address,uint256) constant view returns (uint256 discount,uint256 tokens)",
        "function recordKeyPurchase(uint256 _value,address)",
        "function recordConsumedDiscount(uint256 _discount,uint256)",
        "function unlockVersion() constant pure returns (uint16)",
        "function configUnlock(string _symbol,string _URI)",
        "function setLockTemplate(address _publicLockAddress)",
        "function setExchange(address _tokenAddress,address _exchangeAddress)",
        "function resetTrackedValue(uint256 _grossNetworkProduct,uint256 _totalDiscountGranted)",
        "function getGlobalBaseTokenURI() constant view returns (string)",
        "function getGlobalTokenSymbol() constant view returns (string)"
      ],
      "bytecodeHash": "0x2f4767420e3b4affa1e3169450a565061cab422cdf7cd582179eb33b0480da0b"
    },
    "v8": {
      "contractName": "Unlock",
      "abi": [
        "event ConfigUnlock (address udt,address weth,uint256 estimatedGasForPurchase,string globalTokenSymbol,string globalTokenURI)",
        "event NewLock (address indexed lockOwner,address indexed newLockAddress)",
        "event OwnershipTransferred (address indexed previousOwner,address indexed newOwner)",
        "event ResetTrackedValue (uint256 grossNetworkProduct,uint256 totalDiscountGranted)",
        "event SetLockTemplate (address publicLockAddress)",
        "function estimatedGasForPurchase() constant view returns (uint256)",
        "function globalBaseTokenURI() constant view returns (string)",
        "function globalTokenSymbol() constant view returns (string)",
        "function grossNetworkProduct() constant view returns (uint256)",
        "function isOwner() constant view returns (bool)",
        "function locks(address) constant view returns (bool deployed,uint256 totalSales,uint256 yieldedDiscountTokens)",
        "function owner() constant view returns (address)",
        "function publicLockAddress() constant view returns (address)",
        "function renounceOwnership()",
        "function totalDiscountGranted() constant view returns (uint256)",
        "function transferOwnership(address newOwner)",
        "function udt() constant view returns (address)",
        "function uniswapOracles(address) constant view returns (address)",
        "function weth() constant view returns (address)",
        "function initialize(address _unlockOwner)",
        "function createLock(uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName,bytes12 _salt)",
        "function computeAvailableDiscountFor(address,uint256) constant view returns (uint256 discount,uint256 tokens)",
        "function recordKeyPurchase(uint256 _value,address _referrer)",
        "function recordConsumedDiscount(uint256 _discount,uint256)",
        "function unlockVersion() constant pure returns (uint16)",
        "function configUnlock(address _udt,address _weth,uint256 _estimatedGasForPurchase,string _symbol,string _URI)",
        "function setLockTemplate(address _publicLockAddress)",
        "function setOracle(address _tokenAddress,address _oracleAddress)",
        "function resetTrackedValue(uint256 _grossNetworkProduct,uint256 _totalDiscountGranted)",
        "function getGlobalBaseTokenURI() constant view returns (string)",
        "function getGlobalTokenSymbol() constant view returns (string)"
      ],
      "bytecodeHash": "0xa757523ba876af736fe51084850937c0750049a724990558f1753fe9d0b0ec5e"
    },
    "v9": {
      "contractName": "Unlock",
      "abi": [
        "event ConfigUnlock (address udt,address weth,uint256 estimatedGasForPurchase,string globalTokenSymbol,string globalTokenURI,uint256 chainId)",
        "event NewLock (address indexed lockOwner,address indexed newLockAddress)",
        "event OwnershipTransferred (address indexed previousOwner,address indexed newOwner)",
        "event ResetTrackedValue (uint256 grossNetworkProduct,uint256 totalDiscountGranted)",
        "event SetLockTemplate (address publicLockAddress)",
        "function chainId() constant view returns (uint256)",
        "function estimatedGasForPurchase() constant view returns (uint256)",
        "function globalBaseTokenURI() constant view returns (string)",
        "function globalTokenSymbol() constant view returns (string)",
        "function grossNetworkProduct() constant view returns (uint256)",
        "function isOwner() constant view returns (bool)",
        "function locks(address) constant view returns (bool deployed,uint256 totalSales,uint256 yieldedDiscountTokens)",
        "function owner() constant view returns (address)",
        "function publicLockAddress() constant view returns (address)",
        "function renounceOwnership()",
        "function totalDiscountGranted() constant view returns (uint256)",
        "function transferOwnership(address newOwner)",
        "function udt() constant view returns (address)",
        "function uniswapOracles(address) constant view returns (address)",
        "function weth() constant view returns (address)",
        "function initialize(address _unlockOwner)",
        "function createLock(uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName,bytes12 _salt)",
        "function computeAvailableDiscountFor(address,uint256) constant view returns (uint256 discount,uint256 tokens)",
        "function recordKeyPurchase(uint256 _value,address _referrer)",
        "function recordConsumedDiscount(uint256 _discount,uint256)",
        "function unlockVersion() constant pure returns (uint16)",
        "function configUnlock(address _udt,address _weth,uint256 _estimatedGasForPurchase,string _symbol,string _URI,uint256 _chainId)",
        "function setLockTemplate(address _publicLockAddress)",
        "function setOracle(address _tokenAddress,address _oracleAddress)",
        "function resetTrackedValue(uint256 _grossNetworkProduct,uint256 _totalDiscountGranted)",
        "function getGlobalBaseTokenURI() constant view returns (string)",
        "function getGlobalTokenSymbol() constant view returns (string)"
      ],
      "bytecodeHash": "0xc5ea0fd202dd361f7dcc45b751f2c2d46a796e3a53c7e75dc1c16cf5285b5a8e"
    },
    "v10": {
      "contractName": "Unlock",
      "abi": [
        "event ConfigUnlock (address udt,address weth,uint256 estimatedGasForPurchase,string globalTokenSymbol,string globalTokenURI,uint256 chainId)",
        "event LockUpgraded (address lockAddress,uint16 version)",
        "event NewLock (address indexed lockOwner,address indexed newLockAddress)",
        "event OwnershipTransferred (address indexed previousOwner,address indexed newOwner)",
        "event ResetTrackedValue (uint256 grossNetworkProduct,uint256 totalDiscountGranted)",
        "event SetLockTemplate (address publicLockAddress)",
        "event UnlockTemplateAdded (address indexed impl,uint16 indexed version)",
        "function __initializeOwnable(address sender)",
        "function addLockTemplate(address impl,uint16 version)",
        "function chainId() view returns (uint256)",
        "function computeAvailableDiscountFor(address,uint256) pure returns (uint256 discount,uint256 tokens)",
        "function configUnlock(address _udt,address _weth,uint256 _estimatedGasForPurchase,string _symbol,string _URI,uint256 _chainId)",
        "function createLock(uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName,bytes12) returns (address)",
        "function createUpgradeableLock(bytes data) returns (address)",
        "function estimatedGasForPurchase() view returns (uint256)",
        "function getGlobalBaseTokenURI() view returns (string)",
        "function getGlobalTokenSymbol() view returns (string)",
        "function globalBaseTokenURI() view returns (string)",
        "function globalTokenSymbol() view returns (string)",
        "function grossNetworkProduct() view returns (uint256)",
        "function initialize(address _unlockOwner)",
        "function initializeProxyAdmin()",
        "function isOwner() view returns (bool)",
        "function locks(address) view returns (bool deployed,uint256 totalSales,uint256 yieldedDiscountTokens)",
        "function owner() view returns (address)",
        "function proxyAdminAddress() view returns (address)",
        "function publicLockAddress() view returns (address)",
        "function publicLockImpls(uint16 _version) view returns (address)",
        "function publicLockLatestVersion() view returns (uint16)",
        "function publicLockVersions(address _impl) view returns (uint16)",
        "function recordConsumedDiscount(uint256,uint256) view",
        "function recordKeyPurchase(uint256 _value,address _referrer)",
        "function renounceOwnership()",
        "function resetTrackedValue(uint256 _grossNetworkProduct,uint256 _totalDiscountGranted)",
        "function setLockTemplate(address _publicLockAddress)",
        "function setOracle(address _tokenAddress,address _oracleAddress)",
        "function totalDiscountGranted() view returns (uint256)",
        "function transferOwnership(address newOwner)",
        "function udt() view returns (address)",
        "function uniswapOracles(address) view returns (address)",
        "function unlockVersion() pure returns (uint16)",
        "function upgradeLock(address lockAddress,uint16 version) returns (address)",
        "function weth() view returns (address)"
      ],
      "bytecodeHash": "0x81e49b5cc6f523a46b17d6d6b3658eb34eab85dee56a711bdb06f66358002555"
    },
    "v11": {
      "contractName": "Unlock",
      "abi": [
        "event ConfigUnlock (address udt,address weth,uint256 estimatedGasForPurchase,string globalTokenSymbol,string globalTokenURI,uint256 chainId)",
        "event GNPChanged (uint256 grossNetworkProduct,uint256 _valueInETH,address tokenAddress,uint256 value,address lockAddress)",
        "event LockUpgraded (address lockAddress,uint16 version)",
        "event NewLock (address indexed lockOwner,address indexed newLockAddress)",
        "event OwnershipTransferred (address indexed previousOwner,address indexed newOwner)",
        "event ResetTrackedValue (uint256 grossNetworkProduct,uint256 totalDiscountGranted)",
        "event SetLockTemplate (address publicLockAddress)",
        "event UnlockTemplateAdded (address indexed impl,uint16 indexed version)",
        "function __initializeOwnable(address sender)",
        "function addLockTemplate(address impl,uint16 version)",
        "function chainId() view returns (uint256)",
        "function computeAvailableDiscountFor(address,uint256) pure returns (uint256 discount,uint256 tokens)",
        "function configUnlock(address _udt,address _weth,uint256 _estimatedGasForPurchase,string _symbol,string _URI,uint256 _chainId)",
        "function createLock(uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName,bytes12) returns (address)",
        "function createUpgradeableLock(bytes data) returns (address)",
        "function createUpgradeableLockAtVersion(bytes data,uint16 _lockVersion) returns (address)",
        "function estimatedGasForPurchase() view returns (uint256)",
        "function getGlobalBaseTokenURI() view returns (string)",
        "function getGlobalTokenSymbol() view returns (string)",
        "function globalBaseTokenURI() view returns (string)",
        "function globalTokenSymbol() view returns (string)",
        "function grossNetworkProduct() view returns (uint256)",
        "function initialize(address _unlockOwner)",
        "function initializeProxyAdmin()",
        "function isOwner() view returns (bool)",
        "function locks(address) view returns (bool deployed,uint256 totalSales,uint256 yieldedDiscountTokens)",
        "function networkBaseFee() view returns (uint256)",
        "function owner() view returns (address)",
        "function proxyAdminAddress() view returns (address)",
        "function publicLockAddress() view returns (address)",
        "function publicLockImpls(uint16 _version) view returns (address)",
        "function publicLockLatestVersion() view returns (uint16)",
        "function publicLockVersions(address _impl) view returns (uint16)",
        "function recordConsumedDiscount(uint256,uint256) view",
        "function recordKeyPurchase(uint256 _value,address _referrer)",
        "function renounceOwnership()",
        "function resetTrackedValue(uint256 _grossNetworkProduct,uint256 _totalDiscountGranted)",
        "function setLockTemplate(address _publicLockAddress)",
        "function setOracle(address _tokenAddress,address _oracleAddress)",
        "function totalDiscountGranted() view returns (uint256)",
        "function transferOwnership(address newOwner)",
        "function udt() view returns (address)",
        "function uniswapOracles(address) view returns (address)",
        "function unlockVersion() pure returns (uint16)",
        "function upgradeLock(address lockAddress,uint16 version) returns (address)",
        "function weth() view returns (address)"
      ],
      "bytecodeHash": "0xa7e4659ad2ab8fff93d896c39a634e985bc475dac4caa8a0494433e53d9a9574"
    },
    "v12": {
      "contractName": "Unlock",
      "abi": [
        "error Unlock__ALREADY_DEPLOYED()",
        "error Unlock__INVALID_AMOUNT()",
        "error Unlock__MANAGER_ONLY()",
        "error Unlock__MISSING_LOCK(address lockAddress)",
        "error Unlock__MISSING_LOCK_TEMPLATE()",
        "error Unlock__MISSING_PROXY_ADMIN()",
        "error Unlock__MISSING_TEMPLATE()",
        "error Unlock__VERSION_TOO_HIGH()",
        "event ConfigUnlock (address udt,address weth,uint256 estimatedGasForPurchase,string globalTokenSymbol,string globalTokenURI,uint256 chainId)",
        "event GNPChanged (uint256 grossNetworkProduct,uint256 _valueInETH,address tokenAddress,uint256 value,address lockAddress)",
        "event LockUpgraded (address lockAddress,uint16 version)",
        "event NewLock (address indexed lockOwner,address indexed newLockAddress)",
        "event OwnershipTransferred (address indexed previousOwner,address indexed newOwner)",
        "event ResetTrackedValue (uint256 grossNetworkProduct,uint256 totalDiscountGranted)",
        "event SetLockTemplate (address publicLockAddress)",
        "event UnlockTemplateAdded (address indexed impl,uint16 indexed version)",
        "function __initializeOwnable(address sender)",
        "function addLockTemplate(address impl,uint16 version)",
        "function chainId() view returns (uint256)",
        "function computeAvailableDiscountFor(address,uint256) pure returns (uint256 discount,uint256 tokens)",
        "function configUnlock(address _udt,address _weth,uint256 _estimatedGasForPurchase,string _symbol,string _URI,uint256 _chainId)",
        "function createLock(uint256 _expirationDuration,address _tokenAddress,uint256 _keyPrice,uint256 _maxNumberOfKeys,string _lockName,bytes12) returns (address)",
        "function createUpgradeableLock(bytes data) returns (address)",
        "function createUpgradeableLockAtVersion(bytes data,uint16 _lockVersion) returns (address)",
        "function estimatedGasForPurchase() view returns (uint256)",
        "function getAdmin() view returns (address)",
        "function getGlobalBaseTokenURI() view returns (string)",
        "function getGlobalTokenSymbol() view returns (string)",
        "function globalBaseTokenURI() view returns (string)",
        "function globalTokenSymbol() view returns (string)",
        "function grossNetworkProduct() view returns (uint256)",
        "function initialize(address _unlockOwner)",
        "function initializeProxyAdmin()",
        "function isOwner() view returns (bool)",
        "function locks(address) view returns (bool deployed,uint256 totalSales,uint256 yieldedDiscountTokens)",
        "function networkBaseFee() view returns (uint256)",
        "function owner() view returns (address)",
        "function postLockUpgrade()",
        "function protocolFee() view returns (uint256)",
        "function proxyAdminAddress() view returns (address)",
        "function publicLockAddress() view returns (address)",
        "function publicLockImpls(uint16 _version) view returns (address)",
        "function publicLockLatestVersion() view returns (uint16)",
        "function publicLockVersions(address _impl) view returns (uint16)",
        "function recordConsumedDiscount(uint256,uint256) view",
        "function recordKeyPurchase(uint256 _value,address _referrer)",
        "function removeLock(address lock)",
        "function renounceOwnership()",
        "function resetTrackedValue(uint256 _grossNetworkProduct,uint256 _totalDiscountGranted)",
        "function setLockTemplate(address _publicLockAddress)",
        "function setOracle(address _tokenAddress,address _oracleAddress)",
        "function setProtocolFee(uint256 _protocolFee)",
        "function totalDiscountGranted() view returns (uint256)",
        "function transferOwnership(address newOwner)",
        "function transferTokens(address token,address to,uint256 amount)",
        "function udt() view returns (address)",
        "function uniswapOracles(address) view returns (address)",
        "function unlockVersion() pure returns (uint16)",
        "function upgradeLock(address lockAddress,uint16 version) returns (address)",
        "function weth() view returns (address)"
      ],
      "bytecodeHash": "0x461d3c895d16600884d7cf2a9d05727c467e59a93d606cff28a33e2d76d8fc0b"
    }
  }
};
var abis_default = abis;

// src/constants.ts
import { ethers as ethers2 } from "ethers";
var MAX_UINT = "115792089237316195423570985008687907853269984665640564039457584007913129639935";
var ETHERS_MAX_UINT = ethers2.constants.MaxUint256;
var UNLIMITED_KEYS_COUNT = -1;
var ZERO = ethers2.constants.AddressZero;

// src/erc20.ts
import { ethers as ethers3 } from "ethers";

// src/erc20abi.ts
var erc20abi = [
  "function name() public view returns (string)",
  "function version() public view returns (string)",
  "function totalSupply() public view returns (uint)",
  "function balanceOf(address tokenOwner) public view returns (uint balance)",
  "function decimals() public view returns (uint decimals)",
  "function allowance(address tokenOwner, address spender) public view returns (uint remaining)",
  "function transfer(address to, uint tokens) public returns (bool success)",
  "function approve(address spender, uint tokens) public returns (bool success)",
  "function transferFrom(address from, address to, uint tokens) public returns (bool success)",
  "function symbol() public view returns (string)",
  "event Transfer(address indexed from, address indexed to, uint tokens)",
  "event Approval(address indexed tokenOwner, address indexed spender, uint tokens)"
];
var erc20abi_default = erc20abi;

// src/erc20.ts
var SAI_ADDRESS = "0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359".toLowerCase();
var TransferWithAuthorizationTypes = {
  TransferWithAuthorization: [
    { name: "from", type: "address" },
    { name: "to", type: "address" },
    { name: "value", type: "uint256" },
    { name: "validAfter", type: "uint256" },
    { name: "validBefore", type: "uint256" },
    { name: "nonce", type: "bytes32" }
  ]
};
async function getErc20BalanceForAddress(erc20ContractAddress, address, provider) {
  const contract = new ethers3.Contract(erc20ContractAddress, erc20abi_default, provider);
  const balance = await contract.balanceOf(address);
  return utils_default.hexToNumberString(balance);
}
async function getErc20Decimals(erc20ContractAddress, provider) {
  const contract = new ethers3.Contract(erc20ContractAddress, erc20abi_default, provider);
  let decimals;
  try {
    decimals = await contract.decimals();
  } catch (e) {
    return 18;
  }
  return utils_default.toNumber(decimals);
}
async function getErc20TokenSymbol(erc20ContractAddress, provider) {
  if (erc20ContractAddress.toLowerCase() === SAI_ADDRESS) {
    return "SAI";
  }
  const contract = new ethers3.Contract(erc20ContractAddress, erc20abi_default, provider);
  let symbol;
  try {
    symbol = await contract.symbol();
  } catch (e) {
    return null;
  }
  return symbol;
}
async function getAllowance(erc20ContractAddress, lockContractAddress, provider, spenderAddress) {
  const contract = new ethers3.Contract(erc20ContractAddress, erc20abi_default, provider);
  let amount = ethers3.BigNumber.from(0);
  try {
    amount = await contract.allowance(spenderAddress, lockContractAddress);
  } catch (e) {
  }
  return amount;
}
async function approveTransfer(erc20ContractAddress, lockContractAddress, value, provider, signer) {
  const contract = new ethers3.Contract(erc20ContractAddress, erc20abi_default, signer);
  return contract.approve(lockContractAddress, value);
}
var getDomain = async (chainId, erc20ContractAddress, provider) => {
  const contract = new ethers3.Contract(erc20ContractAddress, erc20abi_default, provider);
  let version = "1";
  try {
    version = await contract.version();
  } catch (error) {
    console.error(
      `We could not retrieve the version of ${erc20ContractAddress} using the version() method. Defaulting to ${version}`
    );
  }
  const name2 = await contract.name();
  if (chainId === 137) {
    return {
      name: name2,
      version,
      salt: ethers3.utils.zeroPad(ethers3.utils.arrayify(137), 32),
      verifyingContract: ethers3.utils.getAddress(erc20ContractAddress)
    };
  }
  return {
    name: name2,
    version,
    chainId,
    verifyingContract: ethers3.utils.getAddress(erc20ContractAddress)
  };
};
async function signTransferAuthorization(erc20ContractAddress, message, provider, signer) {
  const { chainId } = await provider.getNetwork();
  const domain = await getDomain(chainId, erc20ContractAddress, provider);
  return signer._signTypedData(domain, TransferWithAuthorizationTypes, message);
}
async function recoverTransferAuthorization(erc20ContractAddress, message, chainId, signature, provider) {
  const domain = await getDomain(chainId, erc20ContractAddress, provider);
  return ethers3.utils.verifyTypedData(
    domain,
    TransferWithAuthorizationTypes,
    message,
    signature
  );
}
async function transferWithAuthorization(erc20ContractAddress, message, signature, signer) {
  const contract = new ethers3.Contract(erc20ContractAddress, erc20abi_default, signer);
  const { v, r, s } = ethers3.utils.splitSignature(signature);
  return contract.transferWithAuthorization(
    message.from,
    message.to,
    message.value,
    message.validAfter,
    message.validBefore,
    message.nonce,
    v,
    r,
    s
  );
}

// src/PublicLock/utils/approveAllowance.js
async function approveAllowance({
  erc20Address,
  address,
  totalAmountToApprove
}) {
  if (erc20Address && erc20Address !== ZERO) {
    const approvedAmount = await getAllowance(
      erc20Address,
      address,
      this.provider,
      this.signer.getAddress()
    );
    if (!approvedAmount || utils_default.bigNumberify(approvedAmount).lt(totalAmountToApprove)) {
      await (await approveTransfer(
        erc20Address,
        address,
        totalAmountToApprove,
        this.provider,
        this.signer
      )).wait();
    }
  }
}

// src/PublicLock/v4/purchaseKey.js
async function purchaseKey_default({ lockAddress, owner, keyPrice, erc20Address, decimals, swap }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const unlockSwapPurchaserContract = swap ? this.getUnlockSwapPurchaserContract({
    params: this.networkId
  }) : null;
  if (!owner) {
    owner = await this.signer.getAddress();
  }
  if (!erc20Address || erc20Address !== ZERO) {
    erc20Address = await lockContract.tokenAddress();
  }
  let actualAmount;
  if (!keyPrice) {
    actualAmount = await lockContract.keyPrice();
  } else if (decimals == null) {
    if (erc20Address && erc20Address !== ZERO) {
      decimals = await getErc20Decimals(erc20Address, this.provider);
    } else {
      decimals = 18;
    }
    actualAmount = utils_default.toDecimal(keyPrice, decimals);
  }
  const callData = lockContract.interface.encodeFunctionData("purchaseFor", [
    owner
  ]);
  if (!erc20Address || erc20Address === ZERO) {
    transactionOptions.value = actualAmount;
  }
  if (swap && swap?.value) {
    transactionOptions.value = swap.value;
  }
  const approvalOptions = swap ? {
    erc20Address: swap.srcTokenAddress,
    address: unlockSwapPurchaserContract?.address,
    totalAmountToApprove: swap.amountInMax
  } : {
    erc20Address,
    address: lockAddress,
    totalAmountToApprove: actualAmount
  };
  if (approvalOptions.erc20Address && approvalOptions.erc20Address !== ZERO) {
    await approveAllowance.bind(this)(approvalOptions);
  }
  const transactionPromise = swap ? unlockSwapPurchaserContract?.swapAndCall(
    lockAddress,
    swap.srcTokenAddress || ZERO,
    swap.amountInMax,
    swap.uniswapRouter,
    swap.swapCallData,
    callData,
    transactionOptions
  ) : lockContract.purchaseFor(owner, transactionOptions);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  if (receipt.status === 0) {
    throw new Error("Transaction failed");
  }
  const parser = lockContract.interface;
  const transferEvent = receipt.logs.map((log) => {
    if (log.address.toLowerCase() !== lockAddress.toLowerCase())
      return;
    return parser.parseLog(log);
  }).filter((event) => {
    return event && event.name === "Transfer";
  })[0];
  if (transferEvent) {
    return transferEvent.args._tokenId.toString();
  }
  return null;
}

// src/PublicLock/utils/formatKeyPrice.js
var formatKeyPrice_default = async (keyPrice, erc20Address, decimals, provider) => {
  let actualAmount;
  if (decimals !== void 0 && decimals !== null) {
    actualAmount = utils_default.toDecimal(keyPrice, decimals);
  } else {
    if (erc20Address && erc20Address !== ZERO) {
      decimals = await getErc20Decimals(erc20Address, provider);
    } else {
      decimals = 18;
    }
    actualAmount = utils_default.toDecimal(keyPrice, decimals);
  }
  return actualAmount;
};

// src/PublicLock/utils/multiplePurchaseWrapper.js
async function multiplePurchaseWrapper_default(purchaseKey3, {
  lockAddress,
  erc20Address,
  decimals,
  owners = [],
  keyManagers = [],
  keyPrices = [],
  referrers = [],
  data = []
}, transactionOptions = {}, callback) {
  if (!erc20Address) {
    const lockContract = await this.getLockContract(lockAddress);
    erc20Address = await lockContract.tokenAddress();
    if (erc20Address !== ZERO) {
      const getPrice = async (price) => !price ? await lockContract.keyPrice() : await formatKeyPrice_default(price, erc20Address, decimals, this.provider);
      const prices = await Promise.all(
        (keyPrices.length === owners.length ? keyPrices : Array(owners.length).fill(null)).map((kp) => getPrice(kp))
      );
      const totalPrice = prices.reduce(
        (total, kp) => total.add(kp),
        utils_default.bigNumberify(0)
      );
      const approvedAmount = await getAllowance(
        erc20Address,
        lockAddress,
        this.provider,
        this.signer.getAddress()
      );
      if (!approvedAmount || approvedAmount.lt(totalPrice)) {
        await (await approveTransfer(
          erc20Address,
          lockAddress,
          totalPrice,
          this.provider,
          this.signer
        )).wait();
      }
    }
  }
  return Promise.all(
    owners.map(
      async (owner, i) => purchaseKey3.bind(this)(
        {
          lockAddress,
          owner,
          keyManager: keyManagers[i],
          keyPrice: keyPrices[i],
          referrer: referrers[i],
          data: data[i],
          erc20Address,
          decimals
        },
        transactionOptions,
        callback
      )
    )
  );
}

// src/PublicLock/v4/purchaseKeys.js
async function purchaseKeys_default(params, transactionOptions = {}, callback) {
  return await multiplePurchaseWrapper_default.bind(this)(
    purchaseKey_default,
    params,
    transactionOptions,
    callback
  );
}

// src/PublicLock/v4/grantKeys.js
async function grantKeys_default({ lockAddress, recipients, expirations }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  if (!expirations?.length) {
    const duration = await lockContract.expirationDuration();
    if (ETHERS_MAX_UINT.eq(duration)) {
      expirations = new Array(recipients.length).fill(ETHERS_MAX_UINT);
    } else {
      expirations = new Array(recipients.length).fill(
        Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3 + duration.toNumber())
      );
    }
  }
  if (recipients.length !== expirations.length) {
    throw new Error(
      "Number of recipients don't match the number of expirations provided"
    );
  }
  const grantKeysOptions = {};
  const transactionPromise = lockContract["grantKeys(address[],uint256[])"](
    recipients,
    expirations,
    grantKeysOptions
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  const parser = lockContract.interface;
  const transferEvents = receipt.logs.map((log) => {
    if (log.address.toLowerCase() !== lockAddress.toLowerCase())
      return;
    return parser.parseLog(log);
  }).filter((event) => {
    return event && event.name === "Transfer";
  });
  if (transferEvents.length) {
    return transferEvents.map((item) => item.args._tokenId.toString());
  }
  return null;
}

// src/PublicLock/v4/grantKey.js
async function grantKey_default({ lockAddress, recipient, expiration }, transactionOptions = {}, callback) {
  const events = await grantKeys_default.bind(this)(
    {
      lockAddress,
      recipients: [recipient],
      expirations: expiration ? [expiration] : []
    },
    transactionOptions,
    callback
  );
  if (events?.length) {
    return events[0];
  }
  return null;
}

// src/PublicLock/v4/updateKeyPrice.js
async function updateKeyPrice_default({ lockAddress, keyPrice, decimals, erc20Address }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  if (decimals == null) {
    if (!erc20Address) {
      erc20Address = await lockContract.tokenAddress();
    }
    if (erc20Address && erc20Address !== ZERO) {
      decimals = await getErc20Decimals(erc20Address, this.provider);
    } else {
      decimals = 18;
    }
  }
  const actualAmount = utils_default.toDecimal(keyPrice, decimals);
  const transactionPromise = lockContract["updateKeyPrice(uint256)"](actualAmount);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  const parser = lockContract.interface;
  const priceChangedEvent = receipt.logs.map((log) => {
    return parser.parseLog(log);
  }).filter((event) => {
    return event.signature === "PriceChanged(uint256,uint256)";
  })[0];
  if (priceChangedEvent) {
    return utils_default.fromDecimal(priceChangedEvent.args.keyPrice, decimals);
  }
  return null;
}

// src/PublicLock/v4/withdrawFromLock.js
async function withdrawFromLock_default({ lockAddress, amount = "0", decimals = 18 }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const actualAmount = utils_default.toDecimal(amount, decimals);
  const transactionPromise = lockContract["withdraw(uint256)"](actualAmount);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  const parser = lockContract.interface;
  const withdrawalEvent = receipt.logs.map((log) => {
    if (log.address.toLowerCase() !== lockAddress.toLowerCase())
      return;
    return parser.parseLog(log);
  }).filter((event) => {
    return event && event.name === "Withdrawal";
  })[0];
  if (withdrawalEvent) {
    return utils_default.fromWei(withdrawalEvent.args.amount.toString(), "ether");
  }
  return null;
}

// src/PublicLock/v4/isLockManager.js
async function isLockManager_default(lockAddres, userAddress, provider) {
  const lockContract = await this.getLockContract(lockAddres, provider);
  const owner = await lockContract.owner();
  return owner.toLowerCase() === userAddress.toLowerCase();
}

// src/PublicLock/v4/cancelAndRefund.js
async function cancelAndRefund_default({ lockAddress }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.cancelAndRefund();
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/utils/parseLockGetters.js
var attributes = {
  name: (x) => x,
  keyPrice: (x) => x,
  expirationDuration: (value) => {
    if (utils_default.isInfiniteDuration(value)) {
      return -1;
    }
    return parseInt(value, 10);
  },
  maxNumberOfKeys: (value) => {
    if (utils_default.isInfiniteKeys(value)) {
      return UNLIMITED_KEYS_COUNT;
    }
    return utils_default.toNumber(value);
  },
  maxKeysPerAddress: parseInt,
  beneficiary: (x) => x,
  totalSupply: parseInt,
  tokenAddress: (x) => x,
  publicLockVersion: parseInt,
  unlockProtocol: (x) => x
};
async function parseLockGetters_default(address, provider, { fields = [] } = {}) {
  const fieldItems = fields.map((f) => f.toLowerCase().trim()).concat(["unlockprotocol"]);
  const network = await provider.getNetwork();
  const networkConfig = this.networks?.[network.chainId];
  const contract = await this.getLockContract(address, provider);
  const getBlockNumber = async () => {
    const blockNumber = await provider.getBlockNumber();
    update.asOf = blockNumber;
  };
  const update = {};
  const constantPromises = Object.keys(attributes).filter((func) => Object.keys(contract).includes(func)).map(async (attribute) => {
    if (fields.length && !fieldItems.includes(attribute.toLowerCase().trim())) {
      return;
    }
    const result = await contract.functions[`${attribute}()`]();
    update[attribute] = attributes[attribute](result[0]);
  });
  constantPromises.push(getBlockNumber());
  await Promise.all(constantPromises);
  if (update.tokenAddress) {
    if (update.tokenAddress === ZERO) {
      if (update.keyPrice) {
        update.keyPrice = utils_default.fromWei(update.keyPrice, "ether");
      }
      const balance = await provider.getBalance(address);
      update.balance = utils_default.fromWei(balance, "ether");
      update.currencySymbol = networkConfig?.nativeCurrency?.symbol;
      update.currencyDecimals = networkConfig?.nativeCurrency?.decimals;
      update.currencyName = networkConfig?.nativeCurrency?.name;
    } else {
      const [erc20Decimals, erc20Balance, erc20Symbol] = await Promise.all([
        getErc20Decimals(update.tokenAddress, provider),
        getErc20BalanceForAddress(update.tokenAddress, address, provider),
        getErc20TokenSymbol(update.tokenAddress, provider)
      ]);
      if (update.keyPrice) {
        update.keyPrice = utils_default.fromDecimal(update.keyPrice, erc20Decimals);
      }
      update.balance = utils_default.fromDecimal(erc20Balance, erc20Decimals);
      update.currencySymbol = erc20Symbol;
      update.currencyDecimals = erc20Decimals;
      update.currencyName = erc20Symbol;
    }
  }
  update.outstandingKeys = update.totalSupply;
  delete update.totalSupply;
  if (update.tokenAddress === ZERO) {
    update.currencyContractAddress = null;
  } else {
    update.currencyContractAddress = update.tokenAddress;
  }
  delete update.tokenAddress;
  if (update.unlockProtocol) {
    update.unlockContractAddress = update.unlockProtocol;
    delete update.unlockProtocol;
  }
  return update;
}

// src/PublicLock/v4/getLock.js
async function getLock_default(address, provider, options = {}) {
  const update = await parseLockGetters_default.bind(this)(address, provider, options);
  return update;
}

// src/PublicLock/v4/getTokenIdForOwner.js
async function getTokenIdForOwner_default(lockAddress, owner, network) {
  const lockContract = await this.getLockContract(
    lockAddress,
    this.providerForNetwork(network)
  );
  try {
    const tokenId = await lockContract.getTokenIdFor(owner);
    return parseInt(tokenId, 10);
  } catch (error) {
    return 0;
  }
}

// src/PublicLock/v4/getKeyExpirationByLockForOwner.js
async function getKeyExpirationByLockForOwner_default(lockAddress, owner, network) {
  const lockContract = await this.getLockContract(
    lockAddress,
    this.providerForNetwork(network)
  );
  if (await lockContract.publicLockVersion() > 10) {
    throw new Error("Only available until Lock v10");
  }
  try {
    const expiration = await lockContract.keyExpirationTimestampFor(owner);
    if (expiration == "3963877391197344453575983046348115674221700746820753546331534351508065746944") {
      return 0;
    }
    if (expiration.eq(ETHERS_MAX_UINT)) {
      return -1;
    }
    return parseInt(expiration, 10);
  } catch (error) {
    return 0;
  }
}

// src/PublicLock/v4/totalKeys.js
async function totalKeys_default(lockAddres, owner, provider) {
  const lockContract = await this.getLockContract(lockAddres, provider);
  return lockContract.balanceOf(owner);
}

// src/PublicLock/v4/updateLockName.js
async function updateLockName_default({ lockAddress, name: name2 }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress, this.provider);
  const transactionPromise = lockContract.updateLockName(name2);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
  return name2;
}

// src/PublicLock/v4/updateLockSymbol.js
async function updateLockSymbol_default({ lockAddress, symbol }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress, this.provider);
  const transactionPromise = lockContract.updateLockSymbol(symbol);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
  return symbol;
}

// src/PublicLock/v4/setBaseTokenURI.js
async function setBaseTokenURI_default({ lockAddress, baseTokenURI }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress, this.provider);
  const transactionPromise = lockContract.setBaseTokenURI(baseTokenURI);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
  return baseTokenURI;
}

// src/PublicLock/v4/updateRefundPenalty.js
async function updateRefundPenalty_default({ lockAddress, freeTrialLength, refundPenaltyBasisPoints }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress, this.provider);
  const transactionPromise = lockContract.updateRefundPenalty(
    freeTrialLength,
    refundPenaltyBasisPoints
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
  return name;
}

// src/PublicLock/v4/getPurchaseKeysArguments.js
async function getPurchaseKeysArguments({
  lockAddress,
  erc20Address,
  decimals,
  owners = [],
  keyManagers = [],
  keyPrices = [],
  referrers = [],
  data = []
}) {
  const lockContract = await this.getLockContract(lockAddress);
  erc20Address = await lockContract.tokenAddress();
  const getPrice = async (price) => !price ? await lockContract.keyPrice() : await formatKeyPrice_default(price, erc20Address, decimals, this.provider);
  const prices = await Promise.all(
    (keyPrices.length === owners.length ? keyPrices : Array(owners.length).fill(null)).map((kp) => getPrice(kp))
  );
  const totalPrice = prices.reduce(
    (total, kp) => total.add(kp),
    utils_default.bigNumberify(0)
  );
  const items = owners.map((owner, i) => {
    return {
      lockAddress,
      owner,
      keyManager: keyManagers[i],
      keyPrice: keyPrices[i],
      referrer: referrers[i],
      data: data[i],
      erc20Address,
      decimals
    };
  });
  return {
    items,
    totalPrice,
    erc20Address,
    totalAmountToApprove: totalPrice
  };
}

// src/PublicLock/v4/index.js
var v4_default = {
  getPurchaseKeysArguments,
  purchaseKey: purchaseKey_default,
  purchaseKeys: purchaseKeys_default,
  grantKey: grantKey_default,
  grantKeys: grantKeys_default,
  updateKeyPrice: updateKeyPrice_default,
  getLock: getLock_default,
  withdrawFromLock: withdrawFromLock_default,
  isLockManager: isLockManager_default,
  version: "v4",
  Unlock: abis_default.Unlock.v4,
  PublicLock: abis_default.PublicLock.v4,
  cancelAndRefund: cancelAndRefund_default,
  getTokenIdForOwner: getTokenIdForOwner_default,
  getKeyExpirationByLockForOwner: getKeyExpirationByLockForOwner_default,
  totalKeys: totalKeys_default,
  updateLockName: updateLockName_default,
  updateLockSymbol: updateLockSymbol_default,
  setBaseTokenURI: setBaseTokenURI_default,
  updateRefundPenalty: updateRefundPenalty_default
};

// src/PublicLock/v6/purchaseKey.js
async function purchaseKey_default2({
  lockAddress,
  owner,
  keyPrice,
  erc20Address,
  decimals,
  referrer,
  data,
  swap
}, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const unlockSwapPurchaserContract = swap ? this.getUnlockSwapPurchaserContract({
    params: {
      network: this.networkId
    }
  }) : null;
  if (!owner) {
    owner = await this.signer.getAddress();
  }
  if (!referrer) {
    referrer = ZERO;
  }
  if (!data) {
    data = [];
  }
  if (!erc20Address) {
    erc20Address = await lockContract.tokenAddress();
  }
  let actualAmount;
  if (!keyPrice) {
    actualAmount = await lockContract.keyPrice();
  } else if (decimals !== void 0 && decimals !== null) {
    actualAmount = utils_default.toDecimal(keyPrice, decimals);
  } else {
    if (erc20Address && erc20Address !== ZERO) {
      decimals = await getErc20Decimals(erc20Address, this.provider);
    } else {
      decimals = 18;
    }
    actualAmount = utils_default.toDecimal(keyPrice, decimals);
  }
  const purchaseArgs = [actualAmount, owner, referrer, data];
  const callData = lockContract.interface.encodeFunctionData(
    "purchase",
    purchaseArgs
  );
  if (!erc20Address || erc20Address === ZERO) {
    transactionOptions.value = actualAmount;
  }
  if (swap && swap?.value) {
    transactionOptions.value = swap.value;
  }
  const approvalOptions = swap ? {
    erc20Address: swap.srcTokenAddress,
    address: unlockSwapPurchaserContract?.address,
    totalAmountToApprove: swap.amountInMax
  } : {
    erc20Address,
    address: lockAddress,
    totalAmountToApprove: actualAmount
  };
  if (approvalOptions.erc20Address && approvalOptions.erc20Address !== ZERO) {
    await approveAllowance.bind(this)(approvalOptions);
  }
  if (!transactionOptions.gasLimit) {
    try {
      const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = await this.provider.getFeeData();
      if (maxFeePerGas && maxPriorityFeePerGas) {
        transactionOptions.maxFeePerGas = maxFeePerGas;
        transactionOptions.maxPriorityFeePerGas = maxPriorityFeePerGas;
      } else {
        transactionOptions.gasPrice = gasPrice;
      }
      const gasLimitPromise = swap ? unlockSwapPurchaserContract?.estimateGas?.swapAndCall(
        lockAddress,
        swap.srcTokenAddress || ZERO,
        swap.amountInMax,
        swap.uniswapRouter,
        swap.swapCallData,
        callData,
        transactionOptions
      ) : lockContract.estimateGas.purchase(
        actualAmount,
        owner,
        referrer,
        data,
        transactionOptions
      );
      const gasLimit = await gasLimitPromise;
      delete transactionOptions.maxFeePerGas;
      delete transactionOptions.maxPriorityFeePerGas;
      delete transactionOptions.gasPrice;
      transactionOptions.gasLimit = gasLimit.mul(13).div(10).toNumber();
    } catch (error) {
      console.error(
        "We could not estimate gas ourselves. Let wallet do it.",
        error
      );
      delete transactionOptions.maxFeePerGas;
      delete transactionOptions.maxPriorityFeePerGas;
      delete transactionOptions.gasPrice;
    }
  }
  const transactionPromise = swap ? unlockSwapPurchaserContract?.swapAndCall(
    lockAddress,
    swap.srcTokenAddress || ZERO,
    swap.amountInMax,
    swap.uniswapRouter,
    swap.swapCallData,
    callData,
    transactionOptions
  ) : lockContract.purchase(
    actualAmount,
    owner,
    referrer,
    data,
    transactionOptions
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  if (receipt.status === 0) {
    throw new Error("Transaction failed");
  }
  const parser = lockContract.interface;
  const transferEvent = receipt.logs.map((log) => {
    if (log.address.toLowerCase() !== lockAddress.toLowerCase())
      return;
    return parser.parseLog(log);
  }).filter((event) => {
    return event && event.name === "Transfer";
  })[0];
  if (transferEvent) {
    return transferEvent.args.tokenId.toString();
  }
  return null;
}

// src/PublicLock/v6/purchaseKeys.js
async function purchaseKeys_default2(params, transactionOptions = {}, callback) {
  return await multiplePurchaseWrapper_default.bind(this)(
    purchaseKey_default2,
    params,
    transactionOptions,
    callback
  );
}

// src/PublicLock/v6/grantKeys.js
async function grantKeys_default2({ lockAddress, recipients, expirations }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  if (!expirations?.length) {
    const duration = await lockContract.expirationDuration();
    if (ETHERS_MAX_UINT.eq(duration)) {
      expirations = new Array(recipients.length).fill(ETHERS_MAX_UINT);
    } else {
      expirations = new Array(recipients.length).fill(
        Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3 + duration.toNumber())
      );
    }
  }
  if (recipients.length !== expirations.length) {
    throw new Error(
      "Number of recipients don't match the number of expirations provided"
    );
  }
  const transactionPromise = lockContract.grantKeys(
    recipients,
    expirations,
    transactionOptions || {}
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  const parser = lockContract.interface;
  const transferEvents = receipt.logs.map((log) => {
    if (log.address.toLowerCase() !== lockAddress.toLowerCase())
      return;
    return parser.parseLog(log);
  }).filter((event) => {
    return event && event.name === "Transfer";
  });
  if (transferEvents.length) {
    return transferEvents.map((item) => item.args.tokenId.toString());
  }
  return null;
}

// src/PublicLock/v6/grantKey.js
async function grantKey_default2({ lockAddress, recipient, expiration }, transactionOptions = {}, callback) {
  const events = await grantKeys_default2.bind(this)(
    {
      lockAddress,
      recipients: [recipient],
      expirations: expiration ? [expiration] : []
    },
    transactionOptions,
    callback
  );
  if (events?.length) {
    return events[0];
  }
  return null;
}

// src/PublicLock/v6/updateKeyPrice.js
async function updateKeyPrice_default2({ lockAddress, keyPrice, decimals, erc20Address }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  if (!erc20Address) {
    erc20Address = await lockContract.tokenAddress();
  }
  if (decimals == null) {
    if (erc20Address !== ZERO) {
      decimals = await getErc20Decimals(erc20Address, this.provider);
    } else {
      decimals = 18;
    }
  }
  const actualAmount = utils_default.toDecimal(keyPrice, decimals);
  const transactionPromise = lockContract.updateKeyPricing(
    actualAmount,
    erc20Address || ZERO
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  const parser = lockContract.interface;
  const priceChangedEvent = receipt.logs.map((log) => {
    return parser.parseLog(log);
  }).filter((event) => {
    return event.name === "PricingChanged";
  })[0];
  if (priceChangedEvent) {
    return utils_default.fromDecimal(priceChangedEvent.args.keyPrice, decimals);
  }
  return null;
}

// src/PublicLock/v6/withdrawFromLock.js
async function withdrawFromLock_default2({ erc20Address, lockAddress, amount = "0", decimals }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  if (!erc20Address || erc20Address !== ZERO) {
    erc20Address = await lockContract.tokenAddress();
  }
  if (decimals == null) {
    if (erc20Address !== ZERO) {
      decimals = await getErc20Decimals(erc20Address, this.provider);
    } else {
      decimals = 18;
    }
  }
  const actualAmount = utils_default.toDecimal(amount, decimals);
  const transactionPromise = lockContract.withdraw(erc20Address, actualAmount);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  const parser = lockContract.interface;
  const withdrawalEvent = receipt.logs.map((log) => {
    if (log.address.toLowerCase() !== lockAddress.toLowerCase())
      return;
    return parser.parseLog(log);
  }).filter((event) => {
    return event && event.name === "Withdrawal";
  })[0];
  if (withdrawalEvent) {
    return utils_default.fromWei(withdrawalEvent.args.amount.toString(), "ether");
  }
  return null;
}

// src/PublicLock/v6/initializeTemplate.js
async function initializeTemplate_default({ templateAddress }, transactionOptions = {}, callback) {
  const owner = await this.signer.getAddress();
  const expirationDuration = 0;
  const tokenAddress = ZERO;
  const keyPrice = 0;
  const maxNumberOfKeys = 0;
  const lockName = "Public Lock Template";
  const contract = await this.getLockContract(templateAddress);
  const initializeTransaction = await contract.initialize(
    owner,
    expirationDuration,
    tokenAddress,
    keyPrice,
    maxNumberOfKeys,
    lockName
  );
  if (callback) {
    callback(null, initializeTransaction.hash);
  }
  await this.provider.waitForTransaction(initializeTransaction.hash);
}

// src/PublicLock/v6/isLockManager.js
async function isLockManager_default2(lockAddres, userAddress, provider) {
  const lockContract = await this.getLockContract(lockAddres, provider);
  const owner = await lockContract.owner();
  return owner.toLowerCase() === userAddress.toLowerCase();
}

// src/PublicLock/v6/cancelAndRefund.js
async function cancelAndRefund_default2({ lockAddress }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.cancelAndRefund();
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/v6/shareKey.js
async function shareKey_default({ lockAddress, tokenId, recipient, duration }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  if (!tokenId) {
    const owner = await this.signer.getAddress();
    tokenId = await lockContract.getTokenIdFor(owner);
  }
  if (!duration) {
    const keyOwner = await lockContract.ownerOf(tokenId);
    const expiration = await lockContract.keyExpirationTimestampFor(keyOwner);
    duration = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3) - expiration.toNumber();
  }
  const transactionPromise = lockContract.shareKey(
    recipient,
    tokenId,
    duration,
    transactionOptions
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  return await this.provider.waitForTransaction(hash);
}

// src/PublicLock/v6/getLock.js
async function getLock_default2(address, provider, options = {}) {
  const update = await parseLockGetters_default.bind(this)(address, provider, options);
  return update;
}

// src/PublicLock/v6/addLockManager.js
async function addLockManager_default({ lockAddress, userAddress }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.addLockManager(userAddress);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/v6/renounceLockManager.js
async function renounceLockManager_default({ lockAddress }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.renounceLockManager();
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/v6/updateTransferFee.js
async function updateTransferFee_default({ lockAddress, transferFeeBasisPoints }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.updateTransferFee(
    transferFeeBasisPoints
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/v6/index.js
var {
  getTokenIdForOwner,
  getKeyExpirationByLockForOwner,
  totalKeys,
  setBaseTokenURI,
  updateLockName,
  updateLockSymbol,
  updateRefundPenalty
} = v4_default;
var v6_default = {
  version: "v6",
  Unlock: abis_default.Unlock.v6,
  PublicLock: abis_default.PublicLock.v6,
  initializeTemplate: initializeTemplate_default,
  updateKeyPrice: updateKeyPrice_default2,
  purchaseKey: purchaseKey_default2,
  purchaseKeys: purchaseKeys_default2,
  getLock: getLock_default2,
  grantKey: grantKey_default2,
  grantKeys: grantKeys_default2,
  withdrawFromLock: withdrawFromLock_default2,
  isLockManager: isLockManager_default2,
  cancelAndRefund: cancelAndRefund_default2,
  shareKey: shareKey_default,
  getTokenIdForOwner,
  getKeyExpirationByLockForOwner,
  totalKeys,
  updateLockName,
  updateLockSymbol,
  setBaseTokenURI,
  addLockManager: addLockManager_default,
  renounceLockManager: renounceLockManager_default,
  updateRefundPenalty,
  updateTransferFee: updateTransferFee_default
};

// src/PublicLock/v7/grantKeys.js
async function grantKeys_default3({ lockAddress, recipients, expirations, keyManagers }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  if (!expirations?.length) {
    const duration = await lockContract.expirationDuration();
    if (ETHERS_MAX_UINT.eq(duration)) {
      expirations = new Array(recipients.length).fill(ETHERS_MAX_UINT);
    } else {
      expirations = new Array(recipients.length).fill(
        Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3 + duration.toNumber())
      );
    }
  }
  if (!keyManagers?.length) {
    const signer = this.signer;
    const manager = await signer.getAddress();
    keyManagers = new Array(recipients.length).fill(manager);
  }
  if (recipients.length !== expirations.length) {
    throw new Error(
      "Number of recipients don't match the number of expirations provided"
    );
  }
  if (recipients.length !== keyManagers.length) {
    throw new Error(
      "Number of recipients don't match the number of keyManagers provided"
    );
  }
  const transactionPromise = lockContract.grantKeys(
    recipients,
    expirations,
    keyManagers,
    transactionOptions || {}
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  const parser = lockContract.interface;
  const transferEvents = receipt.logs.map((log) => {
    if (log.address.toLowerCase() !== lockAddress.toLowerCase())
      return;
    return parser.parseLog(log);
  }).filter((event) => {
    return event && event.name === "Transfer";
  });
  if (transferEvents.length) {
    return transferEvents.map((item) => {
      return {
        id: item.args.tokenId.toString(),
        owner: item.args.to.toString()
      };
    });
  }
  return null;
}

// src/PublicLock/v7/grantKey.js
async function grantKey_default3({ lockAddress, recipient, expiration, keyManager }, transactionOptions = {}, callback) {
  const events = await grantKeys_default3.bind(this)(
    {
      lockAddress,
      recipients: [recipient],
      expirations: expiration ? [expiration] : [],
      keyManagers: keyManager ? [keyManager] : []
    },
    transactionOptions,
    callback
  );
  if (events?.length) {
    return events[0];
  }
  return null;
}

// src/PublicLock/v7/isLockManager.js
async function isLockManager_default3(lockAddres, userAddress, provider) {
  const lockContract = await this.getLockContract(lockAddres, provider);
  return lockContract.isLockManager(userAddress);
}

// src/PublicLock/v7/isKeyGranter.js
async function isKeyGranter_default(lockAddress, address, provider) {
  const lockContract = await this.getLockContract(lockAddress, provider);
  return lockContract.isKeyGranter(address);
}

// src/PublicLock/v7/addKeyGranter.js
async function addKeyGranter_default({ lockAddress, keyGranter }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.addKeyGranter(keyGranter);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
  return true;
}

// src/PublicLock/v7/expireAndRefundFor.js
async function expireAndRefundFor_default({ lockAddress, keyOwner, amount = "0", decimals, erc20Address }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  if (!erc20Address || erc20Address !== ZERO) {
    erc20Address = await lockContract.tokenAddress();
  }
  if (decimals == null) {
    if (erc20Address !== ZERO) {
      decimals = await getErc20Decimals(erc20Address, this.provider);
    } else {
      decimals = 18;
    }
  }
  const actualAmount = utils_default.toDecimal(amount, decimals);
  const transactionPromise = lockContract.expireAndRefundFor(
    keyOwner,
    actualAmount
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/v7/cancelAndRefund.js
async function cancelAndRefund_default3({ lockAddress, tokenId }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  if (!tokenId) {
    const owner = await this.signer.getAddress();
    tokenId = await lockContract.getTokenIdFor(owner);
  }
  const transactionPromise = lockContract.cancelAndRefund(tokenId);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/v7/keyManagerOf.js
async function keyManagerOf_default(lockAddres, tokenId, provider) {
  const lockContract = await this.getLockContract(lockAddres, provider);
  return lockContract.keyManagerOf(tokenId);
}

// src/PublicLock/v7/getCancelAndRefundValueFor.js
async function getCancelAndRefundValueFor({ lockAddress, owner, tokenAddress }, transactionOptions = {}, provider) {
  const lockContract = await this.getLockContract(lockAddress, provider);
  const value = await lockContract.getCancelAndRefundValueFor(owner);
  let refundValue;
  if (tokenAddress === ZERO) {
    refundValue = utils_default.fromWei(value, "ether");
  } else {
    refundValue = await getErc20Decimals(tokenAddress, this.provider);
  }
  return refundValue;
}
var getCancelAndRefundValueFor_default = getCancelAndRefundValueFor;

// src/PublicLock/v7/setEventHooks.js
async function setEventHooks_default({ lockAddress, keyPurchase = ZERO, keyCancel = ZERO }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.setEventHooks(keyPurchase, keyCancel);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/v7/setKeyManagerOf.js
async function setKeyManagerOf_default({ lockAddress, managerAddress, tokenId }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.setKeyManagerOf(
    tokenId,
    managerAddress
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  const tx = await this.provider.waitForTransaction(hash);
  return tx;
}

// src/PublicLock/v7/index.js
var {
  shareKey,
  initializeTemplate,
  withdrawFromLock,
  updateKeyPrice,
  purchaseKey,
  purchaseKeys,
  getLock,
  getTokenIdForOwner: getTokenIdForOwner2,
  getKeyExpirationByLockForOwner: getKeyExpirationByLockForOwner2,
  totalKeys: totalKeys2,
  updateLockName: updateLockName2,
  updateLockSymbol: updateLockSymbol2,
  setBaseTokenURI: setBaseTokenURI2,
  addLockManager,
  renounceLockManager,
  updateRefundPenalty: updateRefundPenalty2,
  updateTransferFee
} = v6_default;
var v7_default = {
  version: "v7",
  Unlock: abis_default.Unlock.v7,
  PublicLock: abis_default.PublicLock.v7,
  initializeTemplate,
  updateKeyPrice,
  purchaseKey,
  purchaseKeys,
  getLock,
  grantKey: grantKey_default3,
  grantKeys: grantKeys_default3,
  withdrawFromLock,
  isLockManager: isLockManager_default3,
  isKeyGranter: isKeyGranter_default,
  addKeyGranter: addKeyGranter_default,
  expireAndRefundFor: expireAndRefundFor_default,
  cancelAndRefund: cancelAndRefund_default3,
  shareKey,
  keyManagerOf: keyManagerOf_default,
  getCancelAndRefundValueFor: getCancelAndRefundValueFor_default,
  getTokenIdForOwner: getTokenIdForOwner2,
  getKeyExpirationByLockForOwner: getKeyExpirationByLockForOwner2,
  totalKeys: totalKeys2,
  updateLockName: updateLockName2,
  updateLockSymbol: updateLockSymbol2,
  setBaseTokenURI: setBaseTokenURI2,
  addLockManager,
  renounceLockManager,
  updateRefundPenalty: updateRefundPenalty2,
  setEventHooks: setEventHooks_default,
  updateTransferFee,
  setKeyManagerOf: setKeyManagerOf_default
};

// src/PublicLock/v8/keyManagerOf.js
async function keyManagerOf_default2(lockAddres, tokenId, provider) {
  const lockContract = await this.getLockContract(lockAddres, provider);
  return lockContract.keyManagerOf(tokenId);
}

// src/PublicLock/v8/approveBeneficiary.js
async function approveBeneficiary_default({ lockAddress, spender, amount = "0", decimals, erc20Address }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  if (!erc20Address || erc20Address !== ZERO) {
    erc20Address = await lockContract.tokenAddress();
  }
  if (erc20Address === ZERO) {
    throw new Error("Lock can only set approval for ERC20");
  }
  let actualAmount;
  if (amount !== MAX_UINT) {
    if (decimals == null) {
      decimals = await getErc20Decimals(erc20Address, this.provider);
    }
    actualAmount = utils_default.toDecimal(amount, decimals);
  } else {
    actualAmount = amount;
  }
  const transactionPromise = lockContract.approveBeneficiary(
    spender,
    actualAmount
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/v8/index.js
var {
  grantKey,
  grantKeys,
  updateKeyPrice: updateKeyPrice2,
  withdrawFromLock: withdrawFromLock2,
  initializeTemplate: initializeTemplate2,
  isLockManager,
  isKeyGranter,
  addKeyGranter,
  expireAndRefundFor,
  cancelAndRefund,
  shareKey: shareKey2,
  getLock: getLock2,
  purchaseKey: purchaseKey2,
  purchaseKeys: purchaseKeys2,
  getCancelAndRefundValueFor: getCancelAndRefundValueFor2,
  getTokenIdForOwner: getTokenIdForOwner3,
  getKeyExpirationByLockForOwner: getKeyExpirationByLockForOwner3,
  totalKeys: totalKeys3,
  updateLockName: updateLockName3,
  updateLockSymbol: updateLockSymbol3,
  setBaseTokenURI: setBaseTokenURI3,
  addLockManager: addLockManager2,
  renounceLockManager: renounceLockManager2,
  updateRefundPenalty: updateRefundPenalty3,
  setEventHooks,
  updateTransferFee: updateTransferFee2,
  setKeyManagerOf
} = v7_default;
var v8_default = {
  version: "v8",
  Unlock: abis_default.Unlock.v8,
  PublicLock: abis_default.PublicLock.v8,
  initializeTemplate: initializeTemplate2,
  updateKeyPrice: updateKeyPrice2,
  purchaseKey: purchaseKey2,
  purchaseKeys: purchaseKeys2,
  grantKey,
  grantKeys,
  getLock: getLock2,
  withdrawFromLock: withdrawFromLock2,
  isLockManager,
  isKeyGranter,
  addKeyGranter,
  expireAndRefundFor,
  cancelAndRefund,
  shareKey: shareKey2,
  keyManagerOf: keyManagerOf_default2,
  getCancelAndRefundValueFor: getCancelAndRefundValueFor2,
  getTokenIdForOwner: getTokenIdForOwner3,
  getKeyExpirationByLockForOwner: getKeyExpirationByLockForOwner3,
  approveBeneficiary: approveBeneficiary_default,
  totalKeys: totalKeys3,
  updateLockName: updateLockName3,
  updateLockSymbol: updateLockSymbol3,
  setBaseTokenURI: setBaseTokenURI3,
  addLockManager: addLockManager2,
  renounceLockManager: renounceLockManager2,
  updateRefundPenalty: updateRefundPenalty3,
  setEventHooks,
  updateTransferFee: updateTransferFee2,
  setKeyManagerOf
};

// src/PublicLock/v9/purchaseKey.js
async function purchaseKey_default3({
  lockAddress,
  owner,
  keyManager,
  keyPrice,
  erc20Address,
  decimals,
  referrer,
  data,
  swap
}, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const unlockSwapPurchaserContract = swap ? this.getUnlockSwapPurchaserContract({
    params: {
      network: this.networkId
    }
  }) : null;
  if (!owner) {
    owner = await this.signer.getAddress();
  }
  if (!referrer) {
    referrer = ZERO;
  }
  if (!keyManager) {
    keyManager = ZERO;
  }
  if (!data) {
    data = [];
  }
  if (!erc20Address) {
    erc20Address = await lockContract.tokenAddress();
  }
  let actualAmount;
  if (!keyPrice) {
    actualAmount = await lockContract.keyPrice();
  } else {
    actualAmount = await formatKeyPrice_default(
      keyPrice,
      erc20Address,
      decimals,
      this.provider
    );
  }
  const purchaseArgs = [actualAmount, owner, referrer, keyManager, data];
  const callData = lockContract.interface.encodeFunctionData(
    "purchase",
    purchaseArgs
  );
  if (!erc20Address || erc20Address === ZERO) {
    transactionOptions.value = actualAmount;
  }
  if (swap && swap?.value) {
    transactionOptions.value = swap.value;
  }
  const approvalOptions = swap ? {
    erc20Address: swap.srcTokenAddress,
    address: unlockSwapPurchaserContract?.address,
    totalAmountToApprove: swap.amountInMax
  } : {
    erc20Address,
    totalAmountToApprove: actualAmount,
    address: lockAddress
  };
  if (approvalOptions.erc20Address && approvalOptions.erc20Address !== ZERO) {
    await approveAllowance.bind(this)(approvalOptions);
  }
  if (!transactionOptions.gasLimit) {
    try {
      const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = await this.provider.getFeeData();
      if (maxFeePerGas && maxPriorityFeePerGas) {
        transactionOptions.maxFeePerGas = maxFeePerGas;
        transactionOptions.maxPriorityFeePerGas = maxPriorityFeePerGas;
      } else {
        transactionOptions.gasPrice = gasPrice;
      }
      const gasLimitPromise = swap ? unlockSwapPurchaserContract?.estimateGas?.swapAndCall(
        lockAddress,
        swap.srcTokenAddress || ZERO,
        swap.amountInMax,
        swap.uniswapRouter,
        swap.swapCallData,
        callData,
        transactionOptions
      ) : lockContract.estimateGas.purchase(
        actualAmount,
        owner,
        referrer,
        keyManager,
        data,
        transactionOptions
      );
      const gasLimit = await gasLimitPromise;
      delete transactionOptions.maxFeePerGas;
      delete transactionOptions.maxPriorityFeePerGas;
      delete transactionOptions.gasPrice;
      transactionOptions.gasLimit = gasLimit.mul(13).div(10).toNumber();
    } catch (error) {
      console.error(
        "We could not estimate gas ourselves. Let wallet do it.",
        error
      );
      delete transactionOptions.maxFeePerGas;
      delete transactionOptions.maxPriorityFeePerGas;
      delete transactionOptions.gasPrice;
    }
  }
  const transactionRequestPromise = swap ? unlockSwapPurchaserContract?.swapAndCall(
    lockAddress,
    swap.srcTokenAddress || ZERO,
    swap.amountInMax,
    swap.uniswapRouter,
    swap.swapCallData,
    callData,
    transactionOptions
  ) : lockContract.purchase(
    actualAmount,
    owner,
    referrer,
    keyManager,
    data,
    transactionOptions
  );
  const hash = await this._handleMethodCall(transactionRequestPromise);
  if (callback) {
    callback(null, hash, await transactionRequestPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  if (receipt.status === 0) {
    throw new Error("Transaction failed");
  }
  const parser = lockContract.interface;
  const transferEvent = receipt.logs.map((log) => {
    if (log.address.toLowerCase() !== lockAddress.toLowerCase())
      return;
    return parser.parseLog(log);
  }).filter((event) => {
    return event && event.name === "Transfer";
  })[0];
  if (transferEvent) {
    return transferEvent.args.tokenId.toString();
  }
  return null;
}

// src/PublicLock/v9/purchaseKeys.js
async function purchaseKeys_default3(params, transactionOptions = {}, callback) {
  return await multiplePurchaseWrapper_default.bind(this)(
    purchaseKey_default3,
    params,
    transactionOptions,
    callback
  );
}

// src/PublicLock/v9/setMaxNumberOfKeys.js
async function setMaxNumberOfKeys({ lockAddress, maxNumberOfKeys }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.setMaxNumberOfKeys(maxNumberOfKeys);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
}
var setMaxNumberOfKeys_default = setMaxNumberOfKeys;

// src/PublicLock/v9/setExpirationDuration.js
async function setExpirationDuration({ lockAddress, expirationDuration }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.setExpirationDuration(expirationDuration);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
}
var setExpirationDuration_default = setExpirationDuration;

// src/PublicLock/v9/setEventHooks.js
async function setEventHooks_default2({
  lockAddress,
  keyPurchase = ZERO,
  keyCancel = ZERO,
  validKey = ZERO,
  tokenURI = ZERO
}, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.setEventHooks(
    keyPurchase,
    keyCancel,
    validKey,
    tokenURI
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/v9/transferFrom.js
async function transferFrom_default({ lockAddress, keyOwner, to, tokenId }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.transferFrom(keyOwner, to, tokenId);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  const tx = await this.provider.waitForTransaction(hash);
  return tx;
}

// ../networks/dist/index.mjs
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_unlockTypes = __commonJS({
  "../types/dist/types/unlockTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyStatus = exports.HooksName = exports.HookType = exports.TransactionStatus = exports.TransactionType = void 0;
    var TransactionType;
    (function(TransactionType2) {
      TransactionType2["LOCK_CREATION"] = "LOCK_CREATION";
      TransactionType2["KEY_PURCHASE"] = "KEY_PURCHASE";
      TransactionType2["WITHDRAWAL"] = "WITHDRAWAL";
      TransactionType2["UPDATE_KEY_PRICE"] = "UPDATE_KEY_PRICE";
    })(TransactionType = exports.TransactionType || (exports.TransactionType = {}));
    var TransactionStatus;
    (function(TransactionStatus2) {
      TransactionStatus2["SUBMITTED"] = "submitted";
      TransactionStatus2["PENDING"] = "pending";
      TransactionStatus2["MINED"] = "mined";
      TransactionStatus2["STALE"] = "stale";
      TransactionStatus2["FAILED"] = "failed";
      TransactionStatus2["NONE"] = "";
    })(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));
    var HookType12;
    (function(HookType13) {
      HookType13["CUSTOM_CONTRACT"] = "CUSTOM_CONTRACT";
      HookType13["PASSWORD"] = "PASSWORD";
      HookType13["PROMOCODE"] = "PROMOCODE";
      HookType13["CAPTCHA"] = "CAPTCHA";
      HookType13["GUILD"] = "GUILD";
    })(HookType12 = exports.HookType || (exports.HookType = {}));
    exports.HooksName = [
      "onKeyPurchaseHook",
      "onKeyCancelHook",
      "onValidKeyHook",
      "onTokenURIHook",
      "onKeyTransferHook",
      "onKeyExtendHook",
      "onKeyGrantHook"
    ];
    var KeyStatus;
    (function(KeyStatus2) {
      KeyStatus2["NONE"] = "none";
      KeyStatus2["CONFIRMING"] = "confirming";
      KeyStatus2["CONFIRMED"] = "confirmed";
      KeyStatus2["EXPIRED"] = "expired";
      KeyStatus2["VALID"] = "valid";
      KeyStatus2["SUBMITTED"] = "submitted";
      KeyStatus2["PENDING"] = "pending";
      KeyStatus2["FAILED"] = "failed";
    })(KeyStatus = exports.KeyStatus || (exports.KeyStatus = {}));
  }
});
var require_dist = __commonJS({
  "../types/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_unlockTypes(), exports);
  }
});
var networks_exports = {};
__export(networks_exports, {
  arbitrum: () => arbitrum,
  avalanche: () => avalanche,
  base: () => base,
  baseGoerli: () => baseGoerli,
  bsc: () => bsc,
  celo: () => celo,
  gnosis: () => gnosis,
  goerli: () => goerli,
  localhost: () => localhost,
  mainnet: () => mainnet,
  mumbai: () => mumbai,
  optimism: () => optimism,
  palm: () => palm,
  polygon: () => polygon,
  sepolia: () => sepolia
});
var localhost = {
  chain: "localhost",
  description: "Localhost network.",
  featured: false,
  fullySubsidizedGas: true,
  id: 31337,
  isTestNetwork: true,
  name: "localhost",
  nativeCurrency: {
    coingecko: "ethereum",
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  provider: "http://127.0.0.1:8545",
  publicLockVersionToDeploy: 13,
  publicProvider: "http://127.0.0.1:8545",
  subgraph: {
    endpoint: "http://localhost:8000/subgraphs/name/unlock-protocol/unlock",
    endpointV2: "http://localhost:8000/subgraphs/name/testgraph"
  }
};
var import_types = __toESM(require_dist());
var mainnet = {
  blockScan: {
    url: (address) => `https://blockscan.com/address/${address}`
  },
  chain: "ethereum",
  description: "The original and most secure EVM network. Gas fees are expensive on this network.",
  explorer: {
    name: "Etherscan",
    urls: {
      address: (address) => `https://etherscan.io/address/${address}`,
      base: "https://etherscan.io/",
      token: (address, holder) => `https://etherscan.com/token/${address}?a=${holder}`,
      transaction: (hash) => `https://etherscan.io/tx/${hash}`
    }
  },
  featured: true,
  governanceBridge: {
    connext: "0x8898B472C54c31894e3B9bb83cEA802a5d0e63C6",
    domainId: 6648936
  },
  hooks: {
    onKeyPurchaseHook: [
      {
        address: "0x936Ed3E71b5990bC9A94074835D08C6ca7bbFad0",
        id: import_types.HookType.PASSWORD,
        name: "Password required"
      },
      {
        address: "0xaF96721f8ffc136e4C170446E68Dc6744B6Ee4f4",
        id: import_types.HookType.CAPTCHA,
        name: "Captcha"
      },
      {
        address: "0x1d8DD27432cC0aCB93B93c4486F46b67E2208359",
        id: import_types.HookType.GUILD,
        name: "Guild"
      }
    ]
  },
  id: 1,
  isTestNetwork: false,
  keyManagerAddress: "0x9A1f43090307034DBFBE2ba20320Ce815ff046D4",
  maxFreeClaimCost: 1,
  multisig: "0x9168EABE624e9515f3836bA1716EC1DDd4C461D4",
  name: "Ethereum",
  nativeCurrency: {
    coingecko: "ethereum",
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  opensea: {
    collectionUrl: (lockAddress) => `https://opensea.io/assets/${lockAddress}`,
    profileUrl: (address) => `https://opensea.io/${address}`,
    tokenUrl: (lockAddress, tokenId) => `https://opensea.io/assets/${lockAddress}/${tokenId}`
  },
  previousDeploys: [
    {
      startBlock: 7120795,
      unlockAddress: "0x3d5409CcE1d45233dE1D4eBDEe74b8E004abDD13"
    }
  ],
  provider: "https://rpc.unlock-protocol.com/1",
  publicLockVersionToDeploy: 13,
  publicProvider: "https://cloudflare-eth.com/v1/mainnet",
  startBlock: 16989e3,
  subgraph: {
    endpoint: "https://api.thegraph.com/subgraphs/name/unlock-protocol/unlock",
    endpointV2: "https://api.thegraph.com/subgraphs/name/unlock-protocol/mainnet-v2",
    studioEndpoint: "unlock-protocol-mainnet"
  },
  swapPurchaser: "0x02415541c7F4c976722493181cFdb0b46E1c94fb",
  tokens: [
    {
      address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
      decimals: 18,
      name: "Wrapped Ether",
      symbol: "WETH"
    },
    {
      address: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
      decimals: 18,
      name: "Dai Stablecoin",
      symbol: "DAI"
    },
    {
      address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
      decimals: 6,
      name: "USD Coin",
      symbol: "USDC"
    },
    {
      address: "0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0",
      decimals: 18,
      name: "Polygon",
      symbol: "MATIC"
    },
    {
      address: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
      decimals: 6,
      name: "Tether USD",
      symbol: "USDT"
    },
    {
      address: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",
      decimals: 8,
      name: "Wrapped BTC",
      symbol: "WBTC"
    },
    {
      address: "0x0D8775F648430679A709E98d2b0Cb6250d2887EF",
      decimals: 18,
      name: "Basic Attention Token",
      symbol: "BAT"
    }
  ],
  uniswapV3: {
    factoryAddress: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
    oracle: "0x951A807b523cF6e178e0ab80fBd2C9B035521931",
    quoterAddress: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6",
    subgraph: "https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3",
    universalRouterAddress: "0xEf1c6E67703c7BD7107eed8303Fbe6EC2554BF6B"
  },
  unlockAddress: "0xe79B93f8E22676774F2A8dAd469175ebd00029FA",
  url: "https://ethereum.org/en/"
  // universalCard: {
  //   cardPurchaserAddress: '0x49814dd8a03594bE78a18455CC4Df3876ecFbD69',
  //   stripeDestinationNetwork: 'ethereum',
  //   stripeDestinationCurrency: 'usdc',
  // },
};
var import_types2 = __toESM(require_dist());
var gnosis = {
  blockScan: {
    url: (address) => `https://blockscan.com/address/${address}`
  },
  chain: "xdai",
  description: "Gnosis Chain is one of the first Ethereum sidechains and has stayed true to its values.",
  explorer: {
    name: "Blockscout",
    urls: {
      address: (address) => `https://gnosisscan.io/address/${address}/transactions`,
      base: `https://gnosisscan.io/`,
      token: (address, _holder) => `https://gnosisscan.io/token/${address}/token-holders#holders`,
      transaction: (hash) => `https://gnosisscan.io/tx/${hash}`
    }
  },
  faucet: "https://gnosisfaucet.com/",
  featured: true,
  governanceBridge: {
    connext: "0x5bB83e95f63217CDa6aE3D181BA580Ef377D2109",
    domainId: 6778479,
    modules: {
      connextMod: "0xdFB9328cF62e3525D355581dE88AeAa330879D12",
      delayMod: "0x6E74DC46EbF2cDB75B72Ab1dCAe3C98c7E9d28a1"
    }
  },
  hooks: {
    onKeyPurchaseHook: [
      {
        address: "0x927D68eAE936Ec0111f01Fc4Ddd9cC57DB3f0Af2",
        id: import_types2.HookType.PASSWORD,
        name: "Password required"
      },
      {
        address: "0xFb0657eAE55A4dd3E2317C9eCB311bA5Ecc62C9C",
        id: import_types2.HookType.CAPTCHA,
        name: "Captcha"
      },
      {
        address: "0xe20738d9798B5B5801aEEFDB81d80Fcce3a3Aa95",
        id: import_types2.HookType.GUILD,
        name: "Guild"
      }
    ]
  },
  id: 100,
  isTestNetwork: false,
  keyManagerAddress: "0xBa81C9379AC1221BF8C100800dD0B0b0b048ba14",
  maxFreeClaimCost: 100,
  multisig: "0xfAC611a5b5a578628C28F77cEBDDB8C6159Ae79D",
  name: "Gnosis Chain",
  nativeCurrency: {
    coinbase: "DAI",
    coingecko: "xdai",
    decimals: 18,
    name: "xDAI",
    symbol: "xDAI"
  },
  previousDeploys: [
    {
      startBlock: 14521200,
      unlockAddress: "0x14bb3586Ce2946E71B95Fe00Fc73dd30ed830863"
    }
  ],
  provider: "https://rpc.unlock-protocol.com/100",
  publicLockVersionToDeploy: 13,
  publicProvider: "https://rpc.gnosischain.com",
  startBlock: 19338700,
  // This is used in llama pricing API so can't rename.
  subgraph: {
    endpoint: "https://api.thegraph.com/subgraphs/name/unlock-protocol/xdai",
    endpointV2: "https://api.thegraph.com/subgraphs/name/unlock-protocol/gnosis-v2",
    networkName: "xdai"
  },
  tokens: [
    {
      address: "0xddafbb505ad214d7b80b1f830fccc89b60fb7a83",
      decimals: 6,
      name: "USD Coin",
      symbol: "USDC"
    },
    {
      address: "0x4ecaba5870353805a9f068101a40e0f32ed605c6",
      decimals: 6,
      name: "Tether USD",
      symbol: "USDT"
    }
  ],
  unlockAddress: "0x1bc53f4303c711cc693F6Ec3477B83703DcB317f",
  url: "https://www.gnosis.io/"
};
var import_types3 = __toESM(require_dist());
var polygon = {
  blockScan: {
    url: (address) => `https://blockscan.com/address/${address}`
  },
  chain: "polygon",
  description: "Polygon is a side-chain to build and scale your projects on Ethereum, the world's largest blockchain ecosystem.",
  explorer: {
    name: "Polygonscan",
    urls: {
      address: (address) => `https://polygonscan.com/address/${address}`,
      base: `https://polygonscan.com/`,
      token: (address, holder) => `https://polygonscan.com/token/${address}?a=${holder}`,
      transaction: (hash) => `https://polygonscan.com/tx/${hash}`
    }
  },
  featured: true,
  governanceBridge: {
    connext: "0x11984dc4465481512eb5b777E44061C158CF2259",
    domainId: 1886350457,
    modules: {
      connextMod: "0xa8E0FD3D023B1A253eF52B6169851Ee95eF257bE",
      delayMod: "0x31B8bB0BC5ffEe8e476202e9D97b0b8c31aA767d"
    }
  },
  hooks: {
    onKeyPurchaseHook: [
      {
        address: "0x9F4AE507d7E91Ab37CF35f792940fE079bd4E24d",
        id: import_types3.HookType.PASSWORD,
        name: "Password required"
      },
      {
        address: "0x64bDe27046F915e2BAb6339Ce4f737E34474344d",
        id: import_types3.HookType.CAPTCHA,
        name: "Captcha"
      },
      {
        address: "0xBfF080aB4600554c1e8c390d2e070CF423767B64",
        id: import_types3.HookType.GUILD,
        name: "Guild"
      },
      {
        address: "0x93E160838c529873cB7565106bBb79a3226FE07A",
        id: import_types3.HookType.PROMOCODE,
        name: "Discount code"
      }
    ]
  },
  id: 137,
  isTestNetwork: false,
  keyManagerAddress: "0x7111a1aDfbED501beaAd556Bba7cB6dCa3296aa9",
  maxFreeClaimCost: 100,
  multisig: "0x479f3830fbd715342868BA95E438609BCe443DFB",
  name: "Polygon",
  nativeCurrency: {
    coingecko: "matic-network",
    decimals: 18,
    name: "Matic",
    symbol: "MATIC"
  },
  opensea: {
    collectionUrl: (lockAddress) => `https://opensea.io/assets/matic/${lockAddress}`,
    tokenUrl: (lockAddress, tokenId) => `https://opensea.io/assets/matic/${lockAddress}/${tokenId}`
  },
  previousDeploys: [
    {
      startBlock: 15714206,
      unlockAddress: "0x14bb3586Ce2946E71B95Fe00Fc73dd30ed830863"
    }
  ],
  provider: "https://rpc.unlock-protocol.com/137",
  publicLockVersionToDeploy: 13,
  publicProvider: "https://polygon-rpc.com/",
  startBlock: 21986688,
  subgraph: {
    endpoint: "https://api.thegraph.com/subgraphs/name/unlock-protocol/polygon",
    endpointV2: "https://api.thegraph.com/subgraphs/name/unlock-protocol/polygon-v2",
    networkName: "matic"
  },
  swapPurchaser: "0x33aC9CAE1Cd9CBB191116607f564F7381d81BAD9",
  tokens: [
    {
      address: "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619",
      decimals: 18,
      name: "Wrapped Ether",
      symbol: "WETH"
    },
    {
      address: "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063",
      decimals: 18,
      name: "Dai Stablecoin",
      symbol: "DAI"
    },
    {
      address: "0xc2132D05D31c914a87C6611C10748AEb04B58e8F",
      decimals: 6,
      name: "Tether USD",
      symbol: "USDT"
    },
    {
      address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
      decimals: 6,
      name: "USD Coin",
      symbol: "USDC"
    },
    {
      address: "0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6",
      decimals: 8,
      name: "Wrapped BTC",
      symbol: "WBTC"
    }
  ],
  uniswapV3: {
    factoryAddress: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
    oracle: "0xE77c7F14e8EB9925ca418bF80c0a81a5B9C87683",
    quoterAddress: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6",
    universalRouterAddress: "0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5"
  },
  universalCard: {
    cardPurchaserAddress: "0xAB355a589CFbBA7a21b91E5B6063bF822dCc0016",
    stripeDestinationCurrency: "usdc",
    stripeDestinationNetwork: "polygon"
  },
  unlockAddress: "0xE8E5cd156f89F7bdB267EabD5C43Af3d5AF2A78f",
  url: "https://polygon.technology/"
};
var import_types4 = __toESM(require_dist());
var bsc = {
  blockScan: {
    url: (address) => `https://blockscan.com/address/${address}`
  },
  chain: "bsc",
  description: "The best-performing EVM compatible layer 1. Fully compatible tooling for EVM with up to 35 times of capacity.",
  explorer: {
    name: "BscScan",
    urls: {
      address: (address) => `https://bscscan.com/address/${address}`,
      base: `https://bscscan.com/`,
      token: (address, holder) => `https://bscscan.com/token/${address}?a=${holder}`,
      transaction: (hash) => `https://bscscan.com/tx/${hash}`
    }
  },
  featured: false,
  governanceBridge: {
    connext: "0xCd401c10afa37d641d2F594852DA94C700e4F2CE",
    domainId: 6450786,
    modules: {
      connextMod: "0x36b34e10295cCE69B652eEB5a8046041074515Da",
      delayMod: "0xcf07c951C44731f82E548286C7ebeC576149a49e"
    }
  },
  hooks: {
    onKeyPurchaseHook: [
      {
        address: "0x338b1f296217485bf4df6CE9f93ab4C73F72b57D",
        id: import_types4.HookType.PASSWORD,
        name: "Password required"
      },
      {
        address: "0x80E085D7591C61153D876b5171dc25756a7A3254",
        id: import_types4.HookType.CAPTCHA,
        name: "Captcha"
      },
      {
        address: "0xF6963D3c395A7914De77f771C2fC44b47B8379AC",
        id: import_types4.HookType.GUILD,
        name: "Guild"
      }
    ]
  },
  id: 56,
  isTestNetwork: false,
  keyManagerAddress: "0x34EbEc0AE80A2d078DE5489f0f5cAa4d3aaEA355",
  maxFreeClaimCost: 1,
  multisig: "0x373D7cbc4F2700719DEa237500c7a154310B0F9B",
  name: "BNB Chain",
  nativeCurrency: {
    coingecko: "binancecoin",
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  opensea: {
    collectionUrl: (lockAddress) => `https://opensea.io/assets/bsc/${lockAddress}`,
    tokenUrl: (_lockAddress, _tokenId) => `https://opensea.io/assets/bsc/${_lockAddress}/${_tokenId}`
  },
  previousDeploys: [
    {
      startBlock: 12396e3,
      unlockAddress: "0x99b1348a9129ac49c6de7F11245773dE2f51fB0c"
    }
  ],
  provider: "https://rpc.unlock-protocol.com/56",
  publicLockVersionToDeploy: 13,
  publicProvider: "https://bsc-dataseed.binance.org/",
  startBlock: 13079e3,
  subgraph: {
    endpoint: "https://api.thegraph.com/subgraphs/name/unlock-protocol/bsc",
    endpointV2: "https://api.thegraph.com/subgraphs/name/unlock-protocol/bsc-v2"
  },
  swapPurchaser: "0x5Ad19758103D474bdF5E8764D97cB02b83c3c844",
  tokens: [
    {
      address: "0x2170ed0880ac9a755fd29b2688956bd959f933f8",
      decimals: 18,
      name: "Ethereum",
      symbol: "ETH"
    },
    {
      address: "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
      decimals: 18,
      name: "USD Coin",
      symbol: "USDC"
    },
    {
      address: "0x55d398326f99059ff775485246999027b3197955",
      decimals: 18,
      name: "Tether",
      symbol: "USDT"
    },
    {
      address: "0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3",
      decimals: 18,
      name: "Dai",
      symbol: "DAI"
    }
  ],
  uniswapV3: {
    universalRouterAddress: "0x4648a43B2C14Da09FdF82B161150d3F634f40491"
  },
  unlockAddress: "0xeC83410DbC48C7797D2f2AFe624881674c65c856",
  url: "https://www.bnbchain.org/en"
};
var import_types5 = __toESM(require_dist());
var optimism = {
  blockScan: {
    url: (address) => `https://blockscan.com/address/${address}`
  },
  chain: "optimism",
  description: "Optimism is a Layer 2 Optimistic Rollup network designed to utilize the strong security guarantees of Ethereum while reducing its cost and latency.",
  explorer: {
    name: "Etherscan",
    urls: {
      address: (address) => `https://optimistic.etherscan.io/address/${address}`,
      base: `https://optimistic.etherscan.io/`,
      token: (address, holder) => `https://optimistic.etherscan.io/token/${address}?a=${holder}`,
      transaction: (hash) => `https://optimistic.etherscan.io/tx/${hash}`
    }
  },
  featured: true,
  governanceBridge: {
    connext: "0x8f7492DE823025b4CfaAB1D34c58963F2af5DEDA",
    domainId: 1869640809,
    modules: {
      connextMod: "0xF241F12506fb6Bf1909c6bC176A199166414007a",
      delayMod: "0xA8BB5AF09B599794136B14B112e137FAf83Acf1f"
    }
  },
  hooks: {
    onKeyPurchaseHook: [
      {
        address: "0x34EbEc0AE80A2d078DE5489f0f5cAa4d3aaEA355",
        id: import_types5.HookType.PASSWORD,
        name: "Password required"
      },
      {
        address: "0xF6a9138b4ebEd2AcF651Cbd40B45584B4c625e87",
        id: import_types5.HookType.CAPTCHA,
        name: "Captcha"
      },
      {
        address: "0x1402D55BF0D6566ca8F569041000a8015b608632",
        id: import_types5.HookType.GUILD,
        name: "Guild"
      },
      {
        address: "0x8e0B46ec3B95c81355175693dA0083b00fCc1326",
        id: import_types5.HookType.PROMOCODE,
        name: "Discount code"
      }
    ]
  },
  id: 10,
  isTestNetwork: false,
  keyManagerAddress: "0x8c5D54B2CAA4C2D08B0DDF82a1e6D2641779B8EC",
  maxFreeClaimCost: 1,
  multisig: "0x6E78b4447e34e751EC181DCBed63633aA753e145",
  name: "Optimism",
  nativeCurrency: {
    coingecko: "ethereum",
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  opensea: {
    collectionUrl: (lockAddress) => `https://opensea.io/assets/optimism/${lockAddress}`,
    tokenUrl: (_lockAddress, _tokenId) => `https://opensea.io/assets/optimism/${_lockAddress}/${_tokenId}`
  },
  previousDeploys: [],
  provider: "https://rpc.unlock-protocol.com/10",
  publicLockVersionToDeploy: 13,
  publicProvider: "https://mainnet.optimism.io",
  startBlock: 302400,
  subgraph: {
    endpoint: "https://api.thegraph.com/subgraphs/name/unlock-protocol/optimism",
    endpointV2: "https://api.thegraph.com/subgraphs/name/unlock-protocol/optimism-v2"
  },
  swapPurchaser: "0x72381052e4F7765A00a403891420BF75876c75bB",
  tokens: [
    {
      address: "0x0000000000000000000000000000000000000000",
      decimals: 18,
      name: "Ethereum",
      symbol: "ETH"
    },
    {
      address: "0x7f5c764cbc14f9669b88837ca1490cca17c31607",
      decimals: 6,
      name: "USD Coin",
      symbol: "USDC"
    },
    {
      address: "0x94b008aa00579c1307b0ef2c499ad98a8ce58e58",
      decimals: 6,
      name: "Tether",
      symbol: "USDT"
    },
    {
      address: "0xda10009cbd5d07dd0cecc66161fc93d7c9000da1",
      decimals: 18,
      name: "Dai",
      symbol: "DAI"
    }
  ],
  uniswapV3: {
    factoryAddress: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
    oracle: "0x1FF7e338d5E582138C46044dc238543Ce555C963",
    quoterAddress: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6",
    universalRouterAddress: "0xb555edF5dcF85f42cEeF1f3630a52A108E55A654"
  },
  unlockAddress: "0x99b1348a9129ac49c6de7F11245773dE2f51fB0c",
  url: "https://www.optimism.io/"
};
var import_types6 = __toESM(require_dist());
var mumbai = {
  blockScan: {
    url: (address) => `https://blockscan.com/address/${address}`
  },
  chain: "mumbai",
  description: "Polygon test network. Do not use for production.",
  explorer: {
    name: "PolygonScan (Mumbai)",
    urls: {
      address: (address) => `https://mumbai.polygonscan.com/address/${address}`,
      base: `https://mumbai.polygonscan.com/`,
      token: (address, holder) => `https://mumbai.polygonscan.com/token/${address}?a=${holder}`,
      transaction: (hash) => `https://mumbai.polygonscan.com/tx/${hash}`
    }
  },
  faucet: "https://faucet.polygon.technology/",
  featured: false,
  fullySubsidizedGas: true,
  governanceBridge: {
    connext: "0x2334937846Ab2A3FCE747b32587e1A1A2f6EEC5a",
    domainId: 9991
  },
  hooks: {
    onKeyPurchaseHook: [
      {
        address: "0x34EbEc0AE80A2d078DE5489f0f5cAa4d3aaEA355",
        id: import_types6.HookType.PASSWORD,
        name: "Password required"
      },
      {
        address: "0xdd753E08BB09F22593537f29100F0eD98AfA57FA",
        id: import_types6.HookType.CAPTCHA,
        name: "Captcha"
      }
    ]
  },
  id: 80001,
  isTestNetwork: true,
  keyManagerAddress: "0x8c5D54B2CAA4C2D08B0DDF82a1e6D2641779B8EC",
  maxFreeClaimCost: 500,
  multisig: "0x12E37A8880801E1e5290c815a894d322ac591607",
  name: "Mumbai (Polygon)",
  nativeCurrency: {
    coingecko: "matic-network",
    decimals: 18,
    name: "MATIC",
    symbol: "MATIC"
  },
  opensea: {
    collectionUrl: (lockAddress) => `https://testnets.opensea.io/assets/mumbai/${lockAddress}`,
    tokenUrl: (_lockAddress, _tokenId) => `https://testnets.opensea.io/assets/mumbai/${_lockAddress}/${_tokenId}`
  },
  previousDeploys: [],
  provider: "https://rpc.unlock-protocol.com/80001",
  publicLockVersionToDeploy: 13,
  publicProvider: "https://matic-mumbai.chainstacklabs.com",
  startBlock: 26584912,
  subgraph: {
    endpoint: "https://api.thegraph.com/subgraphs/name/unlock-protocol/mumbai",
    endpointV2: "https://api.thegraph.com/subgraphs/name/unlock-protocol/mumbai-v2"
  },
  swapPurchaser: "0x302E9D970A657B42c1C124C69f3a1c1575CB4AD3",
  tokens: [
    {
      address: "0x0FA8781a83E46826621b3BC094Ea2A0212e71B23",
      decimals: 6,
      mainnetAddress: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
      name: "USD Coin",
      symbol: "USDC"
    },
    {
      address: "0xA6FA4fB5f76172d178d61B04b0ecd319C5d1C0aa",
      decimals: 18,
      mainnetAddress: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
      name: "Wrapped Ether",
      symbol: "WETH"
    },
    {
      address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
      decimals: 18,
      mainnetAddress: "0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0",
      name: "Wrapped Matic",
      symbol: "WMATIC"
    },
    {
      address: "0xcB1e72786A6eb3b44C2a2429e317c8a2462CFeb1",
      decimals: 18,
      mainnetAddress: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
      name: "Dai Stablecoin",
      symbol: "DAI"
    }
  ],
  uniswapV3: {
    factoryAddress: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
    oracle: "0x5108412Dd50A6ea79d2F13D5d1A23FDD9bF532db",
    quoterAddress: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6",
    universalRouterAddress: "0x4648a43B2C14Da09FdF82B161150d3F634f40491"
  },
  unlockAddress: "0x1FF7e338d5E582138C46044dc238543Ce555C963",
  unlockOwner: "0xdc230F9A08918FaA5ae48B8E13647789A8B6dD46",
  url: "https://mumbai.polygonscan.com/"
};
var import_types7 = __toESM(require_dist());
var goerli = {
  blockScan: {
    url: (address) => `https://blockscan.com/address/${address}`
  },
  chain: "goerli",
  description: "Main Ethereum test network. Do not use for production.",
  explorer: {
    name: "Goerli (Testnet)",
    urls: {
      address: (address) => `https://goerli.etherscan.io/address/${address}`,
      base: `https://goerli.etherscan.io/`,
      token: (address, holder) => `https://goerli.etherscan.io/token/${address}?a=${holder}`,
      transaction: (hash) => `https://goerli.etherscan.io/tx/${hash}`
    }
  },
  faucet: "https://goerlifaucet.com/",
  featured: true,
  fullySubsidizedGas: true,
  governanceBridge: {
    connext: "0xFCa08024A6D4bCc87275b1E4A1E22B71fAD7f649",
    domainId: 1735353714,
    modules: {
      connextMod: "0xce58DB94DE48A8a9Ea47cBe4376F19724D154DF2",
      delayMod: "0x46FdC1d73486E20406D1C6dAcDD22b6599AEA32d"
    }
  },
  hooks: {
    onKeyPurchaseHook: [
      {
        address: "0xCa837900f7DaB40787b608b6738d1B730f1d2759",
        id: import_types7.HookType.PASSWORD,
        name: "Password required"
      },
      {
        address: "0xDF2A7C8be199C0e9e825750586be7F331F30dC29",
        id: import_types7.HookType.CAPTCHA,
        name: "Captcha"
      },
      {
        address: "0x1AC9271D271b8E50537CAd54b330424C52A84822",
        id: import_types7.HookType.GUILD,
        name: "Guild"
      },
      {
        address: "0x850c015A6A88756a59Dc025fca988494fF90DBB7",
        id: import_types7.HookType.PROMOCODE,
        name: "Discount code"
      }
    ]
  },
  id: 5,
  isTestNetwork: true,
  keyManagerAddress: "0xc328aE7fc36f975BE120aaa99f2d96C3E732e5b6",
  maxFreeClaimCost: 1e5,
  multisig: "0x95C06469e557d8645966077891B4aeDe8D55A755",
  name: "Goerli (Testnet)",
  nativeCurrency: {
    coingecko: "ethereum",
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  opensea: {
    collectionUrl: (lockAddress) => `https://testnets.opensea.io/assets/goerli/${lockAddress}`,
    tokenUrl: (lockAddress, tokenId) => `https://testnets.opensea.io/assets/goerli/${lockAddress}/${tokenId}`
  },
  previousDeploys: [],
  provider: "https://rpc.unlock-protocol.com/5",
  publicLockVersionToDeploy: 13,
  publicProvider: "https://goerli.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161",
  startBlock: 7179039,
  subgraph: {
    endpoint: "https://api.thegraph.com/subgraphs/name/unlock-protocol/goerli",
    endpointV2: "https://api.thegraph.com/subgraphs/name/unlock-protocol/goerli-v2"
  },
  swapPurchaser: "0x49aD0039B30De002d4C27A6E8Fc026c7e23d083C",
  tokens: [
    {
      address: "0x07865c6E87B9F70255377e024ace6630C1Eaa37F",
      decimals: 6,
      mainnetAddress: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
      name: "USD Coin",
      symbol: "USDC"
    },
    {
      address: "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6",
      decimals: 18,
      mainnetAddress: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
      name: "Wrapped Ether",
      symbol: "WETH"
    },
    {
      address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
      decimals: 18,
      mainnetAddress: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
      name: "Uniswap",
      symbol: "UNI"
    }
  ],
  uniswapV3: {
    factoryAddress: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
    oracle: "0x25197CaCDE16500032EF4B35d60c6f7aEd4a38a5",
    universalRouterAddress: "0x4648a43B2C14Da09FdF82B161150d3F634f40491"
  },
  universalCard: {
    cardPurchaserAddress: "0x061Bfda0446c5f71Da760BC31371CB95808f5d82",
    stripeDestinationCurrency: "usdc",
    stripeDestinationNetwork: "ethereum"
  },
  unlockAddress: "0x627118a4fB747016911e5cDA82e2E77C531e8206",
  unlockOwner: "0x6E74DC46EbF2cDB75B72Ab1dCAe3C98c7E9d28a1",
  url: "https://goerli.net/"
};
var import_types8 = __toESM(require_dist());
var celo = {
  blockScan: {
    url: (address) => `https://blockscan.com/address/${address}`
  },
  chain: "celo",
  description: "Celo is the carbon-negative, mobile-first, EVM-compatible blockchain ecosystem leading a thriving new digital economy for all.",
  explorer: {
    name: "Celoscan",
    urls: {
      address: (address) => `https://celoscan.io/address/${address}`,
      base: `https://celoscan.io/`,
      token: (address, holder) => `https://celoscan.io/token/${address}?a=${holder}`,
      transaction: (hash) => `https://celoscan.io/tx/${hash}`
    }
  },
  featured: false,
  hooks: {
    onKeyPurchaseHook: [
      {
        address: "0x1Bc951F8ed90F6c135F01Fe62CA348F4c3F43D00",
        id: import_types8.HookType.CAPTCHA,
        name: "Captcha"
      },
      {
        address: "0xdd753E08BB09F22593537f29100F0eD98AfA57FA",
        id: import_types8.HookType.GUILD,
        name: "Guild"
      }
    ]
  },
  id: 42220,
  isTestNetwork: false,
  keyManagerAddress: "0xF6963D3c395A7914De77f771C2fC44b47B8379AC",
  maxFreeClaimCost: 1,
  multisig: "0xc293E2da9E558bD8B1DFfC4a7b174729fAb2e4E8",
  name: "Celo",
  nativeCurrency: {
    coingecko: "celo",
    decimals: 18,
    name: "CELO",
    symbol: "CELO"
  },
  previousDeploys: [],
  provider: "https://rpc.unlock-protocol.com/42220",
  publicLockVersionToDeploy: 13,
  publicProvider: "https://forno.celo.org",
  startBlock: 7179039,
  subgraph: {
    endpoint: "https://api.thegraph.com/subgraphs/name/unlock-protocol/celo",
    endpointV2: "https://api.thegraph.com/subgraphs/name/unlock-protocol/celo-v2"
  },
  swapPurchaser: "0x42F5c7839Bf00FAea6ca09517E96E82e7364384D",
  tokens: [
    {
      address: "0xef4229c8c3250c675f21bcefa42f58efbff6002a",
      decimals: 6,
      mainnetAddress: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
      name: "USD Coin",
      symbol: "USDC"
    },
    {
      address: "0xE4fE50cdD716522A56204352f00AA110F731932d",
      decimals: 18,
      mainnetAddress: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
      name: "Dai Stablecoin",
      symbol: "DAI"
    }
  ],
  uniswapV3: {
    factoryAddress: "0xAfE208a311B21f13EF87E33A90049fC17A7acDEc",
    oracle: "0x5108412Dd50A6ea79d2F13D5d1A23FDD9bF532db",
    quoterAddress: "0x82825d0554fA07f7FC52Ab63c961F330fdEFa8E8",
    universalRouterAddress: "0xC73d61d192FB994157168Fb56730FdEc64C9Cb8F"
  },
  unlockAddress: "0x1FF7e338d5E582138C46044dc238543Ce555C963",
  url: "https://celo.org"
};
var import_types9 = __toESM(require_dist());
var arbitrum = {
  blockScan: {
    url: (address) => `https://blockscan.com/address/${address}`
  },
  chain: "arbitrum",
  description: "Arbitrum One is a Layer 2 (L2) chain running on top of Ethereum Mainnet that enables high-throughput, low cost smart contracts operations.",
  explorer: {
    name: "Arbitrum",
    urls: {
      address: (address) => `https://arbiscan.io/address/${address}`,
      base: `https://arbiscan.io/`,
      token: (address, holder) => `https://arbiscan.io/token/${address}?a=${holder}`,
      transaction: (hash) => `https://arbiscan.io/tx/${hash}`
    }
  },
  featured: true,
  governanceBridge: {
    connext: "0xEE9deC2712cCE65174B561151701Bf54b99C24C8",
    domainId: 1634886255,
    modules: {
      connextMod: "0x4A553635774b3d6fB6273A83b5B49577dF450227",
      delayMod: "0xF241F12506fb6Bf1909c6bC176A199166414007a"
    }
  },
  hooks: {
    onKeyPurchaseHook: [
      {
        address: "0xd0b14797b9D08493392865647384974470202A78",
        id: import_types9.HookType.PASSWORD,
        name: "Password required"
      },
      {
        address: "0xD925Ac2887Ba4372849F0fd64217A6749552bb21",
        id: import_types9.HookType.CAPTCHA,
        name: "Captcha"
      },
      {
        address: "0x06538095ae3B5123e440D9991377B85C3BC6E6FF",
        id: import_types9.HookType.GUILD,
        name: "Guild"
      }
    ]
  },
  id: 42161,
  isTestNetwork: false,
  keyManagerAddress: "0x520294E736167303efa038205D4391b58261BC9c",
  maxFreeClaimCost: 1,
  multisig: "0x310e9f9E3918a71dB8230cFCF32a083c7D9536d0",
  name: "Arbitrum",
  nativeCurrency: {
    coingecko: "ethereum",
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  opensea: {
    collectionUrl: (lockAddress) => `https://opensea.io/assets/arbitrum/${lockAddress}`,
    tokenUrl: (_lockAddress, _tokenId) => `https://opensea.io/assets/arbitrum/${_lockAddress}/${_tokenId}`
  },
  previousDeploys: [],
  provider: "https://rpc.unlock-protocol.com/42161",
  publicLockVersionToDeploy: 13,
  publicProvider: "https://arb1.arbitrum.io/rpc",
  startBlock: 17429533,
  subgraph: {
    endpoint: "https://api.thegraph.com/subgraphs/name/unlock-protocol/arbitrum",
    endpointV2: "https://api.thegraph.com/subgraphs/name/unlock-protocol/arbitrum-v2",
    networkName: "arbitrum-one"
  },
  swapPurchaser: "0x0C33884Ab3eE799E7628FA3fCF20B81997745a72",
  tokens: [
    {
      address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
      decimals: 18,
      name: "Ethereum",
      symbol: "WETH"
    },
    {
      address: "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8",
      decimals: 6,
      name: "USD Coin",
      symbol: "USDC"
    },
    {
      address: "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
      decimals: 6,
      name: "Tether",
      symbol: "USDT"
    },
    {
      address: "0xda10009cbd5d07dd0cecc66161fc93d7c9000da1",
      decimals: 18,
      name: "Dai",
      symbol: "DAI"
    },
    {
      address: "0x2f2a2543b76a4166549f7aab2e75bef0aefc5b0f",
      decimals: 8,
      name: "Wrapped Bitcoin",
      symbol: "WBTC"
    }
  ],
  uniswapV3: {
    factoryAddress: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
    oracle: "0x821d830a7b9902F83359Bf3Ac727B04b10FD461d",
    quoterAddress: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6",
    universalRouterAddress: "0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5"
  },
  unlockAddress: "0x1FF7e338d5E582138C46044dc238543Ce555C963",
  url: "https://arbitrum.io/"
};
var import_types10 = __toESM(require_dist());
var avalanche = {
  blockScan: {
    url: (address) => `https://blockscan.com/address/${address}`
  },
  chain: "avax",
  description: "Avalanche is an open, programmable smart contracts platform for decentralized applications.",
  explorer: {
    name: "Snowtrace (Avalanche)",
    urls: {
      address: (address) => `https://snowtrace.io/address/${address}`,
      base: `https://snowtrace.io/`,
      token: (address, holder) => `https://snowtrace.io/token/${address}?a=${holder}`,
      transaction: (hash) => `https://snowtrace.io/tx/${hash}`
    }
  },
  featured: false,
  hooks: {
    onKeyPurchaseHook: [
      {
        address: "0x2499D94880B30fA505543550ac8a1e24cfFeFe78",
        id: import_types10.HookType.CAPTCHA,
        name: "Captcha"
      },
      {
        address: "0x58D86Dc056c442867485941FeBeA8D3bB4657eAC",
        id: import_types10.HookType.PASSWORD,
        name: "Password required"
      }
    ]
  },
  id: 43114,
  isTestNetwork: false,
  keyManagerAddress: "0x8e0B46ec3B95c81355175693dA0083b00fCc1326",
  maxFreeClaimCost: 1,
  multisig: "0xEc7777C51327917fd2170c62873272ea168120Cb",
  name: "Avalanche (C-Chain)",
  nativeCurrency: {
    coingecko: "avalanche-2",
    decimals: 18,
    name: "AVAX",
    symbol: "AVAX"
  },
  opensea: {
    collectionUrl: (lockAddress) => `https://opensea.io/assets/avalanche/${lockAddress}`,
    tokenUrl: (_lockAddress, _tokenId) => `https://opensea.io/assets/avalanche/${_lockAddress}/${_tokenId}`
  },
  previousDeploys: [],
  provider: "https://rpc.unlock-protocol.com/43114",
  publicLockVersionToDeploy: 13,
  publicProvider: "https://api.avax.network/ext/bc/C/rpc",
  startBlock: 17188332,
  subgraph: {
    endpoint: "https://api.thegraph.com/subgraphs/name/unlock-protocol/avalanche",
    endpointV2: "https://api.thegraph.com/subgraphs/name/unlock-protocol/avalanche-v2"
  },
  tokens: [
    {
      address: "0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab",
      decimals: 18,
      name: "Ethereum",
      symbol: "WETH"
    },
    {
      address: "0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664",
      decimals: 6,
      name: "USD Coin",
      symbol: "USDC"
    },
    {
      address: "0xc7198437980c041c805a1edcba50c1ce5db95118",
      decimals: 6,
      name: "Tether",
      symbol: "USDT"
    },
    {
      address: "0xd586e7f844cea2f87f50152665bcbc2c279d8d70",
      decimals: 18,
      name: "Dai",
      symbol: "DAI"
    },
    {
      address: "0x50b7545627a5162f82a992c33b87adc75187b218",
      decimals: 8,
      name: "Wrapped Bitcoin",
      symbol: "WBTC"
    }
  ],
  unlockAddress: "0x70cBE5F72dD85aA634d07d2227a421144Af734b3",
  url: "https://www.avalabs.org/"
};
var palm = {
  blockScan: {
    url: (address) => `https://blockscan.com/address/${address}`
  },
  chain: "palm",
  description: "The Palm network is an Ethereum-compatible sidechain, built to serve as the foundation of a new scalable and sustainable ecosystem for NFTs. It is designed by, and for, Ethereum developers and features low gas costs and fast transaction finality.",
  explorer: {
    name: "Palm Explorer",
    urls: {
      address: (address) => `https://explorer.palm.io/address/${address}`,
      base: `https://explorer.palm.io/`,
      token: (address, holder) => `https://explorer.palm.io/token/${address}?a=${holder}`,
      transaction: (hash) => `https://explorer.palm.io/tx/${hash}`
    }
  },
  featured: false,
  fullySubsidizedGas: true,
  id: 11297108109,
  isTestNetwork: false,
  keyManagerAddress: "0x70cBE5F72dD85aA634d07d2227a421144Af734b3",
  maxFreeClaimCost: 1,
  multisig: "0xABEAf8F93bEA2a2E65866CccC3060626eEc7d304",
  name: "Palm",
  nativeCurrency: {
    coingecko: "palm",
    decimals: 18,
    name: "PALM",
    symbol: "PALM"
  },
  opensea: {
    tokenUrl: (_lockAddress, _tokenId) => null
  },
  previousDeploys: [],
  provider: "https://rpc.unlock-protocol.com/11297108109",
  publicLockVersionToDeploy: 13,
  publicProvider: "https://palm-mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161",
  startBlock: 9856400,
  subgraph: {
    endpoint: "https://graph.palm.io/subgraphs/name/unlock-protocol/Palm-mainnet",
    endpointV2: "https://graph.palm.io/subgraphs/name/unlock-protocol/Palm-mainnet",
    networkName: "palm-mainnet"
  },
  tokens: [
    {
      address: "0x726138359C17F1E56bA8c4F737a7CAf724F6010b",
      decimals: 18,
      name: "Wrapped ETH",
      symbol: "WETH"
    },
    {
      address: "0x4C1f6fCBd233241bF2f4D02811E3bF8429BC27B8",
      decimals: 18,
      name: "Dai",
      symbol: "DAI"
    }
  ],
  uniswapV3: {
    factoryAddress: "0x",
    oracle: "0x",
    quoterAddress: "0x"
  },
  unlockAddress: "0x0314E34345C2327aC753C5Bf0D0751Cf6C1BfdE2"
};
var baseGoerli = {
  blockScan: {
    url: (address) => `https://blockscan.com/address/${address}`
  },
  chain: "base-goerli",
  description: "Main Ethereum test network. Do not use for production.",
  explorer: {
    name: "Base Goerli",
    urls: {
      address: (address) => `https://goerli.basescan.org/address/${address}`,
      base: `https://goerli.basescan.org/`,
      token: (address, holder) => `https://goerli.basescan.org/token/${address}?a=${holder}`,
      transaction: (hash) => `https://goerli.basescan.org/tx/${hash}`
    }
  },
  featured: false,
  fullySubsidizedGas: true,
  id: 84531,
  isTestNetwork: true,
  keyManagerAddress: "0x70cBE5F72dD85aA634d07d2227a421144Af734b3",
  maxFreeClaimCost: 1e4,
  multisig: "",
  name: "Base Goerli (Testnet)",
  nativeCurrency: {
    coingecko: "ethereum",
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  opensea: {
    collectionUrl: (lockAddress) => `https://testnets.opensea.io/assets/goerli/${lockAddress}`,
    tokenUrl: (lockAddress, tokenId) => `https://testnets.opensea.io/assets/goerli/${lockAddress}/${tokenId}`
  },
  previousDeploys: [],
  provider: "https://rpc.unlock-protocol.com/84531",
  publicLockVersionToDeploy: 13,
  publicProvider: "https://goerli.base.org",
  startBlock: 2247300,
  subgraph: {
    endpoint: "https://api.studio.thegraph.com/query/44190/unlock-protocol-base-goerli/version/latest",
    endpointV2: "https://api.studio.thegraph.com/query/44190/unlock-protocol-base-goerli/version/latest",
    networkName: "base-testnet",
    studioEndpoint: "unlock-protocol-base-goerli"
  },
  unlockAddress: "0x51A1ceB83B83F1985a81C295d1fF28Afef186E02",
  url: "https://docs.base.org/network-information#base-testnet"
};
var base = {
  blockScan: {
    url: (address) => `https://blockscan.com/address/${address}`
  },
  chain: "base",
  description: "Base is a secure, low-cost, builder-friendly Ethereum L2 built to bring the next billion users onchain.  ",
  explorer: {
    name: "Basescan",
    urls: {
      address: (address) => `https://basescan.org/address/${address}`,
      base: `https://basescan.org/`,
      token: (address, holder) => `https://basescan.org/token/${address}?a=${holder}`,
      transaction: (hash) => `https://basescan.org/tx/${hash}`
    }
  },
  featured: true,
  fullySubsidizedGas: false,
  hooks: {
    onKeyPurchaseHook: []
  },
  id: 8453,
  isTestNetwork: false,
  keyManagerAddress: "0xD26c05a33349a6DeD02DD9360e1ef303d1246fb6",
  maxFreeClaimCost: 1,
  multisig: "0x8149FeaFa41DD1ee3CA62299b9c67e9ac12FA340",
  name: "Base",
  nativeCurrency: {
    coingecko: "ethereum",
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  opensea: {
    collectionUrl: (lockAddress) => `https://opensea.io/assets/base/${lockAddress}`,
    tokenUrl: (_lockAddress, _tokenId) => `https://opensea.io/assets/base/${_lockAddress}/${_tokenId}`
  },
  previousDeploys: [],
  provider: "https://rpc.unlock-protocol.com/8453",
  publicLockVersionToDeploy: 13,
  publicProvider: "https://developer-access-mainnet.base.org",
  startBlock: 175e4,
  subgraph: {
    endpoint: "https://api.studio.thegraph.com/query/44190/unlock-protocol-base/version/latest",
    endpointV2: "https://api.studio.thegraph.com/query/44190/unlock-protocol-base/version/latest",
    networkName: "base",
    studioEndpoint: "unlock-protocol-base"
  },
  tokens: [
    {
      address: "0x50c5725949a6f0c72e6c4a641f24049a917db0cb",
      decimals: 18,
      name: "Dai Stablecoin",
      symbol: "DAI"
    },
    {
      address: "0xd9aaec86b65d86f6a7b5b1b0c42ffa531710b6ca",
      decimals: 6,
      name: "USD Coin",
      symbol: "USDC"
    }
  ],
  unlockAddress: "0xd0b14797b9D08493392865647384974470202A78",
  url: "https://base.org/"
};
var import_types11 = __toESM(require_dist());
var sepolia = {
  blockScan: {
    url: (address) => `https://blockscan.com/address/${address}`
  },
  chain: "sepolia",
  description: "Sepolia is the primary testnet recommended by the Ethereum community for dapp development.",
  explorer: {
    name: "Sepolia Etherscan",
    urls: {
      address: (address) => `https://sepolia.etherscan.io/address/${address}`,
      base: `https://sepolia.etherscan.io/`,
      token: (address, holder) => `https://sepolia.etherscan.io/token/${address}?a=${holder}`,
      transaction: (hash) => `https://sepolia.etherscan.io/tx/${hash}`
    }
  },
  featured: true,
  fullySubsidizedGas: true,
  hooks: {
    onKeyPurchaseHook: [
      {
        address: "0x34EbEc0AE80A2d078DE5489f0f5cAa4d3aaEA355",
        id: import_types11.HookType.PASSWORD,
        name: "Password required"
      },
      {
        address: "0xd0b14797b9D08493392865647384974470202A78",
        id: import_types11.HookType.CAPTCHA,
        name: "Captcha"
      },
      {
        address: "0x6878Ae3c863f6Ebd27B47C02F6B32aAC8B0BA07E",
        id: import_types11.HookType.GUILD,
        name: "Guild"
      },
      {
        address: "0x639143cbf90F27eA5Ce4b3A7D869d4D7878009A5",
        id: import_types11.HookType.PROMOCODE,
        name: "Discount code"
      }
    ]
  },
  id: 11155111,
  isTestNetwork: true,
  keyManagerAddress: "0x338b1f296217485bf4df6CE9f93ab4C73F72b57D",
  maxFreeClaimCost: 1e3,
  multisig: "",
  // SAFE does not support Sepolia as of October 11th 2023
  name: "Sepolia",
  nativeCurrency: {
    coingecko: "ethereum",
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  opensea: {
    collectionUrl: (lockAddress) => `https://testnets.opensea.io/assets/sepolia/${lockAddress}`,
    tokenUrl: (_lockAddress, _tokenId) => `https://testnets.opensea.io/assets/sepolia/${_lockAddress}/${_tokenId}`
  },
  previousDeploys: [],
  provider: "https://rpc.unlock-protocol.com/11155111",
  publicLockVersionToDeploy: 13,
  publicProvider: "https://rpc2.sepolia.org/",
  startBlock: 4381710,
  subgraph: {
    endpoint: "https://api.studio.thegraph.com/query/21867/unlock-protocol-sepolia/version/latest",
    endpointV2: "https://api.studio.thegraph.com/query/21867/unlock-protocol-sepolia/version/latest",
    networkName: "sepolia",
    studioEndpoint: "unlock-protocol-sepolia"
  },
  tokens: [
    {
      address: "0x7b79995e5f793a07bc00c21412e50ecae098e7f9",
      decimals: 18,
      mainnetAddress: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  ],
  unlockAddress: "0x36b34e10295cCE69B652eEB5a8046041074515Da",
  url: "https://github.com/eth-clients/sepolia"
};
var networks = {};
Object.keys(networks_exports).forEach((networkName) => {
  const network = networks_exports[networkName];
  networks[network.id] = network;
});

// src/PublicLock/v9/setGasRefundValue.js
import { ethers as ethers4 } from "ethers";
async function setMaxNumberOfKeys2({ lockAddress, gasRefundValue }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const { chainId: network } = await this.provider.getNetwork();
  let decimals = this.networks[network].nativeCurrency.decimals;
  const erc20Address = await lockContract.tokenAddress();
  if (erc20Address !== ethers4.constants.AddressZero) {
    decimals = await getErc20Decimals(erc20Address, this.provider);
  }
  const refundValue = ethers4.utils.parseUnits(gasRefundValue, decimals);
  const transactionPromise = lockContract.setGasRefundValue(refundValue);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
}
var setGasRefundValue_default = setMaxNumberOfKeys2;

// src/PublicLock/v9/index.js
var {
  grantKey: grantKey2,
  grantKeys: grantKeys2,
  updateKeyPrice: updateKeyPrice3,
  withdrawFromLock: withdrawFromLock3,
  initializeTemplate: initializeTemplate3,
  isLockManager: isLockManager2,
  isKeyGranter: isKeyGranter2,
  addKeyGranter: addKeyGranter2,
  expireAndRefundFor: expireAndRefundFor2,
  cancelAndRefund: cancelAndRefund2,
  shareKey: shareKey3,
  getLock: getLock3,
  keyManagerOf,
  getCancelAndRefundValueFor: getCancelAndRefundValueFor3,
  getTokenIdForOwner: getTokenIdForOwner4,
  getKeyExpirationByLockForOwner: getKeyExpirationByLockForOwner4,
  approveBeneficiary,
  totalKeys: totalKeys4,
  updateLockName: updateLockName4,
  updateLockSymbol: updateLockSymbol4,
  setBaseTokenURI: setBaseTokenURI4,
  addLockManager: addLockManager3,
  renounceLockManager: renounceLockManager3,
  updateRefundPenalty: updateRefundPenalty4,
  updateTransferFee: updateTransferFee3,
  setKeyManagerOf: setKeyManagerOf2
} = v8_default;
var v9_default = {
  version: "v9",
  Unlock: abis_default.Unlock.v9,
  PublicLock: abis_default.PublicLock.v9,
  grantKey: grantKey2,
  grantKeys: grantKeys2,
  updateKeyPrice: updateKeyPrice3,
  withdrawFromLock: withdrawFromLock3,
  initializeTemplate: initializeTemplate3,
  isLockManager: isLockManager2,
  isKeyGranter: isKeyGranter2,
  addKeyGranter: addKeyGranter2,
  expireAndRefundFor: expireAndRefundFor2,
  cancelAndRefund: cancelAndRefund2,
  shareKey: shareKey3,
  getLock: getLock3,
  purchaseKey: purchaseKey_default3,
  purchaseKeys: purchaseKeys_default3,
  keyManagerOf,
  setMaxNumberOfKeys: setMaxNumberOfKeys_default,
  setExpirationDuration: setExpirationDuration_default,
  getCancelAndRefundValueFor: getCancelAndRefundValueFor3,
  getTokenIdForOwner: getTokenIdForOwner4,
  getKeyExpirationByLockForOwner: getKeyExpirationByLockForOwner4,
  approveBeneficiary,
  totalKeys: totalKeys4,
  updateLockName: updateLockName4,
  updateLockSymbol: updateLockSymbol4,
  setBaseTokenURI: setBaseTokenURI4,
  addLockManager: addLockManager3,
  renounceLockManager: renounceLockManager3,
  updateRefundPenalty: updateRefundPenalty4,
  setEventHooks: setEventHooks_default2,
  updateTransferFee: updateTransferFee3,
  setKeyManagerOf: setKeyManagerOf2,
  transferFrom: transferFrom_default,
  setGasRefundValue: setGasRefundValue_default
};

// src/PublicLock/v10/getPurchaseKeysArguments.js
async function getPurchaseKeysArguments2({
  owners: _owners,
  keyManagers: _keyManagers,
  keyPrices: _keyPrices,
  referrers: _referrers,
  lockAddress,
  erc20Address,
  recurringPayments,
  decimals,
  totalApproval,
  // explicit approval amount
  data: _data
}) {
  const lockContract = await this.getLockContract(lockAddress);
  if (!erc20Address) {
    erc20Address = await lockContract.tokenAddress();
  }
  const defaultOwner = await this.signer.getAddress();
  const owners = _owners || [defaultOwner];
  const defaultArray = Array(owners.length).fill(null);
  const keyPrices = await Promise.all(
    (_keyPrices || defaultArray).map(async (kp) => {
      if (!kp) {
        return await lockContract.keyPrice();
      }
      return formatKeyPrice_default(kp, erc20Address, decimals, this.provider);
    })
  );
  const keyManagers = (_keyManagers || defaultArray).map((km) => km || ZERO);
  const referrers = (_referrers || defaultArray).map((km) => km || ZERO);
  const data = (_data || defaultArray).map((d) => d || []);
  if (!(keyManagers.length === owners.length && keyPrices.length === owners.length && referrers.length === owners.length && data.length === owners.length)) {
    throw new Error(
      "Params mismatch. All purchaseKeys params array should have the same length"
    );
  }
  const totalPrice = keyPrices.reduce(
    (total, kp) => total.add(kp),
    utils_default.bigNumberify(0)
  );
  let totalAmountToApprove = totalApproval;
  if (!totalAmountToApprove) {
    totalAmountToApprove = recurringPayments ? keyPrices.map((kp, i) => kp.mul(recurringPayments[i])).reduce(
      (total, approval) => total.add(approval),
      utils_default.bigNumberify(0)
    ) : totalPrice;
  }
  return {
    owners,
    keyPrices,
    keyManagers,
    referrers,
    data,
    totalPrice,
    erc20Address,
    totalAmountToApprove
  };
}

// src/PublicLock/v10/purchaseKeys.js
async function purchaseKeys_default4(options, transactionOptions = {}, callback) {
  const { lockAddress, swap } = options;
  const lockContract = await this.getLockContract(lockAddress);
  const {
    owners,
    keyPrices,
    keyManagers,
    referrers,
    data,
    totalPrice,
    erc20Address,
    totalAmountToApprove
  } = await getPurchaseKeysArguments2.bind(this)(options);
  const unlockSwapPurchaserContract = swap ? this.getUnlockSwapPurchaserContract({
    params: {
      network: this.networkId
    }
  }) : null;
  const purchaseArgs = [keyPrices, owners, referrers, keyManagers, data];
  const callData = lockContract.interface.encodeFunctionData(
    "purchase",
    purchaseArgs
  );
  if (!erc20Address || erc20Address === ZERO) {
    transactionOptions.value = totalPrice;
  }
  if (swap && swap?.value) {
    transactionOptions.value = swap.value;
  }
  const approvalOptions = swap ? {
    erc20Address: swap.srcTokenAddress,
    address: unlockSwapPurchaserContract?.address,
    totalAmountToApprove: swap.amountInMax
  } : {
    erc20Address,
    totalAmountToApprove,
    address: lockAddress
  };
  if (approvalOptions.erc20Address && approvalOptions.erc20Address !== ZERO) {
    await approveAllowance.bind(this)(approvalOptions);
  }
  if (!transactionOptions.gasLimit) {
    const preserveGasSettings = transactionOptions.maxFeePerGas || transactionOptions.gasPrice;
    try {
      if (!preserveGasSettings) {
        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = await this.provider.getFeeData();
        if (maxFeePerGas && maxPriorityFeePerGas) {
          transactionOptions.maxFeePerGas = maxFeePerGas;
          transactionOptions.maxPriorityFeePerGas = maxPriorityFeePerGas;
        } else {
          transactionOptions.gasPrice = gasPrice;
        }
      }
      const gasLimitPromise = swap ? unlockSwapPurchaserContract?.estimateGas?.swapAndCall(
        lockAddress,
        swap.srcTokenAddress || ZERO,
        swap.amountInMax,
        swap.uniswapRouter,
        swap.swapCallData,
        callData,
        transactionOptions
      ) : lockContract.estimateGas.purchase(
        keyPrices,
        owners,
        referrers,
        keyManagers,
        data,
        transactionOptions
      );
      const gasLimit = await gasLimitPromise;
      transactionOptions.gasLimit = gasLimit.mul(13).div(10).toNumber();
    } catch (error) {
      console.error(
        "We could not estimate gas ourselves. Let wallet do it.",
        error
      );
    }
    if (!preserveGasSettings) {
      delete transactionOptions.maxFeePerGas;
      delete transactionOptions.maxPriorityFeePerGas;
      delete transactionOptions.gasPrice;
    }
  }
  const transactionRequestPromise = swap ? unlockSwapPurchaserContract?.populateTransaction?.swapAndCall(
    lockAddress,
    swap.srcTokenAddress || ZERO,
    swap.amountInMax,
    swap.uniswapRouter,
    swap.swapCallData,
    callData,
    transactionOptions
  ) : lockContract.populateTransaction.purchase(
    keyPrices,
    owners,
    referrers,
    keyManagers,
    data,
    transactionOptions
  );
  const transactionRequest = await transactionRequestPromise;
  if (transactionOptions.runEstimate) {
    const estimate = lockContract.signer.estimateGas(transactionRequest);
    return {
      transactionRequest,
      estimate
    };
  }
  const transactionPromise = lockContract.signer.sendTransaction(transactionRequest);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  if (receipt.status === 0) {
    throw new Error("Transaction failed");
  }
  const parser = lockContract.interface;
  const transferEvents = receipt.logs.map((log) => {
    if (log.address.toLowerCase() !== lockAddress.toLowerCase())
      return;
    return parser.parseLog(log);
  }).filter((event) => {
    return event && event.name === "Transfer";
  });
  if (transferEvents && transferEvents.length) {
    return transferEvents.map((v) => v.args.tokenId.toString());
  }
  return null;
}

// src/PublicLock/v10/purchaseKey.js
async function purchaseKey_default4({
  lockAddress,
  owner,
  keyManager,
  keyPrice,
  erc20Address,
  decimals,
  referrer,
  recurringPayments,
  // nb of reccuring payments to approve,
  totalApproval,
  // Explicit approval amount
  data
}, transactionOptions = {}, callback) {
  const keys = await purchaseKeys_default4.bind(this)(
    {
      owners: owner ? [owner] : null,
      keyManagers: keyManager ? [keyManager] : null,
      keyPrices: keyPrice ? [keyPrice] : null,
      referrers: referrer ? [referrer] : null,
      data: data ? [data] : null,
      recurringPayments: recurringPayments ? [recurringPayments] : null,
      lockAddress,
      erc20Address,
      totalApproval,
      decimals
    },
    transactionOptions,
    callback
  );
  return keys[0];
}

// src/PublicLock/v10/extendKey.js
async function extendKey_default({
  lockAddress,
  tokenId,
  keyPrice,
  erc20Address,
  decimals,
  referrer,
  data,
  totalApproval,
  recurringPayment,
  swap
}, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  if (!tokenId) {
    throw new Error("Missing tokenId.");
  }
  if (!referrer) {
    referrer = ZERO;
  }
  if (!data) {
    data = [];
  }
  if (!erc20Address) {
    erc20Address = await lockContract.tokenAddress();
  }
  let actualAmount;
  if (!keyPrice) {
    actualAmount = await lockContract.keyPrice();
  } else {
    actualAmount = await formatKeyPrice_default(
      keyPrice,
      erc20Address,
      decimals,
      this.provider
    );
  }
  const unlockSwapPurchaserContract = swap ? this.getUnlockSwapPurchaserContract({
    params: {
      network: this.networkId
    }
  }) : null;
  const extendArgs = [actualAmount, tokenId, referrer, data];
  const callData = lockContract.interface.encodeFunctionData(
    "extend",
    extendArgs
  );
  if (!erc20Address || erc20Address === ZERO) {
    transactionOptions.value = actualAmount;
  }
  if (swap && swap?.value) {
    transactionOptions.value = swap.value;
  }
  let totalAmountToApprove = totalApproval;
  if (!totalAmountToApprove) {
    totalAmountToApprove = recurringPayment ? actualAmount.mul(recurringPayment) : actualAmount;
  }
  const approvalOptions = swap ? {
    erc20Address: swap.srcTokenAddress,
    address: unlockSwapPurchaserContract?.address,
    totalAmountToApprove: swap.amountInMax
  } : {
    erc20Address,
    totalAmountToApprove,
    address: lockAddress
  };
  if (approvalOptions.erc20Address && approvalOptions.erc20Address !== ZERO) {
    await approveAllowance.bind(this)(approvalOptions);
  }
  if (!transactionOptions.gasLimit) {
    try {
      const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = await this.provider.getFeeData();
      if (maxFeePerGas && maxPriorityFeePerGas) {
        transactionOptions.maxFeePerGas = maxFeePerGas;
        transactionOptions.maxPriorityFeePerGas = maxPriorityFeePerGas;
      } else {
        transactionOptions.gasPrice = gasPrice;
      }
      const gasLimitPromise = swap ? unlockSwapPurchaserContract?.estimateGas?.swapAndCall(
        lockAddress,
        swap.srcTokenAddress || ZERO,
        swap.amountInMax,
        swap.uniswapRouter,
        swap.swapCallData,
        callData,
        transactionOptions
      ) : lockContract.estimateGas.extend(
        actualAmount,
        tokenId,
        referrer,
        data,
        transactionOptions
      );
      const gasLimit = await gasLimitPromise;
      delete transactionOptions.maxFeePerGas;
      delete transactionOptions.maxPriorityFeePerGas;
      delete transactionOptions.gasPrice;
      transactionOptions.gasLimit = gasLimit.mul(13).div(10).toNumber();
    } catch (error) {
      console.error(
        "We could not estimate gas ourselves. Let wallet do it.",
        error
      );
      delete transactionOptions.maxFeePerGas;
      delete transactionOptions.maxPriorityFeePerGas;
      delete transactionOptions.gasPrice;
    }
  }
  const transactionRequestpromise = swap ? unlockSwapPurchaserContract?.populateTransaction?.swapAndCall(
    lockAddress,
    swap.srcTokenAddress || ZERO,
    swap.amountInMax,
    swap.uniswapRouter,
    swap.swapCallData,
    callData,
    transactionOptions
  ) : lockContract.populateTransaction.extend(
    actualAmount,
    tokenId,
    referrer,
    data,
    transactionOptions
  );
  const transactionRequest = await transactionRequestpromise;
  if (transactionOptions.runEstimate) {
    const estimate = lockContract.signer.estimateGas(transactionRequest);
    return {
      transactionRequest,
      estimate
    };
  }
  const transactionPromise = lockContract.signer.sendTransaction(transactionRequest);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  return hash;
}

// src/PublicLock/v10/mergeKeys.js
async function mergeKeys_default({ lockAddress, tokenIdFrom, tokenIdTo, amount }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  if (!tokenIdFrom) {
    throw new Error("Missing tokenId from");
  }
  if (!tokenIdTo) {
    throw new Error("Missing tokenId to");
  }
  if (!amount) {
    const blockNumber = await this.provider.getBlockNumber();
    const { timestamp } = await this.provider.getBlock(blockNumber);
    const expiration = await lockContract.keyExpirationTimestampFor(tokenIdFrom);
    amount = utils_default.bigNumberify(expiration).sub(timestamp + 3);
  }
  const transactionPromise = lockContract.mergeKeys(
    tokenIdFrom,
    tokenIdTo,
    amount
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/v10/shareKey.js
async function shareKey_default2({ lockAddress, tokenId, recipient, duration }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  if (!tokenId) {
    throw new Error("shareKey: Missing token id from");
  }
  if (!duration) {
    const expiration = await lockContract.keyExpirationTimestampFor(tokenId);
    duration = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3) - expiration.toNumber();
  }
  const transactionPromise = lockContract.shareKey(
    recipient,
    tokenId,
    duration,
    transactionOptions
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  if (receipt.status === 0) {
    throw new Error("Transaction failed");
  }
  const parser = lockContract.interface;
  const transferEvent = receipt.logs.map((log) => {
    if (log.address.toLowerCase() !== lockAddress.toLowerCase())
      return;
    return parser.parseLog(log);
  }).filter((event) => {
    return event && event.name === "Transfer";
  })[0];
  if (transferEvent) {
    return transferEvent.args.tokenId.toString();
  }
  return null;
}

// src/PublicLock/v10/setMaxKeysPerAddress.js
async function setMaxKeysPerAddress_default({ lockAddress, maxKeysPerAddress }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.setMaxKeysPerAddress(maxKeysPerAddress);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
}

// src/PublicLock/v10/expireAndRefundFor.js
async function expireAndRefundFor_default2({ lockAddress, tokenId, amount = "0", decimals, erc20Address }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  if (!erc20Address || erc20Address !== ZERO) {
    erc20Address = await lockContract.tokenAddress();
  }
  if (decimals == null) {
    if (erc20Address !== ZERO) {
      decimals = await getErc20Decimals(erc20Address, this.provider);
    } else {
      decimals = 18;
    }
  }
  const actualAmount = utils_default.toDecimal(amount, decimals);
  const transactionPromise = lockContract.expireAndRefundFor(
    tokenId,
    actualAmount
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/v10/getTokenIdForOwner.js
async function getTokenIdForOwner_default2(lockAddress, owner, network) {
  const lockContract = await this.getLockContract(
    lockAddress,
    this.providerForNetwork(network)
  );
  const validTokens = [];
  const allTokens = [];
  const balanceOfTokens = (await lockContract.balanceOf(owner)).toNumber();
  let i = 0;
  while (i < balanceOfTokens) {
    let tokenId = (await lockContract.tokenOfOwnerByIndex(owner, i)).toNumber();
    if (tokenId) {
      allTokens.push(tokenId);
      let expiration = await lockContract.keyExpirationTimestampFor(tokenId);
      if (expiration > (/* @__PURE__ */ new Date()).getTime() * 1e3) {
        validTokens.push(tokenId);
      }
    }
    i++;
  }
  return validTokens[0] || allTokens[0] || 0;
}

// src/PublicLock/v10/getKeyExpirationByLockForOwner.js
async function getKeyExpirationByLockForOwner_default2(lockAddress, owner, network) {
  const lockContract = await this.getLockContract(
    lockAddress,
    this.providerForNetwork(network)
  );
  const tokenId = await getTokenIdForOwner_default2.bind(this)(
    lockAddress,
    owner,
    network
  );
  const expiration = await lockContract.keyExpirationTimestampFor(tokenId);
  if (expiration.eq(ETHERS_MAX_UINT)) {
    return -1;
  }
  return parseInt(expiration, 10);
}

// src/PublicLock/v10/getCancelAndRefundValueFor.js
async function getCancelAndRefundValueFor4({ lockAddress, tokenAddress, tokenId }, transactionOptions = {}, provider) {
  const lockContract = await this.getLockContract(lockAddress, provider);
  const value = await lockContract.getCancelAndRefundValue(tokenId);
  let refundValue;
  if (tokenAddress === ZERO) {
    refundValue = utils_default.fromWei(value, "ether");
  } else {
    refundValue = await getErc20Decimals(tokenAddress, this.provider);
  }
  return refundValue;
}
var getCancelAndRefundValueFor_default2 = getCancelAndRefundValueFor4;

// src/PublicLock/v10/getLock.js
async function getLock_default3(address, provider, options = {}) {
  const update = await parseLockGetters_default.bind(this)(address, provider, options);
  if (update.currencyContractAddress) {
    const erc20LockAllowance = await getAllowance(
      update.currencyContractAddress,
      address,
      provider,
      address
    );
    update.selfAllowance = erc20LockAllowance.toString();
  }
  return update;
}

// src/PublicLock/v10/renewMembershipFor.js
async function renewMembershipFor_default({ lockAddress, referrer, tokenId }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  if (!referrer) {
    referrer = ZERO;
  }
  if (!transactionOptions?.gasLimit) {
    try {
      const gasLimit = await lockContract.estimateGas.renewMembershipFor(
        tokenId,
        referrer,
        transactionOptions
      );
      transactionOptions.gasLimit = gasLimit.mul(13).div(10).toNumber();
    } catch (error) {
      console.error(
        "We could not estimate gas ourselves. Let wallet do it.",
        error
      );
    }
  }
  const transactionPromise = lockContract.renewMembershipFor(
    tokenId,
    referrer,
    transactionOptions
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  if (receipt.status === 0) {
    throw new Error("Transaction failed");
  }
  return tokenId;
}

// src/PublicLock/v10/index.js
var {
  grantKey: grantKey3,
  grantKeys: grantKeys3,
  updateKeyPrice: updateKeyPrice4,
  withdrawFromLock: withdrawFromLock4,
  initializeTemplate: initializeTemplate4,
  isLockManager: isLockManager3,
  isKeyGranter: isKeyGranter3,
  addKeyGranter: addKeyGranter3,
  cancelAndRefund: cancelAndRefund3,
  keyManagerOf: keyManagerOf2,
  setMaxNumberOfKeys: setMaxNumberOfKeys3,
  setExpirationDuration: setExpirationDuration2,
  approveBeneficiary: approveBeneficiary2,
  totalKeys: totalKeys5,
  updateLockName: updateLockName5,
  updateLockSymbol: updateLockSymbol5,
  setBaseTokenURI: setBaseTokenURI5,
  addLockManager: addLockManager4,
  renounceLockManager: renounceLockManager4,
  updateRefundPenalty: updateRefundPenalty5,
  setEventHooks: setEventHooks2,
  updateTransferFee: updateTransferFee4,
  setKeyManagerOf: setKeyManagerOf3,
  transferFrom,
  setGasRefundValue
} = v9_default;
var v10_default = {
  version: "v10",
  PublicLock: abis_default.PublicLock.v10,
  grantKey: grantKey3,
  grantKeys: grantKeys3,
  getPurchaseKeysArguments: getPurchaseKeysArguments2,
  extendKey: extendKey_default,
  updateKeyPrice: updateKeyPrice4,
  withdrawFromLock: withdrawFromLock4,
  initializeTemplate: initializeTemplate4,
  isLockManager: isLockManager3,
  isKeyGranter: isKeyGranter3,
  addKeyGranter: addKeyGranter3,
  expireAndRefundFor: expireAndRefundFor_default2,
  cancelAndRefund: cancelAndRefund3,
  shareKey: shareKey_default2,
  getLock: getLock_default3,
  purchaseKey: purchaseKey_default4,
  purchaseKeys: purchaseKeys_default4,
  mergeKeys: mergeKeys_default,
  keyManagerOf: keyManagerOf2,
  setMaxNumberOfKeys: setMaxNumberOfKeys3,
  setExpirationDuration: setExpirationDuration2,
  setMaxKeysPerAddress: setMaxKeysPerAddress_default,
  getTokenIdForOwner: getTokenIdForOwner_default2,
  getKeyExpirationByLockForOwner: getKeyExpirationByLockForOwner_default2,
  getCancelAndRefundValueFor: getCancelAndRefundValueFor_default2,
  approveBeneficiary: approveBeneficiary2,
  totalKeys: totalKeys5,
  renewMembershipFor: renewMembershipFor_default,
  updateLockName: updateLockName5,
  updateLockSymbol: updateLockSymbol5,
  setBaseTokenURI: setBaseTokenURI5,
  addLockManager: addLockManager4,
  renounceLockManager: renounceLockManager4,
  updateRefundPenalty: updateRefundPenalty5,
  setEventHooks: setEventHooks2,
  updateTransferFee: updateTransferFee4,
  setKeyManagerOf: setKeyManagerOf3,
  transferFrom,
  setGasRefundValue
};

// src/PublicLock/v11/grantKeyExtension.js
async function grantKeyExtension_default({ lockAddress, tokenId, duration = 0 }, transactionOptions = {}, callback) {
  if (!tokenId) {
    throw new Error("Missing tokenId.");
  }
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.grantKeyExtension(tokenId, duration);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/v11/totalKeys.js
async function totalKeys_default2(lockAddres, owner, provider) {
  const lockContract = await this.getLockContract(lockAddres, provider);
  return lockContract.totalKeys(owner);
}

// src/PublicLock/v11/setEventHooks.js
async function setEventHooks_default3({
  lockAddress,
  keyPurchase = ZERO,
  keyCancel = ZERO,
  validKey = ZERO,
  tokenURI = ZERO,
  keyTransfer = ZERO
}, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.setEventHooks(
    keyPurchase,
    keyCancel,
    validKey,
    tokenURI,
    keyTransfer
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/v11/setReferrerFee.js
async function setReferrerFee_default({ lockAddress, address, feeBasisPoint }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress, this.provider);
  const transactionPromise = lockContract.setReferrerFee(address, feeBasisPoint);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/v11/index.js
var v11_default = {
  ...v10_default,
  totalKeys: totalKeys_default2,
  grantKeyExtension: grantKeyExtension_default,
  setEventHooks: setEventHooks_default3,
  setReferrerFee: setReferrerFee_default,
  version: "v11",
  PublicLock: abis_default.PublicLock.v11
};

// src/PublicLock/v12/setMaxKeysPerAddress.js
async function setMaxKeysPerAddress_default2({ lockAddress, maxKeysPerAddress }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const expirationDuration = await lockContract.expirationDuration();
  const maxNumberOfKeys = await lockContract.maxNumberOfKeys();
  const supply = await lockContract.totalSupply();
  const transactionPromise = lockContract.updateLockConfig(
    expirationDuration,
    supply.lt(maxNumberOfKeys) ? maxNumberOfKeys : supply,
    maxKeysPerAddress
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
}

// src/PublicLock/v12/setMaxNumberOfKeys.js
async function setMaxNumberOfKeys4({ lockAddress, maxNumberOfKeys }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const maxKeysPerAddress = await lockContract.maxKeysPerAddress();
  const expirationDuration = await lockContract.expirationDuration();
  const supply = await lockContract.totalSupply();
  const transactionPromise = lockContract.updateLockConfig(
    expirationDuration,
    supply.lt(maxNumberOfKeys) ? maxNumberOfKeys : supply,
    maxKeysPerAddress
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
}
var setMaxNumberOfKeys_default2 = setMaxNumberOfKeys4;

// src/PublicLock/v12/setExpirationDuration.js
async function setExpirationDuration3({ lockAddress, expirationDuration }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const maxKeysPerAddress = await lockContract.maxKeysPerAddress();
  const maxNumberOfKeys = await lockContract.maxNumberOfKeys();
  const supply = await lockContract.totalSupply();
  const transactionPromise = lockContract.updateLockConfig(
    expirationDuration,
    supply.lt(maxNumberOfKeys) ? maxNumberOfKeys : supply,
    maxKeysPerAddress
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
}
var setExpirationDuration_default2 = setExpirationDuration3;

// src/PublicLock/v12/setBaseTokenURI.js
async function setBaseTokenURI6({ lockAddress, baseTokenURI }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const lockName = await lockContract.name();
  const lockSymbol = await lockContract.symbol();
  const transactionPromise = lockContract.setLockMetadata(
    lockName,
    lockSymbol,
    baseTokenURI
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
  return baseTokenURI;
}
var setBaseTokenURI_default2 = setBaseTokenURI6;

// src/PublicLock/v12/updateLockName.js
async function updateLockName6({ lockAddress, name: name2 }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const lockSymbol = await lockContract.symbol();
  const baseTokenURI = await lockContract.tokenURI(0);
  const transactionPromise = lockContract.setLockMetadata(
    name2,
    lockSymbol,
    baseTokenURI
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
  return name2;
}
var updateLockName_default2 = updateLockName6;

// src/PublicLock/v12/updateLockSymbol.js
async function updateLockSymbol6({ lockAddress, symbol }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const lockName = await lockContract.name();
  const baseTokenURI = await lockContract.tokenURI(0);
  const transactionPromise = lockContract.setLockMetadata(
    lockName,
    symbol,
    baseTokenURI
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
  return symbol;
}
var updateLockSymbol_default2 = updateLockSymbol6;

// src/PublicLock/v12/approveBeneficiary.js
async function approveBeneficiary_default2() {
  throw Error(
    "The concept of beneficiary has been deprecated in PublicLock v12"
  );
}

// src/PublicLock/v12/withdrawFromLock.js
async function withdrawFromLock_default3({ lockAddress, beneficiary, amount = "0", decimals, erc20Address }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const tokenAddress = erc20Address || await lockContract.tokenAddress();
  if (decimals == null) {
    if (tokenAddress && tokenAddress !== ZERO) {
      decimals = await getErc20Decimals(tokenAddress, this.provider);
    } else {
      decimals = 18;
    }
  }
  if (!beneficiary) {
    beneficiary = await this.signer.getAddress();
  }
  const actualAmount = utils_default.toDecimal(amount, decimals);
  const transactionPromise = lockContract["withdraw(address,address,uint256)"](
    tokenAddress,
    beneficiary,
    actualAmount
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  const parser = lockContract.interface;
  const withdrawalEvent = receipt.logs.map((log) => {
    if (log.address.toLowerCase() !== lockAddress.toLowerCase())
      return;
    return parser.parseLog(log);
  }).filter((event) => {
    return event && event.name === "Withdrawal";
  })[0];
  if (withdrawalEvent) {
    return utils_default.fromWei(withdrawalEvent.args.amount.toString(), "ether");
  }
  return null;
}

// src/PublicLock/v12/setEventHooks.js
async function setEventHooks_default4({
  lockAddress,
  keyPurchase = ZERO,
  keyCancel = ZERO,
  validKey = ZERO,
  tokenURI = ZERO,
  keyTransfer = ZERO,
  keyExtend = ZERO,
  keyGrant = ZERO
}, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const transactionPromise = lockContract.setEventHooks(
    keyPurchase,
    keyCancel,
    validKey,
    tokenURI,
    keyTransfer,
    keyExtend,
    keyGrant
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash);
  }
  await this.provider.waitForTransaction(hash);
  return null;
}

// src/PublicLock/v12/index.js
var v12_default = {
  ...v11_default,
  approveBeneficiary: approveBeneficiary_default2,
  setMaxKeysPerAddress: setMaxKeysPerAddress_default2,
  setExpirationDuration: setExpirationDuration_default2,
  setMaxNumberOfKeys: setMaxNumberOfKeys_default2,
  setBaseTokenURI: setBaseTokenURI_default2,
  updateLockName: updateLockName_default2,
  updateLockSymbol: updateLockSymbol_default2,
  withdrawFromLock: withdrawFromLock_default3,
  setEventHooks: setEventHooks_default4,
  version: "v12",
  PublicLock: abis_default.PublicLock.v12
};

// src/PublicLock/v13/addKeyGranter.js
import { ethers as ethers5 } from "ethers";
async function addKeyGranter_default2({ lockAddress, keyGranter }, transactionOptions = {}, callback) {
  const lockContract = await this.getLockContract(lockAddress);
  const keyGranterRole = ethers5.utils.keccak256(
    ethers5.utils.toUtf8Bytes("KEY_GRANTER")
  );
  const transactionPromise = lockContract.grantRole(keyGranterRole, keyGranter);
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  await this.provider.waitForTransaction(hash);
  return true;
}

// src/PublicLock/v13/isKeyGranter.js
import { ethers as ethers6 } from "ethers";
async function isKeyGranter_default2(lockAddress, address, provider) {
  const lockContract = await this.getLockContract(lockAddress, provider);
  const keyGranterRole = ethers6.utils.keccak256(
    ethers6.utils.toUtf8Bytes("KEY_GRANTER")
  );
  return lockContract.hasRole(keyGranterRole, address);
}

// src/PublicLock/v13/index.js
var v13_default = {
  ...v12_default,
  version: "v13",
  addKeyGranter: addKeyGranter_default2,
  isKeyGranter: isKeyGranter_default2,
  PublicLock: abis_default.PublicLock.v13
};

// src/PublicLock/index.ts
var PublicLock_default = {
  v4: v4_default,
  v6: v6_default,
  v7: v7_default,
  v8: v8_default,
  v9: v9_default,
  v10: v10_default,
  v11: v11_default,
  v12: v12_default,
  v13: v13_default
};

// src/Unlock/utils.ts
async function _getKeyPrice(lock, provider) {
  const currencyContractAddress = lock.currencyContractAddress || ZERO;
  if (typeof lock.keyPrice === "number") {
    lock.keyPrice = lock.keyPrice.toString();
  }
  if (currencyContractAddress !== ZERO) {
    const erc20Decimals = await getErc20Decimals(
      currencyContractAddress,
      provider
    );
    return utils_default.toDecimal(lock.keyPrice, erc20Decimals);
  }
  return utils_default.toWei(lock.keyPrice, "ether");
}

// src/Unlock/v4/createLock.js
async function createLock_default(lock, transactionOptions = {}, callback) {
  const unlockContract = await this.getUnlockContract();
  let { maxNumberOfKeys } = lock;
  if (!maxNumberOfKeys || maxNumberOfKeys === UNLIMITED_KEYS_COUNT) {
    maxNumberOfKeys = ETHERS_MAX_UINT;
  }
  const decimalKeyPrice = _getKeyPrice(lock, this.provider);
  const currencyContractAddress = lock.currencyContractAddress || ZERO;
  const lockName = lock.name || "New Lock";
  const transactionPromise = unlockContract.functions["createLock(uint256,address,uint256,uint256,string)"](
    lock.expirationDuration,
    currencyContractAddress,
    decimalKeyPrice,
    maxNumberOfKeys,
    lockName
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  const parser = unlockContract.interface;
  const newLockEvent = receipt.logs.map((log) => {
    try {
      return parser.parseLog(log);
    } catch {
      return {};
    }
  }).filter((event) => event.signature === "NewLock(address,address)")[0];
  if (newLockEvent) {
    return newLockEvent.args.newLockAddress;
  }
  return null;
}

// src/Unlock/v4/index.js
var v4_default2 = {
  createLock: createLock_default,
  version: "v4",
  Unlock: abis_default.Unlock.v4,
  PublicLock: abis_default.PublicLock.v4
};

// src/Unlock/v6/createLock.js
async function createLock_default2(lock, transactionOptions = {}, callback) {
  const unlockContract = await this.getUnlockContract();
  let { maxNumberOfKeys } = lock;
  if (!maxNumberOfKeys || maxNumberOfKeys === UNLIMITED_KEYS_COUNT) {
    maxNumberOfKeys = ETHERS_MAX_UINT;
  }
  const decimalKeyPrice = await _getKeyPrice(lock, this.provider);
  const currencyContractAddress = lock.currencyContractAddress || ZERO;
  const lockName = lock.name;
  const salt = utils_default.sha3(utils_default.utf8ToHex(lock.name)).substring(0, 26);
  const transactionPromise = unlockContract.createLock(
    lock.expirationDuration,
    currencyContractAddress,
    decimalKeyPrice,
    maxNumberOfKeys,
    lockName,
    salt
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  const parser = unlockContract.interface;
  const newLockEvent = receipt.logs.map((log) => {
    try {
      return parser.parseLog(log);
    } catch {
      return {};
    }
  }).filter((event) => event.name === "NewLock")[0];
  if (newLockEvent) {
    return newLockEvent.args.newLockAddress;
  }
  return null;
}

// src/Unlock/v6/index.js
var v6_default2 = {
  createLock: createLock_default2,
  version: "v6",
  Unlock: abis_default.Unlock.v6,
  PublicLock: abis_default.PublicLock.v6
};

// src/Unlock/v7/createLock.js
async function createLock_default3(lock, transactionOptions = {}, callback) {
  const unlockContract = await this.getUnlockContract();
  let { maxNumberOfKeys } = lock;
  if (!maxNumberOfKeys || maxNumberOfKeys === UNLIMITED_KEYS_COUNT) {
    maxNumberOfKeys = ETHERS_MAX_UINT;
  }
  const decimalKeyPrice = await _getKeyPrice(lock, this.provider);
  const currencyContractAddress = lock.currencyContractAddress || ZERO;
  const lockName = lock.name;
  const salt = utils_default.sha3(utils_default.utf8ToHex(lock.name)).substring(0, 26);
  const transactionPromise = unlockContract.createLock(
    lock.expirationDuration,
    currencyContractAddress,
    decimalKeyPrice,
    maxNumberOfKeys,
    lockName,
    salt
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  const parser = unlockContract.interface;
  const newLockEvent = receipt.logs.map((log) => {
    try {
      return parser.parseLog(log);
    } catch {
      return {};
    }
  }).filter((event) => event.name === "NewLock")[0];
  if (newLockEvent) {
    return newLockEvent.args.newLockAddress;
  }
  return null;
}

// src/Unlock/v7/index.js
var v7_default2 = {
  createLock: createLock_default3,
  version: "v7",
  Unlock: abis_default.Unlock.v7,
  PublicLock: abis_default.PublicLock.v7
};

// src/Unlock/v8/createLock.js
async function createLock_default4(lock, transactionOptions = {}, callback) {
  const unlockContract = await this.getUnlockContract();
  let { maxNumberOfKeys } = lock;
  if (!maxNumberOfKeys || maxNumberOfKeys === UNLIMITED_KEYS_COUNT) {
    maxNumberOfKeys = ETHERS_MAX_UINT;
  }
  const decimalKeyPrice = await _getKeyPrice(lock, this.provider);
  const currencyContractAddress = lock.currencyContractAddress || ZERO;
  const lockName = lock.name;
  const salt = utils_default.sha3(utils_default.utf8ToHex(lock.name)).substring(0, 26);
  const transactionPromise = unlockContract.createLock(
    lock.expirationDuration,
    currencyContractAddress,
    decimalKeyPrice,
    maxNumberOfKeys,
    lockName,
    salt
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  const parser = unlockContract.interface;
  const newLockEvent = receipt.logs.map((log) => {
    try {
      return parser.parseLog(log);
    } catch {
      return {};
    }
  }).filter((event) => event.name === "NewLock")[0];
  if (newLockEvent) {
    return newLockEvent.args.newLockAddress;
  }
  return null;
}

// src/Unlock/v8/index.js
var v8_default2 = {
  createLock: createLock_default4,
  version: "v8",
  Unlock: abis_default.Unlock.v8,
  PublicLock: abis_default.PublicLock.v8
};

// src/Unlock/v9/index.js
var { createLock } = v8_default2;
var v9_default2 = {
  createLock,
  version: "v9",
  Unlock: abis_default.Unlock.v9,
  PublicLock: abis_default.PublicLock.v9
};

// src/Unlock/v10/upgradeLock.js
async function upgradeLock_default(lockAddress, lockVersion, callback) {
  if (typeof lockVersion !== "number")
    throw Error("lockVersion should be a number");
  const unlockContract = await this.getUnlockContract();
  const transactionPromise = unlockContract.upgradeLock(
    lockAddress,
    lockVersion
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const receipt = await this.provider.waitForTransaction(hash);
  const parser = unlockContract.interface;
  const upgradeLockEvent = receipt.logs.map((log) => {
    if (log.address.toLowerCase() !== unlockContract.address.toLowerCase())
      return;
    return parser.parseLog(log);
  }).filter((event) => event && event.name === "LockUpgraded")[0];
  if (upgradeLockEvent) {
    return upgradeLockEvent.args.version;
  }
  return null;
}

// src/Unlock/v10/createLock.js
async function createLock_default5(lock, transactionOptions = {}, callback) {
  const unlockContract = await this.getUnlockContract();
  let { maxNumberOfKeys, expirationDuration } = lock;
  if (!maxNumberOfKeys || maxNumberOfKeys === UNLIMITED_KEYS_COUNT) {
    maxNumberOfKeys = ETHERS_MAX_UINT;
  }
  if (expirationDuration === -1) {
    expirationDuration = ETHERS_MAX_UINT;
  }
  const decimalKeyPrice = await _getKeyPrice(lock, this.provider);
  const currencyContractAddress = lock.currencyContractAddress || ZERO;
  const lockName = lock.name;
  const salt = utils_default.sha3(utils_default.utf8ToHex(lock.name)).substring(0, 26);
  const transactionPromise = unlockContract.createLock(
    expirationDuration,
    currencyContractAddress,
    decimalKeyPrice,
    maxNumberOfKeys,
    lockName,
    salt,
    transactionOptions
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const { logs } = await this.provider.waitForTransaction(hash);
  const parser = unlockContract.interface;
  const newLockEvent = logs.map((log) => {
    try {
      return parser.parseLog(log);
    } catch {
      return {};
    }
  }).filter((event) => event.name === "NewLock")[0];
  if (newLockEvent) {
    return newLockEvent.args.newLockAddress;
  }
  return null;
}

// src/Unlock/v10/index.js
var v10_default2 = {
  createLock: createLock_default5,
  upgradeLock: upgradeLock_default,
  version: "v10",
  Unlock: abis_default.Unlock.v10
};

// src/Unlock/v11/createLock.js
import { ethers as ethers7 } from "ethers";
async function createLock_default6(lock, transactionOptions = {}, callback) {
  const unlockContract = await this.getUnlockContract();
  const lockVersion = lock.publicLockVersion || await unlockContract.publicLockLatestVersion();
  let { maxNumberOfKeys, expirationDuration } = lock;
  if (!maxNumberOfKeys || maxNumberOfKeys === UNLIMITED_KEYS_COUNT) {
    maxNumberOfKeys = ETHERS_MAX_UINT;
  }
  if (expirationDuration === -1) {
    expirationDuration = ETHERS_MAX_UINT;
  }
  const decimalKeyPrice = await _getKeyPrice(lock, this.provider);
  const currencyContractAddress = lock.currencyContractAddress || ZERO;
  const lockName = lock.name;
  const signerAddress = await this.signer.getAddress();
  const lockCreator = lock.creator || signerAddress;
  if (!lockCreator) {
    throw new Error("No lock creator passed or found.");
  }
  const { abi: lockAbi } = abis_default.PublicLock[`v${lockVersion}`];
  const lockInterface = new ethers7.utils.Interface(lockAbi);
  const calldata = lockInterface.encodeFunctionData(
    "initialize(address,uint256,address,uint256,uint256,string)",
    [
      lockCreator,
      expirationDuration,
      currencyContractAddress,
      decimalKeyPrice,
      maxNumberOfKeys,
      lockName
    ]
  );
  const transactionPromise = unlockContract.createUpgradeableLockAtVersion(
    calldata,
    lockVersion,
    transactionOptions
  );
  const hash = await this._handleMethodCall(transactionPromise);
  if (callback) {
    callback(null, hash, await transactionPromise);
  }
  const { logs } = await this.provider.waitForTransaction(hash);
  const parser = unlockContract.interface;
  const newLockEvent = logs.map((log) => {
    try {
      return parser.parseLog(log);
    } catch {
      return {};
    }
  }).filter((event) => event.name === "NewLock")[0];
  if (newLockEvent) {
    return newLockEvent.args.newLockAddress;
  }
  return null;
}

// src/Unlock/v11/index.js
var { upgradeLock } = v10_default2;
var v11_default2 = {
  createLock: createLock_default6,
  upgradeLock,
  version: "v11",
  Unlock: abis_default.Unlock.v11
};

// src/Unlock/v12/index.ts
var { upgradeLock: upgradeLock2, createLock: createLock2 } = v11_default2;
var v12_default2 = {
  createLock: createLock2,
  upgradeLock: upgradeLock2,
  version: "v12",
  Unlock: abis_default.Unlock.v12
};

// src/Unlock/index.ts
var Unlock_default = {
  v4: v4_default2,
  v6: v6_default2,
  v7: v7_default2,
  v8: v8_default2,
  v9: v9_default2,
  v10: v10_default2,
  v11: v11_default2,
  v12: v12_default2
};

// src/unlockService.ts
var UnlockService = class {
  constructor(networks2) {
    this.networks = networks2;
    this.versionForAddress = {};
  }
  providerForNetwork(networkId) {
    if (!this.networks[networkId]) {
      throw new Error(`Missing config for ${networkId}`);
    }
    const ethersProvider = this.networks[networkId].ethersProvider;
    if (ethersProvider) {
      return ethersProvider;
    }
    return new ethers8.providers.JsonRpcBatchProvider(
      this.networks[networkId].provider,
      networkId
    );
  }
  /**
   * Checks if the contract has been deployed at the address.
   * Invokes the callback with the result.
   * Addresses which do not have a contract attached will return 0x
   */
  async isUnlockContractDeployed(network) {
    if (!this.networks[network]) {
      throw new Error(`Missing config for ${network}`);
    }
    let opCode = await this.providerForNetwork(network).getCode(this.networks[network].unlockAddress);
    return opCode !== "0x";
  }
  /**
   * @param {string} address contract address
   * @param {string} versionRetrievalMethodName the method to call to retrieve the contract version
   */
  async contractAbiVersion(address, versionRetrievalMethodName, provider) {
    const contractAddress = address.toLowerCase();
    let version = this.versionForAddress[contractAddress];
    if (version === void 0) {
      version = await this[versionRetrievalMethodName](
        contractAddress,
        provider
      );
      this.versionForAddress[contractAddress] = version;
    }
    const contractName = versionRetrievalMethodName.includes("PublicLock") ? "PublicLock" : "Unlock";
    if (contractName === "PublicLock" && PublicLock_default[`v${version}`]) {
      return PublicLock_default[`v${version}`];
    }
    if (contractName === "Unlock" && Unlock_default[`v${version}`]) {
      return Unlock_default[`v${version}`];
    }
    throw new Error(
      `Contract ${address} (${contractName}) not deployed on ${await provider.getNetwork()}, or unknown version ${version}`
    );
  }
  async unlockContractAbiVersion(address, provider) {
    return this.contractAbiVersion(
      address,
      "_getUnlockVersionFromContract",
      provider
    );
  }
  /**
   * Returns the ABI for the Lock contract deployed at the provided address
   * @param {*} address
   */
  async lockContractAbiVersion(address, provider) {
    return this.contractAbiVersion(
      address,
      "_getPublicLockVersionFromContract",
      provider
    );
  }
  /**
   * Private method, which given an address will query the lock and return the version of the lock
   * @param {*} address
   */
  async _getPublicLockVersionFromContract(address, provider) {
    const contract = new ethers8.Contract(
      address,
      ["function publicLockVersion() view returns (uint8)"],
      provider
    );
    let version = 0;
    try {
      const contractVersion = await contract.publicLockVersion();
      version = parseInt(contractVersion, 10) || 0;
    } catch (error) {
      console.error(error);
      console.error(
        `We could not retrieve the version of the Unlock contract ${address} on this network.`
      );
    }
    return version;
  }
  /**
   * Private method, which given an address will query the unlock contract to get its version
   * @param {*} address
   */
  async _getUnlockVersionFromContract(address, provider) {
    const contract = new ethers8.Contract(
      address,
      ["function unlockVersion() view returns (uint8)"],
      provider
    );
    let version = 0;
    try {
      const contractVersion = await contract.unlockVersion();
      version = parseInt(contractVersion, 10) || 0;
    } catch (error) {
      const opCode = await provider.getCode(address);
      const hash = ethers8.utils.sha256(opCode);
      if (hash === "0x886b9da11c0a665e98fd914bc79908925a4f6a549286de92ee6825e441a26309") {
        version = 1;
      }
    }
    return version;
  }
  getContract(address, contract, provider) {
    return new ethers8.Contract(address, contract.abi, provider);
  }
  async getLockContract(lockAddress, provider) {
    const version = await this.lockContractAbiVersion(lockAddress, provider);
    return this.getContract(lockAddress, version.PublicLock, provider);
  }
  async getUnlockContract(unlockAddress, provider) {
    const version = await this.unlockContractAbiVersion(unlockAddress, provider);
    return this.getContract(unlockAddress, version.Unlock, provider);
  }
  async getHookContract({
    network,
    address,
    abi
  }) {
    const provider = this.providerForNetwork(network);
    return new ethers8.Contract(address, abi, provider);
  }
};

// src/abis/passwordHookAbi.ts
var passwordHookAbi = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  { inputs: [], name: "NOT_AUTHORIZED", type: "error" },
  { inputs: [], name: "WRONG_PASSWORD", type: "error" },
  {
    inputs: [
      { internalType: "string", name: "message", type: "string" },
      { internalType: "bytes", name: "signature", type: "bytes" }
    ],
    name: "getSigner",
    outputs: [
      { internalType: "address", name: "recoveredAddress", type: "address" }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "bytes", name: "signature", type: "bytes" }
    ],
    name: "keyPurchasePrice",
    outputs: [
      { internalType: "uint256", name: "minKeyPrice", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "bytes", name: "", type: "bytes" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "onKeyPurchase",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "lock", type: "address" },
      { internalType: "address", name: "signer", type: "address" }
    ],
    name: "setSigner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "signers",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "toString",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "value", type: "uint256" }],
    name: "toString",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes", name: "data", type: "bytes" }],
    name: "toString",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "value", type: "bytes32" }],
    name: "toString",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "pure",
    type: "function"
  }
];

// src/abis/discountCodeHookAbi.ts
var discountCodeHookAbi = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  { inputs: [], name: "NOT_AUTHORIZED", type: "error" },
  { inputs: [], name: "TOO_BIG", type: "error" },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "discounts",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "string", name: "message", type: "string" },
      { internalType: "bytes", name: "signature", type: "bytes" }
    ],
    name: "getSigner",
    outputs: [
      { internalType: "address", name: "recoveredAddress", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "bytes", name: "signature", type: "bytes" }
    ],
    name: "keyPurchasePrice",
    outputs: [
      { internalType: "uint256", name: "minKeyPrice", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "bytes", name: "", type: "bytes" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "onKeyPurchase",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "lock", type: "address" },
      { internalType: "address", name: "signer", type: "address" },
      { internalType: "uint256", name: "discount", type: "uint256" }
    ],
    name: "setDiscountForLock",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "toString",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "value", type: "uint256" }],
    name: "toString",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes", name: "data", type: "bytes" }],
    name: "toString",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "value", type: "bytes32" }],
    name: "toString",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "pure",
    type: "function"
  }
];

// src/web3Service.ts
import {
  CurrencyAmount,
  Percent,
  TradeType
} from "@uniswap/sdk-core";
import { AlphaRouter, SwapType } from "@uniswap/smart-order-router";
var Web3Service = class extends UnlockService {
  /**
   * Method which returns the create2 address based on the factory contract (unlock), the lock template,
   * the account and lock salt (both used to create a unique salt)
   * 0x3d602d80600a3d3981f3363d3d373d3d3d363d73 and 5af43d82803e903d91602b57fd5bf3 are the
   * bytecode for eip-1167 (which defines proxies for locks).
   * @private
   */
  _create2Address(unlockAddress, templateAddress, account, lockSalt) {
    const saltHex = `${account}${lockSalt}`;
    const byteCode = `0x3d602d80600a3d3981f3363d3d373d3d3d363d73${templateAddress.replace(
      /0x/,
      ""
    )}5af43d82803e903d91602b57fd5bf3`;
    const byteCodeHash = utils_default.sha3(byteCode);
    const seed = ["ff", unlockAddress, saltHex, byteCodeHash].map((x) => x.replace(/0x/, "")).join("");
    const address = utils_default.sha3(`0x${seed}`).slice(-40);
    return utils_default.toChecksumAddress(`0x${address}`);
  }
  /**
   * Returns details about a transaction
   * @param {*} hash
   * @param {*} network
   * @returns
   */
  async getTransaction(hash, network) {
    return await this.providerForNetwork(network).getTransaction(hash);
  }
  /**
   * This retrieves the balance of an address (contract or account)
   * and formats it to a string of ether.
   * Returns a promise with the balance
   */
  async getAddressBalance(address, network, tokenAddress) {
    const provider = this.providerForNetwork(network);
    if (!tokenAddress) {
      const balance = await provider.getBalance(address);
      return utils_default.fromWei(balance, "ether");
    } else {
      const balancePromise = getErc20BalanceForAddress(
        tokenAddress,
        address,
        provider
      );
      const decimalsPromise = getErc20Decimals(tokenAddress, provider);
      const [balance, decimals] = await Promise.all([
        balancePromise,
        decimalsPromise
      ]);
      return utils_default.fromDecimal(balance, decimals);
    }
  }
  /**
   * Refresh the lock's data.
   * We use the block version
   * @return Promise<Lock>
   */
  async getLock(address, network, options = {
    fields: []
  }) {
    const networkConfig = this.networks[network];
    if (!(networkConfig && networkConfig.unlockAddress)) {
      throw new Error(
        "No unlock factory contract address found in the networks config."
      );
    }
    const provider = this.providerForNetwork(network);
    const version = await this.lockContractAbiVersion(
      address,
      this.providerForNetwork(network)
    );
    const lock = await version.getLock.bind(this)(
      address,
      this.providerForNetwork(network),
      options
    );
    lock.address = address;
    lock.unlockContractAddress = ethers9.utils.getAddress(
      lock.unlockContractAddress
    );
    const previousDeployAddresses = (networkConfig.previousDeploys || []).map(
      (d) => ethers9.utils.getAddress(d.unlockAddress)
    );
    const isPreviousUnlockContract = previousDeployAddresses.includes(
      lock.unlockContractAddress
    );
    const isUnlockContract = ethers9.utils.getAddress(networkConfig.unlockAddress) === lock.unlockContractAddress;
    if (!isUnlockContract && !isPreviousUnlockContract) {
      throw new Error(
        "This contract is not deployed from Unlock factory contract."
      );
    }
    const unlockContract = await this.getUnlockContract(
      lock.unlockContractAddress,
      provider
    );
    const response = await unlockContract.locks(address);
    if (!response.deployed) {
      throw new Error(
        "This contract is not deployed from Unlock factory contract."
      );
    }
    return lock;
  }
  /**
   * Tell whether a user is a manager for the lock
   * @param {string} lockAddress
   * @param {string} manager
   * @return Promise<boolean>
   */
  async isLockManager(lockAddress, manager, network) {
    const version = await this.lockContractAbiVersion(
      lockAddress,
      this.providerForNetwork(network)
    );
    if (!version.isLockManager) {
      throw new Error("Lock version not supported");
    }
    return version.isLockManager.bind(this)(
      lockAddress,
      manager,
      this.providerForNetwork(network)
    );
  }
  /**
   * Returns the key to the lock by the token Id.
   * @param {PropTypes.string} lockAddress
   * @param {PropTypes.number} tokenId
   */
  async getKeyByTokenId(lockAddress, tokenId, network) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    if (await lockContract.publicLockVersion() < 10) {
      throw new Error("Only available for Lock v10+");
    }
    const expirationPromise = this.getKeyExpirationByTokenId(
      lockAddress,
      tokenId,
      network
    );
    const ownerPromise = this.ownerOf(lockAddress, tokenId, network);
    const [owner, expiration] = await Promise.all([
      ownerPromise,
      expirationPromise
    ]);
    const keyPayload = {
      tokenId,
      lock: lockAddress,
      owner,
      expiration
    };
    return keyPayload;
  }
  /**
   * Returns the key expiration to the lock by the account.
   * @private
   * @param {PropTypes.string} lockAddress
   * @param {number} tokenId
   * @return Promise<>
   */
  async getKeyExpirationByTokenId(lockAddress, tokenId, network) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    if (await lockContract.publicLockVersion() < 10) {
      throw new Error("Only available for Lock v10+");
    }
    try {
      const expiration = await lockContract.keyExpirationTimestampFor(tokenId);
      if (expiration == "3963877391197344453575983046348115674221700746820753546331534351508065746944") {
        return 0;
      }
      if (expiration.eq(ETHERS_MAX_UINT)) {
        return -1;
      }
      return parseInt(expiration, 10);
    } catch (error) {
      return 0;
    }
  }
  /**
   * Returns the key to the lock by the account.
   * @param {PropTypes.string} lockAddress
   * @param {PropTypes.string} owner
   */
  async getKeyByLockForOwner(lockAddress, owner, network) {
    const keyPayload = {
      lock: lockAddress,
      owner,
      expiration: 0,
      tokenId: 0
    };
    const tokenIdPromise = this.getTokenIdForOwner(lockAddress, owner, network);
    const expirationPromise = this.getKeyExpirationByLockForOwner(
      lockAddress,
      owner,
      network
    );
    const [tokenId, expiration] = await Promise.all([
      tokenIdPromise,
      expirationPromise
    ]);
    keyPayload.tokenId = tokenId;
    keyPayload.expiration = expiration;
    return keyPayload;
  }
  /**
   * Returns true if the address has a valid key (will call the hook when applicable!)
   * @param lockAddress
   * @param owner
   * @param network
   */
  async getHasValidKey(lockAddress, owner, network) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    return lockContract.getHasValidKey(owner);
  }
  /**
   * Returns the key expiration to the lock by the account.
   * @private
   * @param {PropTypes.string} lockAddress
   * @param {PropTypes.string} owner
   * @return Promise<>
   */
  async getKeyExpirationByLockForOwner(lockAddress, owner, network) {
    const version = await this.lockContractAbiVersion(
      lockAddress,
      this.providerForNetwork(network)
    );
    return version.getKeyExpirationByLockForOwner.bind(this)(
      lockAddress,
      owner,
      network
    );
  }
  /**
   * Returns the key expiration to the lock by the account.
   * @private
   * @param {PropTypes.string} lockAddress
   * @param {PropTypes.string} owner
   * @return Promise<>
   */
  async getTokenIdForOwner(lockAddress, owner, network) {
    const version = await this.lockContractAbiVersion(
      lockAddress,
      this.providerForNetwork(network)
    );
    return version.getTokenIdForOwner.bind(this)(lockAddress, owner, network);
  }
  /**
   * Given some data and a signed version of the same, returns the address of the account that signed it
   * @param data
   * @param signedData
   * @returns {Promise<*>}
   */
  async recoverAccountFromSignedData(data, signedData) {
    return utils_default.verifyMessage(data, signedData);
  }
  /**
   * Given an ERC20 token contract address, resolve with the symbol that identifies that token.
   * @param {string} contractAddress
   * @returns {Promise<string>}
   */
  async getTokenSymbol(contractAddress, network) {
    const symbolPromise = getErc20TokenSymbol(
      contractAddress,
      this.providerForNetwork(network)
    );
    return symbolPromise;
  }
  /**
   * Given an ERC20 token contract address, resolve with the provided user's balance of that token.
   * @param {string} contractAddress
   * @param {string} userWalletAddress
   * @returns {Promise<string>}
   */
  async getTokenBalance(contractAddress, userWalletAddress, network) {
    const balancePromise = getErc20BalanceForAddress(
      contractAddress,
      userWalletAddress,
      this.providerForNetwork(network)
    );
    const decimalsPromise = getErc20Decimals(
      contractAddress,
      this.providerForNetwork(network)
    );
    const [balance, decimals] = await Promise.all([
      balancePromise,
      decimalsPromise
    ]);
    return utils_default.fromDecimal(balance, decimals);
  }
  async getTokenDecimals(contractAddress, network) {
    const provider = this.providerForNetwork(network);
    const decimals = await getErc20Decimals(contractAddress, provider);
    return decimals;
  }
  /**
   * Yields true if an address is key granter on a lock
   */
  async isKeyGranter(lockAddress, address, network) {
    const version = await this.lockContractAbiVersion(
      lockAddress,
      this.providerForNetwork(network)
    );
    if (!version.isKeyGranter) {
      throw new Error("Lock version not supported");
    }
    return version.isKeyGranter.bind(this)(
      lockAddress,
      address,
      this.providerForNetwork(network)
    );
  }
  /**
   * Retrieves the key manager for a key
   * @param {*} lockAddress
   * @param {*} tokenId
   * @param {*} network
   */
  async keyManagerOf(lockAddress, tokenId, network) {
    const version = await this.lockContractAbiVersion(
      lockAddress,
      this.providerForNetwork(network)
    );
    if (!version.keyManagerOf) {
      throw new Error("Lock version not supported");
    }
    return version.keyManagerOf.bind(this)(
      lockAddress,
      tokenId,
      this.providerForNetwork(network)
    );
  }
  /**
   * Returns the owner of a key
   * @param {*} lockAddress
   * @param {*} tokenId
   * @param {*} network
   */
  async ownerOf(lockAddress, tokenId, network) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    return lockContract.ownerOf(tokenId);
  }
  /**
   * Returns id a key is valid or not
   * @param {*} lockAddress
   * @param {*} tokenId
   * @param {*} network
   */
  async isValidKey(lockAddress, tokenId, network) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    return lockContract.isValidKey(tokenId);
  }
  /**
   * Returns the Ethers contract 'connected' (should be used with care)
   * @param {*} lockAddress
   * @param {*} network
   */
  async lockContract(lockAddress, network) {
    return await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
  }
  /**
   * Returns numbers of owners for a specific lock
   * @param {*} lockAddress
   * @param {*} network
   */
  async numberOfOwners(lockAddress, network) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    return ethers9.BigNumber.from(await lockContract.numberOfOwners()).toNumber();
  }
  /**
   * Returns transfer fee for lock
   * @param {*} lockAddress
   * @param {*} network
   */
  async transferFeeBasisPoints(lockAddress, network) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    if (!lockContract.transferFeeBasisPoints) {
      throw new Error("Lock version is not supported");
    }
    return ethers9.BigNumber.from(
      await lockContract.transferFeeBasisPoints()
    ).toNumber();
  }
  /**
   * Returns total of key for a specific address
   * @param {String} lockAddress
   * @param {String} address
   * @param {Number} network
   */
  async totalKeys(lockAddress, owner, network) {
    const version = await this.lockContractAbiVersion(
      lockAddress,
      this.providerForNetwork(network)
    );
    if (!version.totalKeys) {
      throw new Error("Lock version not supported");
    }
    const count = await version.totalKeys.bind(this)(
      lockAddress,
      owner,
      this.providerForNetwork(network)
    );
    return count.toNumber();
  }
  /**
   * Returns lock version
   * @param {String} lockAddress
   * @param {Number} network
   */
  async publicLockVersion(lockAddress, network) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    return await lockContract.publicLockVersion();
  }
  async tokenURI(lockAddress, tokenId, network) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    return await lockContract.tokenURI(tokenId);
  }
  /**
   * Returns the number of keys available for sale
   * @param lockAddress
   * @param network
   * @returns
   */
  async keysAvailable(lockAddress, network) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const totalSupplyPromise = lockContract.totalSupply();
    const maxNumberOfKeysPromise = lockContract.maxNumberOfKeys();
    const [totalSupply, maxNumberOfKeys] = await Promise.all([
      totalSupplyPromise,
      maxNumberOfKeysPromise
    ]);
    return maxNumberOfKeys.sub(totalSupply);
  }
  /**
   * Returns how much of a refund a key owner would receive
   * @param lockAddress
   * @param network
   * @param owner
   * @param tokenAddress
   * @param tokenId
   * @returns
   */
  async getCancelAndRefundValueFor(params, transactionOptions, callback) {
    const { lockAddress, network } = params;
    const version = await this.lockContractAbiVersion(
      lockAddress,
      this.providerForNetwork(network)
    );
    if (!version.getCancelAndRefundValueFor) {
      throw new Error("Lock version not supported");
    }
    return await version.getCancelAndRefundValueFor.bind(this)(
      params,
      transactionOptions,
      this.providerForNetwork(network)
    );
  }
  // For <= v10, it returns the total number of keys.
  // Starting with v11, it returns the total number of valid
  async balanceOf(lockAddress, owner, network) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const balance = await lockContract.balanceOf(owner);
    return balance.toNumber();
  }
  // Return key ID of owner at the specified index.
  // If a owner has multiple keys, you can iterate over all of them starting from 0 as index until you hit a zero value which implies no more.
  async tokenOfOwnerByIndex(lockAddress, owner, index, network) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const id = await lockContract.tokenOfOwnerByIndex(owner, index);
    return id.toNumber();
  }
  // Return the latest key ID of owner.
  async latestTokenOfOwner(lockAddress, owner, network) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const totalKeys6 = await lockContract.totalKeys(owner);
    if (totalKeys6.gt(0)) {
      const id = await lockContract.tokenOfOwnerByIndex(owner, totalKeys6.sub(1));
      return id.toNumber();
    }
    return null;
  }
  /**
   * Returns the number of keys already sold
   * @param lockAddress
   * @param network
   * @returns
   */
  async totalSupply(lockAddress, network) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    return await lockContract.totalSupply();
  }
  /**
   * Returns the purchase price for the user on the lock
   */
  async purchasePriceFor({
    lockAddress,
    userAddress,
    data,
    referrer,
    network
  }) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const price = await lockContract.purchasePriceFor(
      userAddress,
      referrer,
      data
    );
    return price;
  }
  /**
   * Returns freeTrialLength value
   */
  async freeTrialLength({
    lockAddress,
    network
  }) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const freeTrialLength = await lockContract.freeTrialLength();
    return ethers9.BigNumber.from(freeTrialLength).toNumber();
  }
  /**
   * Returns refundPenaltyBasisPoints value
   */
  async refundPenaltyBasisPoints({
    lockAddress,
    network
  }) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const refundPenaltyBasisPoints = await lockContract.refundPenaltyBasisPoints();
    return ethers9.BigNumber.from(refundPenaltyBasisPoints).toNumber();
  }
  /**
   * Returns onKeyCancelHook value
   */
  async onKeyCancelHook({
    lockAddress,
    network
  }) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const address = await lockContract.onKeyCancelHook();
    return address;
  }
  /**
   * Returns onKeyPurchaseHook value
   */
  async onKeyPurchaseHook({
    lockAddress,
    network
  }) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const address = await lockContract.onKeyPurchaseHook();
    return address;
  }
  /**
   * Returns onKeyTransferHook value
   */
  async onKeyTransferHook({
    lockAddress,
    network
  }) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const address = await lockContract.onKeyTransferHook();
    return address;
  }
  /**
   * Returns onTokenURIHook value
   */
  async onTokenURIHook({
    lockAddress,
    network
  }) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const address = await lockContract.onTokenURIHook();
    return address;
  }
  /**
   * Returns onValidKeyHook value
   */
  async onValidKeyHook({
    lockAddress,
    network
  }) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const address = await lockContract.onValidKeyHook();
    return address;
  }
  /**
   * Returns onKeyExtendHook value
   */
  async onKeyExtendHook({
    lockAddress,
    network
  }) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const address = await lockContract.onKeyExtendHook();
    return address;
  }
  /**
   * Returns onKeyGrantHook value
   */
  async onKeyGrantHook({
    lockAddress,
    network
  }) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const address = await lockContract.onKeyGrantHook();
    return address;
  }
  /**
   * Returns last lock version
   * @param {Number} network
   */
  async publicLockLatestVersion(network) {
    const provider = this.providerForNetwork(network);
    const networkConfig = this.networks[network];
    const unlockAddress = networkConfig.unlockAddress;
    if (!unlockAddress) {
      throw new Error("unlockAddress is not defined for the provided network. ");
    }
    const unlockContract = await this.getUnlockContract(unlockAddress, provider);
    return await unlockContract.publicLockLatestVersion();
  }
  /**
   * Returns referrer fees
   */
  async referrerFees({
    lockAddress,
    network,
    address
  }) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const referrerFees = await lockContract.referrerFees(address);
    return ethers9.BigNumber.from(referrerFees).toNumber();
  }
  async getBaseTokenURI({
    lockAddress,
    network
  }) {
    const lockContract = await this.getLockContract(
      lockAddress,
      this.providerForNetwork(network)
    );
    const tokenURI = await lockContract.tokenURI(1);
    const baseTokenURI = tokenURI.substring(0, tokenURI.lastIndexOf("/") + 1);
    return baseTokenURI;
  }
  /**
   * Returns an object the contains the resolved address or ens
   * name of the input address with it's type
   */
  async resolveName(addressOrEns) {
    const provider = this.providerForNetwork(1);
    try {
      const address = addressOrEns.trim();
      const isNotENS = ethers9.utils.isAddress(address);
      if (isNotENS) {
        return {
          input: address,
          address,
          name: address,
          type: "address"
        };
      } else {
        const name2 = address;
        const resolvedName = await provider.resolveName(address);
        if (resolvedName) {
          return {
            input: address,
            name: name2,
            address: resolvedName,
            type: "name"
          };
        } else {
          return {
            input: address,
            name: name2,
            address: resolvedName,
            type: "error"
          };
        }
      }
    } catch (err) {
      console.error(err);
      return "";
    }
  }
  /**
   * Get signer for `Password hook contract`
   */
  async getPasswordHookSigners(params) {
    const { lockAddress, contractAddress, network } = params ?? {};
    const contract = await this.getHookContract({
      network,
      address: contractAddress,
      abi: passwordHookAbi
    });
    return contract.signers(lockAddress);
  }
  async getUniswapRoute({
    params: { tokenOut, amountOut, recipient, tokenIn, network }
  }) {
    const provider = this.providerForNetwork(network);
    const networkConfig = this.networks[network];
    const router = new AlphaRouter({
      chainId: network,
      provider
    });
    const outputAmount = CurrencyAmount.fromRawAmount(tokenOut, amountOut);
    const routeArgs = [
      outputAmount,
      tokenIn,
      TradeType.EXACT_OUTPUT,
      {
        type: SwapType.UNIVERSAL_ROUTER,
        recipient,
        slippageTolerance: new Percent(15, 100),
        deadline: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3 + 60 * 60)
        // 1 hour
      }
    ];
    const swapResponse = await router.route(...routeArgs);
    if (!swapResponse) {
      throw new Error("No route found");
    }
    const {
      methodParameters,
      quote,
      quoteGasAdjusted,
      estimatedGasUsedUSD,
      trade
    } = swapResponse;
    const amountInMax = utils_default.currencyAmountToBigNumber(quote);
    const { calldata: swapCalldata, value, to: swapRouter } = methodParameters;
    const ratio = 1 / Number(trade.executionPrice.toFixed(6));
    const convertToQuoteToken = (value2) => {
      return Number(value2) * ratio;
    };
    return {
      swapCalldata,
      value,
      amountInMax,
      swapRouter: (
        // use hard coded router when available
        networkConfig?.uniswapV3?.universalRouterAddress || swapRouter
      ),
      quote,
      trade,
      convertToQuoteToken,
      quoteGasAdjusted,
      estimatedGasUsedUSD
    };
  }
  async getTokenIdsFromTx({
    params: { hash, network, lockAddress }
  }) {
    const provider = this.providerForNetwork(network);
    const lockContract = await this.getLockContract(lockAddress, provider);
    const txReceipt = await provider.getTransactionReceipt(hash);
    const parser = lockContract.interface;
    const events = txReceipt.logs.map((log) => {
      if (log.address.toLowerCase() !== lockAddress.toLowerCase())
        return;
      return parser.parseLog(log);
    });
    const purchaseItems = events.filter((event) => {
      return event && event.name === "Transfer";
    });
    if (purchaseItems.length) {
      return purchaseItems.map((item) => item?.args?.tokenId?.toString());
    }
    const extendItems = events.filter((event) => {
      return event && event.name === "KeyExtended";
    });
    if (extendItems.length) {
      return extendItems.map((item) => item?.args?.tokenId?.toString());
    }
    return null;
  }
  async getGasRefundValue({
    network,
    lockAddress
  }) {
    const provider = this.providerForNetwork(network);
    const lockContract = await this.getLockContract(lockAddress, provider);
    if (!lockContract.gasRefundValue) {
      return "0";
    }
    const gasRefund = await lockContract.gasRefundValue();
    let decimals = this.networks[network].nativeCurrency.decimals;
    const erc20Address = await lockContract.tokenAddress();
    if (erc20Address !== ethers9.constants.AddressZero) {
      decimals = await getErc20Decimals(erc20Address, provider);
    }
    return ethers9.utils.formatUnits(gasRefund, decimals);
  }
  /**
   * Get signer for `Password hook contract`
   */
  async getDiscountHookValues(params) {
    const { lockAddress, contractAddress, network, signerAddress } = params ?? {};
    const contract = await this.getHookContract({
      network,
      address: contractAddress,
      abi: discountCodeHookAbi
    });
    const discountForSigner = await contract.discounts(
      lockAddress,
      signerAddress
    );
    return ethers9.BigNumber.from(discountForSigner).toNumber();
  }
};

// src/walletService.ts
import { ethers as ethers11 } from "ethers";

// src/abis/UnlockSwapPurchaserABI.ts
var UnlockSwapPurchaserABI = [
  `function swapAndCall(address lock, address srcToken, uint amountInMax,address uniswapRouter, bytes memory swapCalldata, bytes memory callData) public payable returns(bytes memory)`
];

// src/CardPurchaser.ts
import { ethers as ethers10 } from "ethers";

// src/abis/CardPurchaserABI.ts
var CardPurchaserABI = [
  {
    inputs: [
      { internalType: "address", name: "_owner", type: "address" },
      { internalType: "address", name: "_unlockAddress", type: "address" },
      { internalType: "address", name: "_usdc", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  { inputs: [], name: "LOCK_CALL_FAILED", type: "error" },
  { inputs: [], name: "MISSING_LOCK", type: "error" },
  { inputs: [], name: "PURCHASER_DOES_NOT_MATCH_PAYER", type: "error" },
  { inputs: [], name: "SIGNER_DOES_NOT_MATCH", type: "error" },
  { inputs: [], name: "TOO_LATE", type: "error" },
  { inputs: [], name: "TOO_MUCH_SPENT", type: "error" },
  { inputs: [], name: "WITHDRAW_FAILED", type: "error" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "from", type: "address" },
          { internalType: "address", name: "to", type: "address" },
          { internalType: "uint256", name: "value", type: "uint256" },
          { internalType: "uint256", name: "validAfter", type: "uint256" },
          { internalType: "uint256", name: "validBefore", type: "uint256" },
          { internalType: "bytes32", name: "nonce", type: "bytes32" }
        ],
        internalType: "struct CardPurchaser.ApprovalMessage",
        name: "approvalMessage",
        type: "tuple"
      },
      { internalType: "bytes", name: "approvalSignature", type: "bytes" },
      {
        components: [
          { internalType: "address", name: "lock", type: "address" },
          { internalType: "address", name: "sender", type: "address" },
          { internalType: "uint256", name: "expiration", type: "uint256" }
        ],
        internalType: "struct CardPurchaser.PurchaseMessage",
        name: "purchaseMessage",
        type: "tuple"
      },
      { internalType: "bytes", name: "purchaseSignature", type: "bytes" },
      { internalType: "bytes", name: "callData", type: "bytes" }
    ],
    name: "purchase",
    outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockAddress",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "usdc",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tokenAddress", type: "address" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "withdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// src/CardPurchaser.ts
var PurchaseTypes = {
  Purchase: [
    { name: "lock", type: "address" },
    { name: "sender", type: "address" },
    { name: "expiration", type: "uint256" }
  ]
};
var CardPurchaser = class {
  constructor(networks2) {
    this.networks = networks2 || networks;
  }
  providerForNetwork(network) {
    if (!this.networks[network]) {
      throw new Error(`Missing config for ${network}`);
    }
    return new ethers10.providers.JsonRpcBatchProvider(
      this.networks[network].provider,
      network
    );
  }
  /**
   * Returns the contract
   * @param param0
   * @returns
   */
  getContract({ network, signer }) {
    const networkConfig = this.networks[network];
    const cardPurchaserContractAddress = networkConfig?.universalCard?.cardPurchaserAddress;
    if (!cardPurchaserContractAddress) {
      throw new Error("No card purchaser contract address found for network");
    }
    const provider = this.providerForNetwork(network);
    const cardPurchaserContract = new ethers10.Contract(
      cardPurchaserContractAddress,
      CardPurchaserABI,
      provider
    );
    if (signer) {
      return cardPurchaserContract.connect(signer);
    }
    return cardPurchaserContract;
  }
  async getDomain(network) {
    const contract = this.getContract({ network });
    const [name2, version] = await Promise.all([
      contract.name(),
      contract.version()
    ]);
    return {
      name: name2,
      version,
      chainId: network,
      verifyingContract: contract.address
    };
  }
  /**
   * Returns a message and corresponding signature to perform a purchase
   * These will be submitted to the purchase function on the CardPurchaser contract
   * @param network
   * @param lockAddress
   * @param signer
   * @returns
   */
  async getPurchaseAuthorizationSignature(network, lockAddress, signer) {
    const networkConfig = this.networks[network];
    const cardPurchaserAddress = networkConfig?.universalCard?.cardPurchaserAddress;
    if (!cardPurchaserAddress) {
      throw new Error("Card Purchaser not available for this network");
    }
    const domain = await this.getDomain(network);
    const now = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    const message = {
      sender: await signer.getAddress(),
      lock: lockAddress,
      expiration: now + 60 * 60
      // 1 hour!
    };
    const signature = await signer._signTypedData(
      domain,
      PurchaseTypes,
      message
    );
    return { signature, message };
  }
  /**
   *
   * @param network
   * @param transfer
   * @param purchase
   * @param callData
   * @param signer
   */
  async purchase(network, transfer, purchase, callData, signer) {
    const contract = this.getContract({ network });
    return contract.connect(signer).purchase(
      transfer.message,
      transfer.signature,
      purchase.message,
      purchase.signature,
      callData
    );
  }
};

// src/walletService.ts
var WalletService = class extends UnlockService {
  /**
   * This needs to be called with a ethers.providers which includes a signer or with a signer
   */
  async connect(provider, signer) {
    this.provider = provider;
    if (signer) {
      this.signer = signer;
    } else {
      this.signer = this.provider.getSigner(0);
    }
    const { chainId: networkId } = await this.provider.getNetwork();
    if (this.networkId !== networkId) {
      this.networkId = networkId;
    }
    if (!this.networks[networkId]) {
      throw new Error(`Missing config for ${networkId}`);
    }
    if (this.networks[networkId].unlockAddress) {
      this.unlockAddress = this.networks[networkId].unlockAddress;
    }
    return networkId;
  }
  /**
   * Function which yields the address of the account on the provider
   */
  async getAccount() {
    const accounts = await this.provider.listAccounts();
    if (!accounts.length) {
      return null;
    }
    const address = accounts[0];
    return address;
  }
  /**
   * This function submits a web3 transaction and will trigger an event as soon as it receives its
   * hash. We then use the web3Service to handle the ongoing transaction (watch for confirmation
   * receipt... etc)
   * A the moment the dispatcher relies on the strict emission, it is imperitive that the emission
   * of these fields not change for the time being!
   * @private
   * @param {Promise} the result of calling a contract method (ethersjs contract)
   * @param {string} the Unlock protocol transaction type
   * @param {Function} a standard node callback that accepts the transaction hash
   */
  // eslint-disable-next-line no-underscore-dangle
  // TODO: Do we need this???
  async _handleMethodCall(methodCall) {
    const transaction = await methodCall;
    if (transaction.hash) {
      return transaction.hash;
    }
    const finalTransaction = await transaction.wait();
    return finalTransaction.hash;
  }
  /**
   * Updates the key price on a lock
   * @param {PropTypes.address} lockAddress : address of the lock for which we update the price
   * @param {string} price : new price for the lock
   * @param {function} callback : callback invoked with the transaction hash
   * @return Promise<PropTypes.number> newKeyPrice
   */
  async updateKeyPrice(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    return version.updateKeyPrice.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Creates a lock on behalf of the user.
   * @param {PropTypes.lock} lock
   * @param {function} callback : callback invoked with the transaction hash
   * @return Promise<PropTypes.address> lockAddress
   */
  async createLock(lock, transactionOptions, callback) {
    const version = await this.unlockContractAbiVersion();
    if (lock && typeof lock.publicLockVersion !== "undefined" && version < 11) {
      throw new Error("Lock creation at version only available for lock v11+");
    }
    return version.createLock.bind(this)(lock, transactionOptions, callback);
  }
  async unlockContractAbiVersion() {
    return super.unlockContractAbiVersion(this.unlockAddress, this.provider);
  }
  async lockContractAbiVersion(address) {
    return super.lockContractAbiVersion(address, this.provider);
  }
  async getUnlockContract() {
    const contract = await super.getUnlockContract(
      this.unlockAddress,
      this.provider
    );
    return contract.connect(this.signer);
  }
  async getLockContract(address) {
    const contract = await super.getLockContract(address, this.provider);
    return contract.connect(this.signer);
  }
  /**
   *  Then we need to call initialize on it. This is critical because otherwise anyone can claim it and then self-destruct it, killing all locks which use the same contract after this.
   * @param {*} params
   * @param {*} callback
   */
  async initializeTemplate(params, transactionOptions, callback) {
    if (!params.templateAddress)
      throw new Error("Missing templateAddress");
    const version = await this.lockContractAbiVersion(params.templateAddress);
    return version.initializeTemplate.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Purchase a key to a lock by account.
   * The key object is passed so we can keep track of it from the application
   * - {PropTypes.address} lockAddress
   * - {PropTypes.address} owner
   * - {string} keyPrice
   * - {string} data
   * - {PropTypes.address} erc20Address
   * - {number} decimals
   * @param {function} callback : callback invoked with the transaction hash
   */
  async purchaseKey(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    return version.purchaseKey.bind(this)(params, transactionOptions, callback);
  }
  /**
   * Purchase several keys to a lock by account.
   * The key object is passed so we can keep track of it from the application
   * - {PropTypes.address} lockAddress
   * - {PropTypes.arrayOf(PropTypes.address)} owners
   * - {PropTypes.arrayOf(string)} keyPrices
   * - {PropTypes.arrayOf(string)} data
   * - {PropTypes.address} erc20Address
   * - {number} decimals
   * @param {function} callback : callback invoked with the transaction hash
   */
  async purchaseKeys(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    return version.purchaseKeys.bind(this)(params, transactionOptions, callback);
  }
  /**
   * Function to renew a membership, callable by anyone.
   * This is only useful for ERC20 locks for which the key owner has approved
   * a large enough token amount!
   * @param params
   * @param callback
   * @returns
   */
  async renewMembershipFor(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    if (!params.tokenId)
      throw new Error("Missing tokenId");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    return version.renewMembershipFor.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Extends an expired key
   * @param {*} params
   * @param {*} callback
   */
  async extendKey(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    const lockContract = await this.getLockContract(params.lockAddress);
    if (!(params.tokenId || params.owner)) {
      throw new Error("Missing tokenId or owner");
    }
    if (!version.extendKey) {
      const owner = params.owner ? params.owner : lockContract.ownerOf(params.tokenId);
      return this.purchaseKey.bind(this)(
        {
          owner,
          ...params
        },
        transactionOptions,
        callback
      );
    }
    if (!params.tokenId && params.owner) {
      const id = await lockContract.tokenOfOwnerByIndex(params.owner, 0);
      params.tokenId = id.toString();
    }
    return version.extendKey.bind(this)(params, transactionOptions, callback);
  }
  /**
   * Purchase key function. This implementation requires the following
   * @param {object} params:
   * - {PropTypes.address} lockAddress
   * - {number} tokenIdFrom
   * - {number} tokenIdTo
   * - {number} amount if null, will take the entire remaining time of the from key
   * @param {function} callback invoked with the transaction hash
   */
  async mergeKeys(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.mergeKeys) {
      throw new Error("Lock version not supported");
    }
    return version.mergeKeys.bind(this)(params, transactionOptions, callback);
  }
  /**
   * Set ERC20 allowance to the beneficary
   * @param {object} params:
   * - {PropTypes.address} lockAddress
   * - {string} spender the address of the spender
   * - {number} amount the amount to approve
   * @param {function} callback invoked with the transaction hash
   */
  async approveBeneficiary(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.approveBeneficiary) {
      throw new Error("Lock version not supported");
    }
    return version.approveBeneficiary.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Grants permission to grant keys to address
   * @param {*} params
   * @param {*} callback
   */
  async addKeyGranter(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    if (!params.keyGranter)
      throw new Error("Missing account");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.addKeyGranter) {
      throw new Error("Lock version not supported");
    }
    return version.addKeyGranter.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Expire and refunds (optional) a key by lock manager
   * @param {*} params
   * @param {*} callback
   */
  async expireAndRefundFor(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    if (!params.keyOwner)
      throw new Error("Missing keyOwner");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.expireAndRefundFor) {
      throw new Error("Lock version not supported");
    }
    return version.expireAndRefundFor.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Cancels a membership and receive a refund (called by key manager)
   * @param {*} params
   * @param {*} callback
   */
  async cancelAndRefund(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.cancelAndRefund) {
      throw new Error("Lock version not supported");
    }
    return version.cancelAndRefund.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Shares a key by transfering time from key to another key
   * @param {*} params
   * - {PropTypes.address} lockAddress
   * - {PropTypes.address } recipient
   * - {string}: tokenId the token to share time from
   * - {string}: duration time to share in seconds
   * @param {*} callback
   */
  async shareKey(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    if (!params.recipient)
      throw new Error("Missing recipient");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.shareKey) {
      throw new Error("Lock version not supported");
    }
    return version.shareKey.bind(this)(params, transactionOptions, callback);
  }
  /**
   * Grants a key to an address
   * @param {function} callback : callback invoked with the transaction hash
   */
  async grantKey(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    return version.grantKey.bind(this)(params, transactionOptions, callback);
  }
  /**
   * Grant keys to multiple recipient addresses with custom expiration
   * @param {function} callback : callback invoked with the transaction hash
   */
  async grantKeys(params, transactionOptions, callback) {
    if (!params.lockAddress) {
      throw new Error("Missing lockAddress");
    }
    const version = await this.lockContractAbiVersion(params.lockAddress);
    return version.grantKeys.bind(this)(params, transactionOptions, callback);
  }
  /**
   * Grant key extension. This implementation requires the following
   * @param {object} params:
   * - {PropTypes.address} lockAddress
   * - {number} tokenId
   * - {number} duration default to 0, which will extend the key by the
   *  default duration of the lock
   * @param {function} callback invoked with the transaction hash
   */
  async grantKeyExtension(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.grantKeyExtension) {
      throw new Error("Lock version not supported");
    }
    return version.grantKeyExtension.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Update the name of a lock
   * @param {object} params:
   * - {PropTypes.address} lockAddress
   * - {string} name the new name of the lock
   * @param {function} callback invoked with the transaction hash
   */
  async updateLockName(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.updateLockName) {
      throw new Error("Lock version not supported");
    }
    return version.updateLockName.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Update the symbol of a lock
   * @param {object} params:
   * - {PropTypes.address} lockAddress
   * - {string} symbol the new symbol of the lock
   * @param {function} callback invoked with the transaction hash
   */
  async updateLockSymbol(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.updateLockSymbol) {
      throw new Error("Lock version not supported");
    }
    return version.updateLockSymbol.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Update the base URI used to parse the tokenURI
   * @param {object} params:
   * - {PropTypes.address} lockAddress
   * - {string} baseTokenURI the new baseTokenURI of the lock
   * @param {function} callback invoked with the transaction hash
   */
  async setBaseTokenURI(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.setBaseTokenURI) {
      throw new Error("Lock version not supported");
    }
    return version.setBaseTokenURI.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Triggers a transaction to withdraw funds from the lock and assign them to the owner.
   * @param {object} params
   * - {PropTypes.address} lockAddress
   * - {string} amount the amount to withdraw (0 to withdraw the entire balance)
   * - {string} Erc20Address the address of the ERC20 currency to withdraw
   * - {number} decimals the number of decimals of the ERC20
   * - {string} beneficary the address that will receive the funds (only v12+)
   * @param {function} callback : callback invoked with the transaction hash
   */
  async withdrawFromLock(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    return version.withdrawFromLock.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Tries multiple approaches for eth_signTypedData
   * @param {*} account
   * @param {*} data
   */
  async unformattedSignTypedData(account, data) {
    const methods = {
      eth_signTypedData: (data2) => data2,
      eth_signTypedData_v3: (data2) => JSON.stringify(data2),
      eth_signTypedData_v4: (data2) => JSON.stringify(data2)
    };
    const toTry = Object.keys(methods);
    return new Promise((resolve, reject) => {
      const tryNext = async (tries) => {
        const method = tries.shift();
        if (!method) {
          return reject(new Error("All signing method failed"));
        }
        try {
          const sendData = methods[method](data);
          const result = await this.provider.send(method, [account, sendData]);
          if (result) {
            return resolve(result);
          }
        } catch (error) {
          console.error(`Method ${method} not supported by provider.`);
          console.error(error);
        }
        return tryNext(tries);
      };
      tryNext(toTry);
    });
  }
  async signMessage(data, method) {
    const dataHash = utils_default.utf8ToHex(data);
    const addr = await this.signer.getAddress();
    let firstParam = dataHash;
    let secondParam = addr.toLowerCase();
    if (method === "eth_sign") {
      ;
      [firstParam, secondParam] = [secondParam, firstParam];
    }
    return this.provider.send(method, [firstParam, secondParam]);
  }
  async setMaxNumberOfKeys(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.setMaxNumberOfKeys) {
      throw new Error("Lock version not supported");
    }
    return version.setMaxNumberOfKeys.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  async setMaxKeysPerAddress(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.setMaxKeysPerAddress) {
      throw new Error("Lock version not supported");
    }
    return version.setMaxKeysPerAddress.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  async setExpirationDuration(params, transactionOptions, callback) {
    if (!params.lockAddress) {
      throw new Error("Missing lockAddress");
    }
    if (params.expirationDuration && typeof params.expirationDuration === "number" && params.expirationDuration < 1) {
      throw new Error("Expiration duration must be greater than 0");
    }
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.setExpirationDuration) {
      throw new Error("Lock version not supported");
    }
    return version.setExpirationDuration.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Add lock manager to Contact
   * @param {*} params
   * @param {*} callback
   */
  async addLockManager(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    if (!params.userAddress)
      throw new Error("Missing userAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.addLockManager) {
      throw new Error("Lock version not supported");
    }
    return version.addLockManager.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Renounce lock manager status for Contract
   * @param {*} params
   * @param {*} callback
   */
  async renounceLockManager(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.renounceLockManager) {
      throw new Error("Lock version not supported");
    }
    return version.renounceLockManager.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Update Refund Penalty: Allow the owner to change the refund penalty.
   * @param {*} params
   * @param {*} callback
   */
  async updateRefundPenalty(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.updateRefundPenalty) {
      throw new Error("Lock version not supported");
    }
    return version.updateRefundPenalty.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Allows a Lock manager to update or remove an event hook
   * @param {*} params
   * @param {*} callback
   */
  async setEventHooks(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.setEventHooks) {
      throw new Error("Lock version not supported");
    }
    return version.setEventHooks.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Allow a Lock manager to change the transfer fee.
   * @param {*} params
   * @param {*} callback
   */
  async updateTransferFee(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.updateTransferFee) {
      throw new Error("Lock version not supported");
    }
    return version.updateTransferFee.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /* Upgrade a lock to a specific version
   * @param {*} params
   * @param {*} callback
   */
  async upgradeLock(params, transactionOptions, callback) {
    const version = await this.unlockContractAbiVersion();
    if (version <= 10) {
      throw new Error("Upgrade lock only available for lock v10+");
    }
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    return version.upgradeLock.bind(this)(
      params.lockAddress,
      params.lockVersion,
      callback
    );
  }
  /**
   * Update referrer fee
   * @param {*} params
   * @param {*} callback
   */
  async setReferrerFee(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.setReferrerFee) {
      throw new Error("Lock version not supported");
    }
    return version.setReferrerFee.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Set signer for `Password hook contract`
   */
  async setPasswordHookSigner(params, signer) {
    const { lockAddress, signerAddress, contractAddress, network } = params ?? {};
    const contract = await this.getHookContract({
      network,
      address: contractAddress,
      abi: passwordHookAbi
    });
    const tx = await contract.connect(this.signer).setSigner(lockAddress, signerAddress);
    return tx;
  }
  /**
   * Change lock manager for a specific key
   * @param {*} params
   * @param {*} callback
   */
  async setKeyManagerOf(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    if (!params.managerAddress)
      throw new Error("Missing managerAddress");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.setKeyManagerOf) {
      throw new Error("Lock version not supported");
    }
    return version.setKeyManagerOf.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Returns the ethers contract object for the UnlockSwapPurchaser contract
   * @param param0
   * @returns
   */
  getUnlockSwapPurchaserContract({
    params: { network }
  }) {
    const networkConfig = this.networks[network];
    const unlockSwapPurchaserAddress = networkConfig?.swapPurchaser;
    if (!unlockSwapPurchaserAddress) {
      throw new Error("SwapPurchaser not available for this network");
    }
    const provider = this.providerForNetwork(network);
    const swapPurchaserContract = new ethers11.Contract(
      unlockSwapPurchaserAddress,
      UnlockSwapPurchaserABI,
      provider
    );
    return swapPurchaserContract.connect(this.signer);
  }
  /**
   * This yields the authorizations required to spend USDC on behalf of the user
   * to buy a key from a specific lock. This is mostly used for the universal
   * card support!
   * @param param0
   * @returns
   */
  async getAndSignAuthorizationsForTransferAndPurchase({
    amount,
    lockAddress,
    network
  }) {
    const networkConfig = this.networks[this.networkId];
    const cardPurchaserAddress = networkConfig?.universalCard?.cardPurchaserAddress;
    if (!cardPurchaserAddress) {
      throw new Error("CardPurchaser not available for this network");
    }
    let usdcContractAddress;
    if (networkConfig?.tokens) {
      usdcContractAddress = networkConfig.tokens.find(
        (token) => token.symbol === "USDC"
      )?.address;
    }
    if (!usdcContractAddress) {
      throw new Error("USDC not available for this network");
    }
    const value = ethers11.utils.parseUnits(amount, 4).toHexString();
    const now = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    const transferMessage = {
      from: await this.signer.getAddress(),
      to: ethers11.utils.getAddress(cardPurchaserAddress),
      value,
      validAfter: 0,
      validBefore: now + 60 * 60 * 24,
      // Valid for 1 day (TODO: how do we handle funds when they are stuck?)
      nonce: ethers11.utils.hexlify(ethers11.utils.randomBytes(32))
      // 32 byte hex string
    };
    const transferSignature = await signTransferAuthorization(
      usdcContractAddress,
      transferMessage,
      this.provider,
      this.signer
    );
    const cardPurchaser = new CardPurchaser();
    const { signature: purchaseSignature, message: purchaseMessage } = await cardPurchaser.getPurchaseAuthorizationSignature(
      network,
      lockAddress,
      this.signer
    );
    return {
      transferSignature,
      transferMessage,
      purchaseSignature,
      purchaseMessage
    };
  }
  /**
   * Performs a purchase using the CardPurchaser contract
   * @param param0
   * @returns
   */
  async purchaseWithCardPurchaser({
    transfer,
    purchase,
    callData
  }) {
    const networkConfig = this.networks[this.networkId];
    const cardPurchaserAddress = networkConfig?.universalCard?.cardPurchaserAddress;
    if (!cardPurchaserAddress) {
      throw new Error("CardPurchaser not available for this network");
    }
    const cardPurchaser = new CardPurchaser();
    return cardPurchaser.purchase(
      this.networkId,
      transfer,
      purchase,
      callData,
      this.signer
    );
  }
  /**
   * Transfers a specific NFT  from one account to another
   * @returns
   */
  async transferFrom(params, transactionOptions, callback) {
    if (!params.lockAddress)
      throw new Error("Missing lockAddress");
    if (!params.keyOwner)
      throw new Error("Missing keyOwner");
    if (!params.to)
      throw new Error("Missing to");
    if (!params.tokenId)
      throw new Error("Missing tokenId");
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.transferFrom) {
      throw new Error("Lock version not supported");
    }
    return version.transferFrom.bind(this)(params, transactionOptions, callback);
  }
  async setGasRefund(params, transactionOptions, callback) {
    const version = await this.lockContractAbiVersion(params.lockAddress);
    if (!version.setGasRefundValue) {
      throw new Error("Lock version not supported");
    }
    return version.setGasRefundValue.bind(this)(
      params,
      transactionOptions,
      callback
    );
  }
  /**
   * Set signer for `Discount code` hook contract
   */
  async setDiscountCodeHookSigner(params) {
    const {
      lockAddress,
      signerAddress,
      contractAddress,
      network,
      discountPercentage = 0
    } = params ?? {};
    const contract = await this.getHookContract({
      network,
      address: contractAddress,
      abi: discountCodeHookAbi
    });
    const discountBasisPoints = discountPercentage * 100;
    const tx = await contract.setDiscountForLock(
      lockAddress,
      signerAddress,
      discountBasisPoints
    );
    return tx;
  }
};

// src/providers.ts
function getCurrentProvider(environment) {
  if (environment.ethereum && environment.ethereum.constructor.name === "Object")
    return "Opera";
  if (environment.web3.currentProvider.isMetaMask)
    return "Metamask";
  if (environment.web3.currentProvider.isTrust)
    return "Trust";
  if (environment.web3.currentProvider.isToshi)
    return "Coinbase Wallet";
  if (environment.web3.currentProvider.isCipher)
    return "Cipher";
  if (environment.web3.currentProvider.constructor.name === "EthereumProvider")
    return "Mist";
  if (environment.web3.currentProvider.constructor.name === "Web3FrameProvider")
    return "Parity";
  if (environment.web3.currentProvider.host && environment.web3.currentProvider.host.indexOf("infura") !== -1)
    return "Infura";
  if (environment.web3.currentProvider.host && environment.web3.currentProvider.host.indexOf("localhost") !== -1)
    return "localhost";
  return "UnknownProvider";
}
function getWeb3Provider(url) {
  return url;
}

// src/locksmithService.ts
import { SiweMessage } from "siwe";

// src/@generated/client/api.ts
import globalAxios2 from "axios";

// src/@generated/client/base.ts
import globalAxios from "axios";
var BASE_PATH = "https://locksmith.unlock-protocol.com".replace(/\/+$/, "");
var BaseAPI = class {
  constructor(configuration, basePath = BASE_PATH, axios = globalAxios) {
    this.basePath = basePath;
    this.axios = axios;
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};

// src/@generated/client/common.ts
var DUMMY_BASE_URL = "https://example.com";
var assertParamExists = function(functionName, paramName, paramValue) {
  if (paramValue === null || paramValue === void 0) {
    throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
  }
};
var setApiKeyToObject = async function(object, keyParamName, configuration) {
  if (configuration && configuration.apiKey) {
    const localVarApiKeyValue = typeof configuration.apiKey === "function" ? await configuration.apiKey(keyParamName) : await configuration.apiKey;
    object[keyParamName] = localVarApiKeyValue;
  }
};
var setBearerAuthToObject = async function(object, configuration) {
  if (configuration && configuration.accessToken) {
    const accessToken = typeof configuration.accessToken === "function" ? await configuration.accessToken() : await configuration.accessToken;
    object["Authorization"] = "Bearer " + accessToken;
  }
};
var setSearchParams = function(url, ...objects) {
  const searchParams = new URLSearchParams(url.search);
  for (const object of objects) {
    for (const key in object) {
      if (Array.isArray(object[key])) {
        searchParams.delete(key);
        for (const item of object[key]) {
          searchParams.append(key, item);
        }
      } else {
        searchParams.set(key, object[key]);
      }
    }
  }
  url.search = searchParams.toString();
};
var serializeDataIfNeeded = function(value, requestOptions, configuration) {
  const nonString = typeof value !== "string";
  const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString;
  return needsSerialization ? JSON.stringify(value !== void 0 ? value : {}) : value || "";
};
var toPathString = function(url) {
  return url.pathname + url.search + url.hash;
};
var createRequestFunction = function(axiosArgs, globalAxios3, BASE_PATH2, configuration) {
  return (axios = globalAxios3, basePath = BASE_PATH2) => {
    const axiosRequestArgs = { ...axiosArgs.options, url: (configuration?.basePath || basePath) + axiosArgs.url };
    return axios.request(axiosRequestArgs);
  };
};

// src/@generated/client/api.ts
var CapturePurchaseRequestPurchaseTypeEnum = {
  Extend: "extend",
  Purchase: "purchase"
};
var GetSubscription200ResponseSubscriptionsInnerTypeEnum = {
  Crypto: "crypto",
  Fiat: "fiat"
};
var DefaultApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * List applications created the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    applications: async (options = {}) => {
      const localVarPath = `/v2/applications/list`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    balance: async (options = {}) => {
      const localVarPath = `/purchase`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Cancel a fiat subscription.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelSubscription: async (network, lockAddress, keyId, options = {}) => {
      assertParamExists("cancelSubscription", "network", network);
      assertParamExists("cancelSubscription", "lockAddress", lockAddress);
      assertParamExists("cancelSubscription", "keyId", keyId);
      const localVarPath = `/v2/subscriptions/{network}/locks/{lockAddress}/keys/{keyId}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Setup an onramp session for the user.
     * @param {string} session The id of the onramp session
     * @param {string} transactionHash The transacttion hash for the deposit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    captureOnRampSession: async (session, transactionHash, options = {}) => {
      assertParamExists("captureOnRampSession", "session", session);
      assertParamExists("captureOnRampSession", "transactionHash", transactionHash);
      const localVarPath = `/v2/purchase/onramp/{session}/capture`.replace(`{${"session"}}`, encodeURIComponent(String(session)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (transactionHash !== void 0) {
        localVarQueryParameter["transactionHash"] = transactionHash;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Capture a purchase
     * @param {CapturePurchaseRequest} [capturePurchaseRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    capturePurchase: async (capturePurchaseRequest, options = {}) => {
      const localVarPath = `/purchase/capture`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(capturePurchaseRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Check if claim is possible for a given purchase
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CheckClaimRequest} [checkClaimRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkClaim: async (network, lockAddress, checkClaimRequest, options = {}) => {
      assertParamExists("checkClaim", "network", network);
      assertParamExists("checkClaim", "lockAddress", lockAddress);
      const localVarPath = `/claim/{network}/locks/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(checkClaimRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Mark a ticket as checked in.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkTicket: async (network, lockAddress, keyId, options = {}) => {
      assertParamExists("checkTicket", "network", network);
      assertParamExists("checkTicket", "lockAddress", lockAddress);
      assertParamExists("checkTicket", "keyId", keyId);
      const localVarPath = `/v2/api/ticket/{network}/lock/{lockAddress}/key/{keyId}/check`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Claim a membership key for a lock. If not authenticated, requires an email in the body.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} captcha Recaptcha value to pass.
     * @param {ClaimRequest} claimRequest 
     * @param {string} [recipient] Recipient address for key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    claim: async (network, lockAddress, captcha, claimRequest, recipient, options = {}) => {
      assertParamExists("claim", "network", network);
      assertParamExists("claim", "lockAddress", lockAddress);
      assertParamExists("claim", "captcha", captcha);
      assertParamExists("claim", "claimRequest", claimRequest);
      const localVarPath = `/v2/claim/{network}/locks/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (captcha !== void 0 && captcha !== null) {
        localVarHeaderParameter["captcha"] = String(captcha);
      }
      if (recipient !== void 0 && recipient !== null) {
        localVarHeaderParameter["recipient"] = String(recipient);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(claimRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Connect a stripe account to a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {ConnectStripeAccountRequest} [connectStripeAccountRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectStripeAccount: async (network, lockAddress, connectStripeAccountRequest, options = {}) => {
      assertParamExists("connectStripeAccount", "network", network);
      assertParamExists("connectStripeAccount", "lockAddress", lockAddress);
      const localVarPath = `/v2/stripe/connect/{network}/locks/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(connectStripeAccountRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create application associated with user wallet.
     * @param {ApplicationBody} applicationBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApplication: async (applicationBody, options = {}) => {
      assertParamExists("createApplication", "applicationBody", applicationBody);
      const localVarPath = `/v2/applications`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(applicationBody, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @param {number} network Network id.
     * @param {string} captcha Recaptcha value to pass.
     * @param {LockContractOptions} lockContractOptions 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLockContract: async (network, captcha, lockContractOptions, options = {}) => {
      assertParamExists("createLockContract", "network", network);
      assertParamExists("createLockContract", "captcha", captcha);
      assertParamExists("createLockContract", "lockContractOptions", lockContractOptions);
      const localVarPath = `/v2/api/contracts/{network}/lock`.replace(`{${"network"}}`, encodeURIComponent(String(network)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarQueryParameter, "api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (captcha !== void 0 && captcha !== null) {
        localVarHeaderParameter["captcha"] = String(captcha);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(lockContractOptions, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Setup an onramp session for the user.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CreateOnRampSessionRequest} createOnRampSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOnRampSession: async (network, lockAddress, createOnRampSessionRequest, options = {}) => {
      assertParamExists("createOnRampSession", "network", network);
      assertParamExists("createOnRampSession", "lockAddress", lockAddress);
      assertParamExists("createOnRampSession", "createOnRampSessionRequest", createOnRampSessionRequest);
      const localVarPath = `/v2/purchase/onramp/{network}/locks/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createOnRampSessionRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a transfer code to transfer an airdropped key to an email address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransferCode: async (network, lockAddress, keyId, options = {}) => {
      assertParamExists("createTransferCode", "network", network);
      assertParamExists("createTransferCode", "lockAddress", lockAddress);
      assertParamExists("createTransferCode", "keyId", keyId);
      const localVarPath = `/v2/transfer/{network}/locks/{lockAddress}/keys/{keyId}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVerifier: async (network, lockAddress, verifierAddress, options = {}) => {
      assertParamExists("createVerifier", "network", network);
      assertParamExists("createVerifier", "lockAddress", lockAddress);
      assertParamExists("createVerifier", "verifierAddress", verifierAddress);
      const localVarPath = `/v2/api/verifier/{network}/{lockAddress}/{verifierAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"verifierAddress"}}`, encodeURIComponent(String(verifierAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete application by id.
     * @param {string} id Application id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApplication: async (id, options = {}) => {
      assertParamExists("deleteApplication", "id", id);
      const localVarPath = `/v2/applications/:id`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete a checkout config
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCheckoutConfig: async (id, options = {}) => {
      assertParamExists("deleteCheckoutConfig", "id", id);
      const localVarPath = `/v2/checkout/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Remove verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVerifier: async (network, lockAddress, verifierAddress, options = {}) => {
      assertParamExists("deleteVerifier", "network", network);
      assertParamExists("deleteVerifier", "lockAddress", lockAddress);
      assertParamExists("deleteVerifier", "verifierAddress", verifierAddress);
      const localVarPath = `/v2/api/verifier/{network}/{lockAddress}/{verifierAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"verifierAddress"}}`, encodeURIComponent(String(verifierAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Disconnect stripe account.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disconnectStripe: async (network, lockAddress, options = {}) => {
      assertParamExists("disconnectStripe", "network", network);
      assertParamExists("disconnectStripe", "lockAddress", lockAddress);
      const localVarPath = `/{network}/lock/{lockAddress}/stripe`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Send QR code by email.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailTicket: async (network, lockAddress, keyId, options = {}) => {
      assertParamExists("emailTicket", "network", network);
      assertParamExists("emailTicket", "lockAddress", lockAddress);
      assertParamExists("emailTicket", "keyId", keyId);
      const localVarPath = `/v2/api/ticket/{network}/{lockAddress}/{keyId}/email`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Generate certificate for specific key
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCertificate: async (network, lockAddress, keyId, options = {}) => {
      assertParamExists("generateCertificate", "network", network);
      assertParamExists("generateCertificate", "lockAddress", lockAddress);
      assertParamExists("generateCertificate", "keyId", keyId);
      const localVarPath = `/v2/certificate/{network}/lock/{lockAddress}/key/{keyId}/generate`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Generate a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateTicket: async (network, lockAddress, keyId, options = {}) => {
      assertParamExists("generateTicket", "network", network);
      assertParamExists("generateTicket", "lockAddress", lockAddress);
      assertParamExists("generateTicket", "keyId", keyId);
      const localVarPath = `/v2/api/ticket/{network}/lock/{lockAddress}/key/{keyId}/generate`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get the price breakdown for recipients & total charges with fees for a specific lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChargesForLock: async (network, lockAddress, purchaseData, recipients, options = {}) => {
      assertParamExists("getChargesForLock", "network", network);
      assertParamExists("getChargesForLock", "lockAddress", lockAddress);
      assertParamExists("getChargesForLock", "purchaseData", purchaseData);
      assertParamExists("getChargesForLock", "recipients", recipients);
      const localVarPath = `/v2/api/charges/{network}/locks/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (purchaseData) {
        localVarQueryParameter["purchaseData[]"] = purchaseData;
      }
      if (recipients) {
        localVarQueryParameter["recipients[]"] = recipients;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCheckoutConfig: async (id, options = {}) => {
      assertParamExists("getCheckoutConfig", "id", id);
      const localVarPath = `/v2/checkout/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get custom email content for a specific template and lock details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomEmailContent: async (network, lockAddress, template, options = {}) => {
      assertParamExists("getCustomEmailContent", "network", network);
      assertParamExists("getCustomEmailContent", "lockAddress", lockAddress);
      assertParamExists("getCustomEmailContent", "template", template);
      const localVarPath = `/v2/email/{network}/locks/{lockAddress}/custom/{template}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"template"}}`, encodeURIComponent(String(template)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get the data for recipients and guild. This is to be used in conjunction with the Guild
     * @param {number} network The network the lock is on
     * @param {string} [lockAddress] The address of the lock
     * @param {Array<string>} [recipients] The list of recipients for the purchase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForRecipientsAndGuild: async (network, lockAddress, recipients, options = {}) => {
      assertParamExists("getDataForRecipientsAndGuild", "network", network);
      const localVarPath = `/v2/hooks/guild`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (network !== void 0) {
        localVarQueryParameter["network"] = network;
      }
      if (lockAddress !== void 0) {
        localVarQueryParameter["lockAddress"] = lockAddress;
      }
      if (recipients) {
        localVarQueryParameter["recipients"] = recipients;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get the event details from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventDetails: async (network, lockAddress, options = {}) => {
      assertParamExists("getEventDetails", "network", network);
      assertParamExists("getEventDetails", "lockAddress", lockAddress);
      const localVarPath = `/v2/events/{network}/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get saved lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockSettings: async (network, lockAddress, options = {}) => {
      assertParamExists("getLockSettings", "network", network);
      assertParamExists("getLockSettings", "lockAddress", lockAddress);
      const localVarPath = `/v2/lock-settings/{network}/locks/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get lock setting by slug
     * @param {string} slug Slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockSettingsBySlug: async (slug, options = {}) => {
      assertParamExists("getLockSettingsBySlug", "slug", slug);
      const localVarPath = `/v2/lock-settings/slug/{slug}`.replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns Stripe connection details
     * @param {string} lockAddress Lock address.
     * @param {number} chain Lock network
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockStripeConnectionDetails: async (lockAddress, chain, options = {}) => {
      assertParamExists("getLockStripeConnectionDetails", "lockAddress", lockAddress);
      assertParamExists("getLockStripeConnectionDetails", "chain", chain);
      const localVarPath = `/lock/{lockAddress}/stripe-connected`.replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (chain !== void 0) {
        localVarQueryParameter["chain"] = chain;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get receipt details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReceipt: async (network, lockAddress, hash, options = {}) => {
      assertParamExists("getReceipt", "network", network);
      assertParamExists("getReceipt", "lockAddress", lockAddress);
      assertParamExists("getReceipt", "hash", hash);
      const localVarPath = `/v2/receipts/{network}/{lockAddress}/{hash}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get all receipts for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReceipts: async (network, lockAddress, options = {}) => {
      assertParamExists("getReceipts", "network", network);
      assertParamExists("getReceipts", "lockAddress", lockAddress);
      const localVarPath = `/v2/receipts/{network}/{lockAddress}/all`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get supplier details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReceiptsBase: async (network, lockAddress, options = {}) => {
      assertParamExists("getReceiptsBase", "network", network);
      assertParamExists("getReceiptsBase", "lockAddress", lockAddress);
      const localVarPath = `/v2/receipts-base/{network}/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists the locks connected to Stripe for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStripeConnections: async (options = {}) => {
      const localVarPath = `/v2/stripe/connections`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get an active subscription associated with the key. It can be fiat or crypto.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscription: async (network, lockAddress, keyId, options = {}) => {
      assertParamExists("getSubscription", "network", network);
      assertParamExists("getSubscription", "lockAddress", lockAddress);
      assertParamExists("getSubscription", "keyId", keyId);
      const localVarPath = `/v2/subscriptions/{network}/locks/{lockAddress}/keys/{keyId}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * get a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicket: async (network, lockAddress, keyId, options = {}) => {
      assertParamExists("getTicket", "network", network);
      assertParamExists("getTicket", "lockAddress", lockAddress);
      assertParamExists("getTicket", "keyId", keyId);
      const localVarPath = `/v2/api/ticket/{network}/lock/{lockAddress}/key/{keyId}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get the total price for a purchase (including fees)
     * @param {number} network The network the lock is on
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTotalPrice: async (network, amount, address, options = {}) => {
      assertParamExists("getTotalPrice", "network", network);
      const localVarPath = `/v2/api/purchase/total`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (network !== void 0) {
        localVarQueryParameter["network"] = network;
      }
      if (amount !== void 0) {
        localVarQueryParameter["amount"] = amount;
      }
      if (address !== void 0) {
        localVarQueryParameter["address"] = address;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get the price breakdown for universal credit card
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniversalCardPrice: async (network, lockAddress, purchaseData, recipients, options = {}) => {
      assertParamExists("getUniversalCardPrice", "network", network);
      assertParamExists("getUniversalCardPrice", "lockAddress", lockAddress);
      assertParamExists("getUniversalCardPrice", "purchaseData", purchaseData);
      assertParamExists("getUniversalCardPrice", "recipients", recipients);
      const localVarPath = `/v2/api/price/{network}/{lockAddress}/card`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (purchaseData) {
        localVarQueryParameter["purchaseData[]"] = purchaseData;
      }
      if (recipients) {
        localVarQueryParameter["recipients[]"] = recipients;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns if credit card payment are enable for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isCardPaymentEnabledForLock: async (network, lockAddress, options = {}) => {
      assertParamExists("isCardPaymentEnabledForLock", "network", network);
      assertParamExists("isCardPaymentEnabledForLock", "lockAddress", lockAddress);
      const localVarPath = `/v2/api/credit-card-details/{network}/locks/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get key and user metadata.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keyMetadata: async (network, lockAddress, keyId, options = {}) => {
      assertParamExists("keyMetadata", "network", network);
      assertParamExists("keyMetadata", "lockAddress", lockAddress);
      assertParamExists("keyMetadata", "keyId", keyId);
      const localVarPath = `/v2/api/metadata/{network}/locks/{lockAddress}/keys/{keyId}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * List of lock keys by network with additional metadata if the caller is the lockManager
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} query Query you want to search for.
     * @param {string} filterKey The key you want to search on.
     * @param {string} [expiration] Expiration time
     * @param {number} [page] Page number when paginating
     * @param {number} [max] Maximum number of items to get by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keys: async (network, lockAddress, query, filterKey, expiration, page, max, options = {}) => {
      assertParamExists("keys", "network", network);
      assertParamExists("keys", "lockAddress", lockAddress);
      assertParamExists("keys", "query", query);
      assertParamExists("keys", "filterKey", filterKey);
      const localVarPath = `/v2/api/{network}/locks/{lockAddress}/keys`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarQueryParameter, "api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (query !== void 0) {
        localVarQueryParameter["query"] = query;
      }
      if (filterKey !== void 0) {
        localVarQueryParameter["filterKey"] = filterKey;
      }
      if (expiration !== void 0) {
        localVarQueryParameter["expiration"] = expiration;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (max !== void 0) {
        localVarQueryParameter["max"] = max;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * A list of all checkout configs created by the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCheckoutConfigs: async (options = {}) => {
      const localVarPath = `/v2/checkout/list`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * List payment methods for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentMethods: async (options = {}) => {
      const localVarPath = `/v2/purchase/list`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lockMetadata: async (network, lockAddress, options = {}) => {
      assertParamExists("lockMetadata", "network", network);
      assertParamExists("lockMetadata", "lockAddress", lockAddress);
      const localVarPath = `/v2/api/metadata/{network}/locks/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Login as a user using Sign in with Ethereum message signed by the wallet address.
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (loginRequest, options = {}) => {
      assertParamExists("login", "loginRequest", loginRequest);
      const localVarPath = `/v2/auth/login`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Logout from locksmith. This will invalidate all your session tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (options = {}) => {
      const localVarPath = `/v2/auth/logout`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Provide a unique nonce for using in sign in with ethereum
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nonce: async (options = {}) => {
      const localVarPath = `/v2/auth/nonce`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @param {number} network Network id.
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    price: async (network, amount, address, options = {}) => {
      assertParamExists("price", "network", network);
      const localVarPath = `/v2/api/{network}/price`.replace(`{${"network"}}`, encodeURIComponent(String(network)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (amount !== void 0) {
        localVarQueryParameter["amount"] = amount;
      }
      if (address !== void 0) {
        localVarQueryParameter["address"] = address;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create purchase intent for stripe.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {PurchaseRequest} purchaseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchase: async (network, lockAddress, purchaseRequest, options = {}) => {
      assertParamExists("purchase", "network", network);
      assertParamExists("purchase", "lockAddress", lockAddress);
      assertParamExists("purchase", "purchaseRequest", purchaseRequest);
      const localVarPath = `/v2/purchase/intent/{network}/locks/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(purchaseRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * resubscribe emails from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reSubscribeEmail: async (network, lockAddress, options = {}) => {
      assertParamExists("reSubscribeEmail", "network", network);
      assertParamExists("reSubscribeEmail", "lockAddress", lockAddress);
      const localVarPath = `/v2/email-subscriptions/subscribe/{network}/locks/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Remove all payment methods for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePaymentMethods: async (options = {}) => {
      const localVarPath = `/v2/purchase/payment-methods`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Invalidate a session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revoke: async (options = {}) => {
      const localVarPath = `/v2/auth/revoke`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Save custom email content for a specif lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveCustomEmailContent: async (network, lockAddress, template, options = {}) => {
      assertParamExists("saveCustomEmailContent", "network", network);
      assertParamExists("saveCustomEmailContent", "lockAddress", lockAddress);
      assertParamExists("saveCustomEmailContent", "template", template);
      const localVarPath = `/v2/email/{network}/locks/{lockAddress}/custom/{template}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"template"}}`, encodeURIComponent(String(template)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Save event data
     * @param {SaveEventDataRequest} [saveEventDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveEventData: async (saveEventDataRequest, options = {}) => {
      const localVarPath = `/v2/events/save`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(saveEventDataRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Save lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {LockSettings} [lockSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveLockSetting: async (network, lockAddress, lockSettings, options = {}) => {
      assertParamExists("saveLockSetting", "network", network);
      assertParamExists("saveLockSetting", "lockAddress", lockAddress);
      const localVarPath = `/v2/lock-settings/{network}/locks/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(lockSettings, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create purchaser details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveReceipt: async (network, lockAddress, hash, options = {}) => {
      assertParamExists("saveReceipt", "network", network);
      assertParamExists("saveReceipt", "lockAddress", lockAddress);
      assertParamExists("saveReceipt", "hash", hash);
      const localVarPath = `/v2/receipts/{network}/{lockAddress}/{hash}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create supplier details.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveReceiptsBase: async (network, lockAddress, options = {}) => {
      assertParamExists("saveReceiptsBase", "network", network);
      assertParamExists("saveReceiptsBase", "lockAddress", lockAddress);
      const localVarPath = `/v2/receipts-base/{network}/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Send custom email to recipients
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {SendCustomEmailRequest} [sendCustomEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendCustomEmail: async (network, lockAddress, sendCustomEmailRequest, options = {}) => {
      assertParamExists("sendCustomEmail", "network", network);
      assertParamExists("sendCustomEmail", "lockAddress", lockAddress);
      const localVarPath = `/v2/email/{network}/locks/{lockAddress}/custom/send`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(sendCustomEmailRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Setup a payment method for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setupPayment: async (options = {}) => {
      const localVarPath = `/v2/purchase/setup`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Generate signature to prove validity of token.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signTicket: async (network, lockAddress, keyId, options = {}) => {
      assertParamExists("signTicket", "network", network);
      assertParamExists("signTicket", "lockAddress", lockAddress);
      assertParamExists("signTicket", "keyId", keyId);
      const localVarPath = `/v2/api/ticket/{network}/{lockAddress}/{keyId}/sign`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get QR code for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketQRCode: async (network, lockAddress, keyId, options = {}) => {
      assertParamExists("ticketQRCode", "network", network);
      assertParamExists("ticketQRCode", "lockAddress", lockAddress);
      assertParamExists("ticketQRCode", "keyId", keyId);
      const localVarPath = `/v2/api/ticket/{network}/{lockAddress}/{keyId}/qr`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get the verification URL for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketVerificationUrl: async (network, lockAddress, keyId, options = {}) => {
      assertParamExists("ticketVerificationUrl", "network", network);
      assertParamExists("ticketVerificationUrl", "lockAddress", lockAddress);
      assertParamExists("ticketVerificationUrl", "keyId", keyId);
      const localVarPath = `/v2/api/ticket/{network}/{lockAddress}/{keyId}/verification`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Finalize the transfer of a key to a recipient. This is to copy over any locksmith related data to the recipient\'s account.
     * @param {TransferDoneRequest} [transferDoneRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferDone: async (transferDoneRequest, options = {}) => {
      const localVarPath = `/v2/transfer/done`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(transferDoneRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Unsubscribe email from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsubscribeEmail: async (network, lockAddress, options = {}) => {
      assertParamExists("unsubscribeEmail", "network", network);
      assertParamExists("unsubscribeEmail", "lockAddress", lockAddress);
      const localVarPath = `/v2/email-subscriptions/unsubscribe/{network}/locks/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update application by id.
     * @param {string} id Application id.
     * @param {ApplicationBody} [applicationBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApplication: async (id, applicationBody, options = {}) => {
      assertParamExists("updateApplication", "id", id);
      const localVarPath = `/v2/applications/:id`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(applicationBody, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * A new checkout config is created or updated if it already exists
     * @param {string} id This is optional. If you don\&#39;t pass an ID, a new config will be created. If you pass an ID, the config will be created.
     * @param {UpdateCheckoutConfigRequest} [updateCheckoutConfigRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCheckoutConfig: async (id, updateCheckoutConfigRequest, options = {}) => {
      assertParamExists("updateCheckoutConfig", "id", id);
      const localVarPath = `/v2/checkout/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateCheckoutConfigRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update or create metadata for key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateKeyMetadata: async (network, lockAddress, keyId, updateLockMetadataRequest, options = {}) => {
      assertParamExists("updateKeyMetadata", "network", network);
      assertParamExists("updateKeyMetadata", "lockAddress", lockAddress);
      assertParamExists("updateKeyMetadata", "keyId", keyId);
      assertParamExists("updateKeyMetadata", "updateLockMetadataRequest", updateLockMetadataRequest);
      const localVarPath = `/v2/api/metadata/{network}/locks/{lockAddress}/keys/{keyId}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateLockMetadataRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update or create metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLockMetadata: async (network, lockAddress, updateLockMetadataRequest, options = {}) => {
      assertParamExists("updateLockMetadata", "network", network);
      assertParamExists("updateLockMetadata", "lockAddress", lockAddress);
      assertParamExists("updateLockMetadata", "updateLockMetadataRequest", updateLockMetadataRequest);
      const localVarPath = `/v2/api/metadata/{network}/locks/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateLockMetadataRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update or create user metadata for lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} userAddress User address.
     * @param {UpdateUserMetadataRequest} updateUserMetadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserMetadata: async (network, lockAddress, userAddress, updateUserMetadataRequest, options = {}) => {
      assertParamExists("updateUserMetadata", "network", network);
      assertParamExists("updateUserMetadata", "lockAddress", lockAddress);
      assertParamExists("updateUserMetadata", "userAddress", userAddress);
      assertParamExists("updateUserMetadata", "updateUserMetadataRequest", updateUserMetadataRequest);
      const localVarPath = `/v2/api/metadata/{network}/locks/{lockAddress}/users/{userAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"userAddress"}}`, encodeURIComponent(String(userAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateUserMetadataRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update or create user metadata for lock.
     * @param {UpdateUsersMetadataRequest} updateUsersMetadataRequest users array containing user metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUsersMetadata: async (updateUsersMetadataRequest, options = {}) => {
      assertParamExists("updateUsersMetadata", "updateUsersMetadataRequest", updateUsersMetadataRequest);
      const localVarPath = `/v2/api/metadata/users`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateUsersMetadataRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Upload images to locksmith
     * @param {Array<any>} [images] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadImages: async (images, options = {}) => {
      const localVarPath = `/v2/images/upload`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (images) {
        images.forEach((element) => {
          localVarFormParams.append("images", element);
        });
      }
      localVarHeaderParameter["Content-Type"] = "multipart/form-data";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams;
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get user details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    user: async (options = {}) => {
      const localVarPath = `/v2/auth/user`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Check if an address is a verifier of the lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifier: async (network, lockAddress, verifierAddress, options = {}) => {
      assertParamExists("verifier", "network", network);
      assertParamExists("verifier", "lockAddress", lockAddress);
      assertParamExists("verifier", "verifierAddress", verifierAddress);
      const localVarPath = `/v2/api/verifier/{network}/lock/{lockAddress}/address/{verifierAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress))).replace(`{${"verifierAddress"}}`, encodeURIComponent(String(verifierAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * List of verifiers for the lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiers: async (network, lockAddress, options = {}) => {
      assertParamExists("verifiers", "network", network);
      assertParamExists("verifiers", "lockAddress", lockAddress);
      const localVarPath = `/v2/api/verifier/list/{network}/{lockAddress}`.replace(`{${"network"}}`, encodeURIComponent(String(network))).replace(`{${"lockAddress"}}`, encodeURIComponent(String(lockAddress)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var DefaultApiFp = function(configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     * List applications created the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async applications(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.applications(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async balance(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.balance(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Cancel a fiat subscription.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelSubscription(network, lockAddress, keyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSubscription(network, lockAddress, keyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Setup an onramp session for the user.
     * @param {string} session The id of the onramp session
     * @param {string} transactionHash The transacttion hash for the deposit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async captureOnRampSession(session, transactionHash, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.captureOnRampSession(session, transactionHash, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Capture a purchase
     * @param {CapturePurchaseRequest} [capturePurchaseRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async capturePurchase(capturePurchaseRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.capturePurchase(capturePurchaseRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Check if claim is possible for a given purchase
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CheckClaimRequest} [checkClaimRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkClaim(network, lockAddress, checkClaimRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkClaim(network, lockAddress, checkClaimRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Mark a ticket as checked in.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkTicket(network, lockAddress, keyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkTicket(network, lockAddress, keyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Claim a membership key for a lock. If not authenticated, requires an email in the body.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} captcha Recaptcha value to pass.
     * @param {ClaimRequest} claimRequest 
     * @param {string} [recipient] Recipient address for key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async claim(network, lockAddress, captcha, claimRequest, recipient, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.claim(network, lockAddress, captcha, claimRequest, recipient, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Connect a stripe account to a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {ConnectStripeAccountRequest} [connectStripeAccountRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async connectStripeAccount(network, lockAddress, connectStripeAccountRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.connectStripeAccount(network, lockAddress, connectStripeAccountRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Create application associated with user wallet.
     * @param {ApplicationBody} applicationBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApplication(applicationBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(applicationBody, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {number} network Network id.
     * @param {string} captcha Recaptcha value to pass.
     * @param {LockContractOptions} lockContractOptions 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLockContract(network, captcha, lockContractOptions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createLockContract(network, captcha, lockContractOptions, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Setup an onramp session for the user.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CreateOnRampSessionRequest} createOnRampSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOnRampSession(network, lockAddress, createOnRampSessionRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createOnRampSession(network, lockAddress, createOnRampSessionRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Create a transfer code to transfer an airdropped key to an email address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTransferCode(network, lockAddress, keyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createTransferCode(network, lockAddress, keyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Create verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createVerifier(network, lockAddress, verifierAddress, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createVerifier(network, lockAddress, verifierAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Delete application by id.
     * @param {string} id Application id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteApplication(id, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Delete a checkout config
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCheckoutConfig(id, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCheckoutConfig(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Remove verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteVerifier(network, lockAddress, verifierAddress, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVerifier(network, lockAddress, verifierAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Disconnect stripe account.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async disconnectStripe(network, lockAddress, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.disconnectStripe(network, lockAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Send QR code by email.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async emailTicket(network, lockAddress, keyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.emailTicket(network, lockAddress, keyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Generate certificate for specific key
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateCertificate(network, lockAddress, keyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateCertificate(network, lockAddress, keyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Generate a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateTicket(network, lockAddress, keyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateTicket(network, lockAddress, keyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get the price breakdown for recipients & total charges with fees for a specific lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChargesForLock(network, lockAddress, purchaseData, recipients, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChargesForLock(network, lockAddress, purchaseData, recipients, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCheckoutConfig(id, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCheckoutConfig(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get custom email content for a specific template and lock details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCustomEmailContent(network, lockAddress, template, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomEmailContent(network, lockAddress, template, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get the data for recipients and guild. This is to be used in conjunction with the Guild
     * @param {number} network The network the lock is on
     * @param {string} [lockAddress] The address of the lock
     * @param {Array<string>} [recipients] The list of recipients for the purchase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataForRecipientsAndGuild(network, lockAddress, recipients, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDataForRecipientsAndGuild(network, lockAddress, recipients, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get the event details from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventDetails(network, lockAddress, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventDetails(network, lockAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get saved lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLockSettings(network, lockAddress, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLockSettings(network, lockAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get lock setting by slug
     * @param {string} slug Slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLockSettingsBySlug(slug, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLockSettingsBySlug(slug, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Returns Stripe connection details
     * @param {string} lockAddress Lock address.
     * @param {number} chain Lock network
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLockStripeConnectionDetails(lockAddress, chain, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLockStripeConnectionDetails(lockAddress, chain, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get receipt details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReceipt(network, lockAddress, hash, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getReceipt(network, lockAddress, hash, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get all receipts for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReceipts(network, lockAddress, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getReceipts(network, lockAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get supplier details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReceiptsBase(network, lockAddress, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getReceiptsBase(network, lockAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Lists the locks connected to Stripe for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStripeConnections(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStripeConnections(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get an active subscription associated with the key. It can be fiat or crypto.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSubscription(network, lockAddress, keyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscription(network, lockAddress, keyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * get a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTicket(network, lockAddress, keyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTicket(network, lockAddress, keyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get the total price for a purchase (including fees)
     * @param {number} network The network the lock is on
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTotalPrice(network, amount, address, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTotalPrice(network, amount, address, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get the price breakdown for universal credit card
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUniversalCardPrice(network, lockAddress, purchaseData, recipients, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUniversalCardPrice(network, lockAddress, purchaseData, recipients, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Returns if credit card payment are enable for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async isCardPaymentEnabledForLock(network, lockAddress, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.isCardPaymentEnabledForLock(network, lockAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get key and user metadata.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async keyMetadata(network, lockAddress, keyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.keyMetadata(network, lockAddress, keyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * List of lock keys by network with additional metadata if the caller is the lockManager
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} query Query you want to search for.
     * @param {string} filterKey The key you want to search on.
     * @param {string} [expiration] Expiration time
     * @param {number} [page] Page number when paginating
     * @param {number} [max] Maximum number of items to get by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async keys(network, lockAddress, query, filterKey, expiration, page, max, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.keys(network, lockAddress, query, filterKey, expiration, page, max, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * A list of all checkout configs created by the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listCheckoutConfigs(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listCheckoutConfigs(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * List payment methods for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPaymentMethods(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentMethods(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lockMetadata(network, lockAddress, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lockMetadata(network, lockAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Login as a user using Sign in with Ethereum message signed by the wallet address.
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(loginRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Logout from locksmith. This will invalidate all your session tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Provide a unique nonce for using in sign in with ethereum
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nonce(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nonce(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * 
     * @param {number} network Network id.
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async price(network, amount, address, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.price(network, amount, address, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Create purchase intent for stripe.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {PurchaseRequest} purchaseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async purchase(network, lockAddress, purchaseRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.purchase(network, lockAddress, purchaseRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * resubscribe emails from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async reSubscribeEmail(network, lockAddress, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.reSubscribeEmail(network, lockAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Remove all payment methods for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePaymentMethods(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePaymentMethods(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Invalidate a session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async revoke(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.revoke(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Save custom email content for a specif lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveCustomEmailContent(network, lockAddress, template, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveCustomEmailContent(network, lockAddress, template, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Save event data
     * @param {SaveEventDataRequest} [saveEventDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveEventData(saveEventDataRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveEventData(saveEventDataRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Save lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {LockSettings} [lockSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveLockSetting(network, lockAddress, lockSettings, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveLockSetting(network, lockAddress, lockSettings, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Create purchaser details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveReceipt(network, lockAddress, hash, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveReceipt(network, lockAddress, hash, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Create supplier details.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveReceiptsBase(network, lockAddress, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveReceiptsBase(network, lockAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Send custom email to recipients
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {SendCustomEmailRequest} [sendCustomEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendCustomEmail(network, lockAddress, sendCustomEmailRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendCustomEmail(network, lockAddress, sendCustomEmailRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Setup a payment method for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setupPayment(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setupPayment(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Generate signature to prove validity of token.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signTicket(network, lockAddress, keyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signTicket(network, lockAddress, keyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get QR code for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketQRCode(network, lockAddress, keyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketQRCode(network, lockAddress, keyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get the verification URL for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticketVerificationUrl(network, lockAddress, keyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticketVerificationUrl(network, lockAddress, keyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Finalize the transfer of a key to a recipient. This is to copy over any locksmith related data to the recipient\'s account.
     * @param {TransferDoneRequest} [transferDoneRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transferDone(transferDoneRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.transferDone(transferDoneRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Unsubscribe email from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unsubscribeEmail(network, lockAddress, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribeEmail(network, lockAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Update application by id.
     * @param {string} id Application id.
     * @param {ApplicationBody} [applicationBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateApplication(id, applicationBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplication(id, applicationBody, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * A new checkout config is created or updated if it already exists
     * @param {string} id This is optional. If you don\&#39;t pass an ID, a new config will be created. If you pass an ID, the config will be created.
     * @param {UpdateCheckoutConfigRequest} [updateCheckoutConfigRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCheckoutConfig(id, updateCheckoutConfigRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateCheckoutConfig(id, updateCheckoutConfigRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Update or create metadata for key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateKeyMetadata(network, lockAddress, keyId, updateLockMetadataRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateKeyMetadata(network, lockAddress, keyId, updateLockMetadataRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Update or create metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateLockMetadata(network, lockAddress, updateLockMetadataRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateLockMetadata(network, lockAddress, updateLockMetadataRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Update or create user metadata for lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} userAddress User address.
     * @param {UpdateUserMetadataRequest} updateUserMetadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserMetadata(network, lockAddress, userAddress, updateUserMetadataRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserMetadata(network, lockAddress, userAddress, updateUserMetadataRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Update or create user metadata for lock.
     * @param {UpdateUsersMetadataRequest} updateUsersMetadataRequest users array containing user metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUsersMetadata(updateUsersMetadataRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsersMetadata(updateUsersMetadataRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Upload images to locksmith
     * @param {Array<any>} [images] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadImages(images, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadImages(images, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Get user details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async user(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.user(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Check if an address is a verifier of the lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifier(network, lockAddress, verifierAddress, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verifier(network, lockAddress, verifierAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * List of verifiers for the lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifiers(network, lockAddress, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verifiers(network, lockAddress, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    }
  };
};
var DefaultApiFactory = function(configuration, basePath, axios) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     * List applications created the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    applications(options) {
      return localVarFp.applications(options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    balance(options) {
      return localVarFp.balance(options).then((request) => request(axios, basePath));
    },
    /**
     * Cancel a fiat subscription.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelSubscription(network, lockAddress, keyId, options) {
      return localVarFp.cancelSubscription(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
    },
    /**
     * Setup an onramp session for the user.
     * @param {string} session The id of the onramp session
     * @param {string} transactionHash The transacttion hash for the deposit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    captureOnRampSession(session, transactionHash, options) {
      return localVarFp.captureOnRampSession(session, transactionHash, options).then((request) => request(axios, basePath));
    },
    /**
     * Capture a purchase
     * @param {CapturePurchaseRequest} [capturePurchaseRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    capturePurchase(capturePurchaseRequest, options) {
      return localVarFp.capturePurchase(capturePurchaseRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Check if claim is possible for a given purchase
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CheckClaimRequest} [checkClaimRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkClaim(network, lockAddress, checkClaimRequest, options) {
      return localVarFp.checkClaim(network, lockAddress, checkClaimRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Mark a ticket as checked in.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkTicket(network, lockAddress, keyId, options) {
      return localVarFp.checkTicket(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
    },
    /**
     * Claim a membership key for a lock. If not authenticated, requires an email in the body.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} captcha Recaptcha value to pass.
     * @param {ClaimRequest} claimRequest 
     * @param {string} [recipient] Recipient address for key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    claim(network, lockAddress, captcha, claimRequest, recipient, options) {
      return localVarFp.claim(network, lockAddress, captcha, claimRequest, recipient, options).then((request) => request(axios, basePath));
    },
    /**
     * Connect a stripe account to a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {ConnectStripeAccountRequest} [connectStripeAccountRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectStripeAccount(network, lockAddress, connectStripeAccountRequest, options) {
      return localVarFp.connectStripeAccount(network, lockAddress, connectStripeAccountRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Create application associated with user wallet.
     * @param {ApplicationBody} applicationBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApplication(applicationBody, options) {
      return localVarFp.createApplication(applicationBody, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {number} network Network id.
     * @param {string} captcha Recaptcha value to pass.
     * @param {LockContractOptions} lockContractOptions 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLockContract(network, captcha, lockContractOptions, options) {
      return localVarFp.createLockContract(network, captcha, lockContractOptions, options).then((request) => request(axios, basePath));
    },
    /**
     * Setup an onramp session for the user.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {CreateOnRampSessionRequest} createOnRampSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOnRampSession(network, lockAddress, createOnRampSessionRequest, options) {
      return localVarFp.createOnRampSession(network, lockAddress, createOnRampSessionRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Create a transfer code to transfer an airdropped key to an email address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTransferCode(network, lockAddress, keyId, options) {
      return localVarFp.createTransferCode(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
    },
    /**
     * Create verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVerifier(network, lockAddress, verifierAddress, options) {
      return localVarFp.createVerifier(network, lockAddress, verifierAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * Delete application by id.
     * @param {string} id Application id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApplication(id, options) {
      return localVarFp.deleteApplication(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Delete a checkout config
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCheckoutConfig(id, options) {
      return localVarFp.deleteCheckoutConfig(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Remove verifier.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVerifier(network, lockAddress, verifierAddress, options) {
      return localVarFp.deleteVerifier(network, lockAddress, verifierAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * Disconnect stripe account.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disconnectStripe(network, lockAddress, options) {
      return localVarFp.disconnectStripe(network, lockAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * Send QR code by email.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    emailTicket(network, lockAddress, keyId, options) {
      return localVarFp.emailTicket(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
    },
    /**
     * Generate certificate for specific key
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCertificate(network, lockAddress, keyId, options) {
      return localVarFp.generateCertificate(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
    },
    /**
     * Generate a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateTicket(network, lockAddress, keyId, options) {
      return localVarFp.generateTicket(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the price breakdown for recipients & total charges with fees for a specific lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChargesForLock(network, lockAddress, purchaseData, recipients, options) {
      return localVarFp.getChargesForLock(network, lockAddress, purchaseData, recipients, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {string} id The id of the checkout config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCheckoutConfig(id, options) {
      return localVarFp.getCheckoutConfig(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Get custom email content for a specific template and lock details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomEmailContent(network, lockAddress, template, options) {
      return localVarFp.getCustomEmailContent(network, lockAddress, template, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the data for recipients and guild. This is to be used in conjunction with the Guild
     * @param {number} network The network the lock is on
     * @param {string} [lockAddress] The address of the lock
     * @param {Array<string>} [recipients] The list of recipients for the purchase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForRecipientsAndGuild(network, lockAddress, recipients, options) {
      return localVarFp.getDataForRecipientsAndGuild(network, lockAddress, recipients, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the event details from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventDetails(network, lockAddress, options) {
      return localVarFp.getEventDetails(network, lockAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * Get saved lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockSettings(network, lockAddress, options) {
      return localVarFp.getLockSettings(network, lockAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * Get lock setting by slug
     * @param {string} slug Slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockSettingsBySlug(slug, options) {
      return localVarFp.getLockSettingsBySlug(slug, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns Stripe connection details
     * @param {string} lockAddress Lock address.
     * @param {number} chain Lock network
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLockStripeConnectionDetails(lockAddress, chain, options) {
      return localVarFp.getLockStripeConnectionDetails(lockAddress, chain, options).then((request) => request(axios, basePath));
    },
    /**
     * Get receipt details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReceipt(network, lockAddress, hash, options) {
      return localVarFp.getReceipt(network, lockAddress, hash, options).then((request) => request(axios, basePath));
    },
    /**
     * Get all receipts for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReceipts(network, lockAddress, options) {
      return localVarFp.getReceipts(network, lockAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * Get supplier details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReceiptsBase(network, lockAddress, options) {
      return localVarFp.getReceiptsBase(network, lockAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists the locks connected to Stripe for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStripeConnections(options) {
      return localVarFp.getStripeConnections(options).then((request) => request(axios, basePath));
    },
    /**
     * Get an active subscription associated with the key. It can be fiat or crypto.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscription(network, lockAddress, keyId, options) {
      return localVarFp.getSubscription(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
    },
    /**
     * get a ticket for a key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicket(network, lockAddress, keyId, options) {
      return localVarFp.getTicket(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the total price for a purchase (including fees)
     * @param {number} network The network the lock is on
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTotalPrice(network, amount, address, options) {
      return localVarFp.getTotalPrice(network, amount, address, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the price breakdown for universal credit card
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {Array<string>} purchaseData The purchase data passed to the purchase function
     * @param {Array<string>} recipients The recipients passed to the purchase function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUniversalCardPrice(network, lockAddress, purchaseData, recipients, options) {
      return localVarFp.getUniversalCardPrice(network, lockAddress, purchaseData, recipients, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns if credit card payment are enable for a lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isCardPaymentEnabledForLock(network, lockAddress, options) {
      return localVarFp.isCardPaymentEnabledForLock(network, lockAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * Get key and user metadata.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keyMetadata(network, lockAddress, keyId, options) {
      return localVarFp.keyMetadata(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
    },
    /**
     * List of lock keys by network with additional metadata if the caller is the lockManager
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} query Query you want to search for.
     * @param {string} filterKey The key you want to search on.
     * @param {string} [expiration] Expiration time
     * @param {number} [page] Page number when paginating
     * @param {number} [max] Maximum number of items to get by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    keys(network, lockAddress, query, filterKey, expiration, page, max, options) {
      return localVarFp.keys(network, lockAddress, query, filterKey, expiration, page, max, options).then((request) => request(axios, basePath));
    },
    /**
     * A list of all checkout configs created by the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCheckoutConfigs(options) {
      return localVarFp.listCheckoutConfigs(options).then((request) => request(axios, basePath));
    },
    /**
     * List payment methods for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPaymentMethods(options) {
      return localVarFp.listPaymentMethods(options).then((request) => request(axios, basePath));
    },
    /**
     * Get metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lockMetadata(network, lockAddress, options) {
      return localVarFp.lockMetadata(network, lockAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * Login as a user using Sign in with Ethereum message signed by the wallet address.
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(loginRequest, options) {
      return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Logout from locksmith. This will invalidate all your session tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options) {
      return localVarFp.logout(options).then((request) => request(axios, basePath));
    },
    /**
     * Provide a unique nonce for using in sign in with ethereum
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nonce(options) {
      return localVarFp.nonce(options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @param {number} network Network id.
     * @param {number} [amount] Amount of tokens you want to get the price for in USD.
     * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    price(network, amount, address, options) {
      return localVarFp.price(network, amount, address, options).then((request) => request(axios, basePath));
    },
    /**
     * Create purchase intent for stripe.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {PurchaseRequest} purchaseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchase(network, lockAddress, purchaseRequest, options) {
      return localVarFp.purchase(network, lockAddress, purchaseRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * resubscribe emails from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reSubscribeEmail(network, lockAddress, options) {
      return localVarFp.reSubscribeEmail(network, lockAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * Remove all payment methods for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePaymentMethods(options) {
      return localVarFp.removePaymentMethods(options).then((request) => request(axios, basePath));
    },
    /**
     * Invalidate a session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revoke(options) {
      return localVarFp.revoke(options).then((request) => request(axios, basePath));
    },
    /**
     * Save custom email content for a specif lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} template Template id for email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveCustomEmailContent(network, lockAddress, template, options) {
      return localVarFp.saveCustomEmailContent(network, lockAddress, template, options).then((request) => request(axios, basePath));
    },
    /**
     * Save event data
     * @param {SaveEventDataRequest} [saveEventDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveEventData(saveEventDataRequest, options) {
      return localVarFp.saveEventData(saveEventDataRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Save lock settings
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {LockSettings} [lockSettings] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveLockSetting(network, lockAddress, lockSettings, options) {
      return localVarFp.saveLockSetting(network, lockAddress, lockSettings, options).then((request) => request(axios, basePath));
    },
    /**
     * Create purchaser details
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} hash Hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveReceipt(network, lockAddress, hash, options) {
      return localVarFp.saveReceipt(network, lockAddress, hash, options).then((request) => request(axios, basePath));
    },
    /**
     * Create supplier details.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveReceiptsBase(network, lockAddress, options) {
      return localVarFp.saveReceiptsBase(network, lockAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * Send custom email to recipients
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {SendCustomEmailRequest} [sendCustomEmailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendCustomEmail(network, lockAddress, sendCustomEmailRequest, options) {
      return localVarFp.sendCustomEmail(network, lockAddress, sendCustomEmailRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Setup a payment method for user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setupPayment(options) {
      return localVarFp.setupPayment(options).then((request) => request(axios, basePath));
    },
    /**
     * Generate signature to prove validity of token.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signTicket(network, lockAddress, keyId, options) {
      return localVarFp.signTicket(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get QR code for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketQRCode(network, lockAddress, keyId, options) {
      return localVarFp.ticketQRCode(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get the verification URL for the key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticketVerificationUrl(network, lockAddress, keyId, options) {
      return localVarFp.ticketVerificationUrl(network, lockAddress, keyId, options).then((request) => request(axios, basePath));
    },
    /**
     * Finalize the transfer of a key to a recipient. This is to copy over any locksmith related data to the recipient\'s account.
     * @param {TransferDoneRequest} [transferDoneRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferDone(transferDoneRequest, options) {
      return localVarFp.transferDone(transferDoneRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Unsubscribe email from lock
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unsubscribeEmail(network, lockAddress, options) {
      return localVarFp.unsubscribeEmail(network, lockAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * Update application by id.
     * @param {string} id Application id.
     * @param {ApplicationBody} [applicationBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApplication(id, applicationBody, options) {
      return localVarFp.updateApplication(id, applicationBody, options).then((request) => request(axios, basePath));
    },
    /**
     * A new checkout config is created or updated if it already exists
     * @param {string} id This is optional. If you don\&#39;t pass an ID, a new config will be created. If you pass an ID, the config will be created.
     * @param {UpdateCheckoutConfigRequest} [updateCheckoutConfigRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCheckoutConfig(id, updateCheckoutConfigRequest, options) {
      return localVarFp.updateCheckoutConfig(id, updateCheckoutConfigRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Update or create metadata for key.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} keyId Key Id.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateKeyMetadata(network, lockAddress, keyId, updateLockMetadataRequest, options) {
      return localVarFp.updateKeyMetadata(network, lockAddress, keyId, updateLockMetadataRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Update or create metadata for lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLockMetadata(network, lockAddress, updateLockMetadataRequest, options) {
      return localVarFp.updateLockMetadata(network, lockAddress, updateLockMetadataRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Update or create user metadata for lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} userAddress User address.
     * @param {UpdateUserMetadataRequest} updateUserMetadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserMetadata(network, lockAddress, userAddress, updateUserMetadataRequest, options) {
      return localVarFp.updateUserMetadata(network, lockAddress, userAddress, updateUserMetadataRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Update or create user metadata for lock.
     * @param {UpdateUsersMetadataRequest} updateUsersMetadataRequest users array containing user metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUsersMetadata(updateUsersMetadataRequest, options) {
      return localVarFp.updateUsersMetadata(updateUsersMetadataRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Upload images to locksmith
     * @param {Array<any>} [images] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadImages(images, options) {
      return localVarFp.uploadImages(images, options).then((request) => request(axios, basePath));
    },
    /**
     * Get user details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    user(options) {
      return localVarFp.user(options).then((request) => request(axios, basePath));
    },
    /**
     * Check if an address is a verifier of the lock.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {string} verifierAddress User address to use as verifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifier(network, lockAddress, verifierAddress, options) {
      return localVarFp.verifier(network, lockAddress, verifierAddress, options).then((request) => request(axios, basePath));
    },
    /**
     * List of verifiers for the lock address.
     * @param {number} network Network id.
     * @param {string} lockAddress Lock address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifiers(network, lockAddress, options) {
      return localVarFp.verifiers(network, lockAddress, options).then((request) => request(axios, basePath));
    }
  };
};
var DefaultApi = class extends BaseAPI {
  /**
   * List applications created the user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  applications(options) {
    return DefaultApiFp(this.configuration).applications(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  balance(options) {
    return DefaultApiFp(this.configuration).balance(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Cancel a fiat subscription.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} keyId Key Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  cancelSubscription(network, lockAddress, keyId, options) {
    return DefaultApiFp(this.configuration).cancelSubscription(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Setup an onramp session for the user.
   * @param {string} session The id of the onramp session
   * @param {string} transactionHash The transacttion hash for the deposit
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  captureOnRampSession(session, transactionHash, options) {
    return DefaultApiFp(this.configuration).captureOnRampSession(session, transactionHash, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Capture a purchase
   * @param {CapturePurchaseRequest} [capturePurchaseRequest] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  capturePurchase(capturePurchaseRequest, options) {
    return DefaultApiFp(this.configuration).capturePurchase(capturePurchaseRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Check if claim is possible for a given purchase
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {CheckClaimRequest} [checkClaimRequest] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  checkClaim(network, lockAddress, checkClaimRequest, options) {
    return DefaultApiFp(this.configuration).checkClaim(network, lockAddress, checkClaimRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Mark a ticket as checked in.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} keyId Key Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  checkTicket(network, lockAddress, keyId, options) {
    return DefaultApiFp(this.configuration).checkTicket(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Claim a membership key for a lock. If not authenticated, requires an email in the body.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} captcha Recaptcha value to pass.
   * @param {ClaimRequest} claimRequest 
   * @param {string} [recipient] Recipient address for key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  claim(network, lockAddress, captcha, claimRequest, recipient, options) {
    return DefaultApiFp(this.configuration).claim(network, lockAddress, captcha, claimRequest, recipient, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Connect a stripe account to a lock
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {ConnectStripeAccountRequest} [connectStripeAccountRequest] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  connectStripeAccount(network, lockAddress, connectStripeAccountRequest, options) {
    return DefaultApiFp(this.configuration).connectStripeAccount(network, lockAddress, connectStripeAccountRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Create application associated with user wallet.
   * @param {ApplicationBody} applicationBody 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  createApplication(applicationBody, options) {
    return DefaultApiFp(this.configuration).createApplication(applicationBody, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @param {number} network Network id.
   * @param {string} captcha Recaptcha value to pass.
   * @param {LockContractOptions} lockContractOptions 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  createLockContract(network, captcha, lockContractOptions, options) {
    return DefaultApiFp(this.configuration).createLockContract(network, captcha, lockContractOptions, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Setup an onramp session for the user.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {CreateOnRampSessionRequest} createOnRampSessionRequest 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  createOnRampSession(network, lockAddress, createOnRampSessionRequest, options) {
    return DefaultApiFp(this.configuration).createOnRampSession(network, lockAddress, createOnRampSessionRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Create a transfer code to transfer an airdropped key to an email address.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} keyId Key Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  createTransferCode(network, lockAddress, keyId, options) {
    return DefaultApiFp(this.configuration).createTransferCode(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Create verifier.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} verifierAddress User address to use as verifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  createVerifier(network, lockAddress, verifierAddress, options) {
    return DefaultApiFp(this.configuration).createVerifier(network, lockAddress, verifierAddress, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Delete application by id.
   * @param {string} id Application id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  deleteApplication(id, options) {
    return DefaultApiFp(this.configuration).deleteApplication(id, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Delete a checkout config
   * @param {string} id The id of the checkout config
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  deleteCheckoutConfig(id, options) {
    return DefaultApiFp(this.configuration).deleteCheckoutConfig(id, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Remove verifier.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} verifierAddress User address to use as verifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  deleteVerifier(network, lockAddress, verifierAddress, options) {
    return DefaultApiFp(this.configuration).deleteVerifier(network, lockAddress, verifierAddress, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Disconnect stripe account.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  disconnectStripe(network, lockAddress, options) {
    return DefaultApiFp(this.configuration).disconnectStripe(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Send QR code by email.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} keyId Key Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  emailTicket(network, lockAddress, keyId, options) {
    return DefaultApiFp(this.configuration).emailTicket(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Generate certificate for specific key
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} keyId Key Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  generateCertificate(network, lockAddress, keyId, options) {
    return DefaultApiFp(this.configuration).generateCertificate(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Generate a ticket for a key.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} keyId Key Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  generateTicket(network, lockAddress, keyId, options) {
    return DefaultApiFp(this.configuration).generateTicket(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get the price breakdown for recipients & total charges with fees for a specific lock
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {Array<string>} purchaseData The purchase data passed to the purchase function
   * @param {Array<string>} recipients The recipients passed to the purchase function
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getChargesForLock(network, lockAddress, purchaseData, recipients, options) {
    return DefaultApiFp(this.configuration).getChargesForLock(network, lockAddress, purchaseData, recipients, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @param {string} id The id of the checkout config
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getCheckoutConfig(id, options) {
    return DefaultApiFp(this.configuration).getCheckoutConfig(id, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get custom email content for a specific template and lock details
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} template Template id for email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getCustomEmailContent(network, lockAddress, template, options) {
    return DefaultApiFp(this.configuration).getCustomEmailContent(network, lockAddress, template, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get the data for recipients and guild. This is to be used in conjunction with the Guild
   * @param {number} network The network the lock is on
   * @param {string} [lockAddress] The address of the lock
   * @param {Array<string>} [recipients] The list of recipients for the purchase
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getDataForRecipientsAndGuild(network, lockAddress, recipients, options) {
    return DefaultApiFp(this.configuration).getDataForRecipientsAndGuild(network, lockAddress, recipients, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get the event details from lock
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getEventDetails(network, lockAddress, options) {
    return DefaultApiFp(this.configuration).getEventDetails(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get saved lock settings
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getLockSettings(network, lockAddress, options) {
    return DefaultApiFp(this.configuration).getLockSettings(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get lock setting by slug
   * @param {string} slug Slug
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getLockSettingsBySlug(slug, options) {
    return DefaultApiFp(this.configuration).getLockSettingsBySlug(slug, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Returns Stripe connection details
   * @param {string} lockAddress Lock address.
   * @param {number} chain Lock network
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getLockStripeConnectionDetails(lockAddress, chain, options) {
    return DefaultApiFp(this.configuration).getLockStripeConnectionDetails(lockAddress, chain, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get receipt details
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} hash Hash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getReceipt(network, lockAddress, hash, options) {
    return DefaultApiFp(this.configuration).getReceipt(network, lockAddress, hash, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get all receipts for a lock
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getReceipts(network, lockAddress, options) {
    return DefaultApiFp(this.configuration).getReceipts(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get supplier details
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getReceiptsBase(network, lockAddress, options) {
    return DefaultApiFp(this.configuration).getReceiptsBase(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists the locks connected to Stripe for a user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getStripeConnections(options) {
    return DefaultApiFp(this.configuration).getStripeConnections(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get an active subscription associated with the key. It can be fiat or crypto.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} keyId Key Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getSubscription(network, lockAddress, keyId, options) {
    return DefaultApiFp(this.configuration).getSubscription(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * get a ticket for a key.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} keyId Key Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getTicket(network, lockAddress, keyId, options) {
    return DefaultApiFp(this.configuration).getTicket(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get the total price for a purchase (including fees)
   * @param {number} network The network the lock is on
   * @param {number} [amount] Amount of tokens you want to get the price for in USD.
   * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getTotalPrice(network, amount, address, options) {
    return DefaultApiFp(this.configuration).getTotalPrice(network, amount, address, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get the price breakdown for universal credit card
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {Array<string>} purchaseData The purchase data passed to the purchase function
   * @param {Array<string>} recipients The recipients passed to the purchase function
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getUniversalCardPrice(network, lockAddress, purchaseData, recipients, options) {
    return DefaultApiFp(this.configuration).getUniversalCardPrice(network, lockAddress, purchaseData, recipients, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Returns if credit card payment are enable for a lock
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  isCardPaymentEnabledForLock(network, lockAddress, options) {
    return DefaultApiFp(this.configuration).isCardPaymentEnabledForLock(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get key and user metadata.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} keyId Key Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  keyMetadata(network, lockAddress, keyId, options) {
    return DefaultApiFp(this.configuration).keyMetadata(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * List of lock keys by network with additional metadata if the caller is the lockManager
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} query Query you want to search for.
   * @param {string} filterKey The key you want to search on.
   * @param {string} [expiration] Expiration time
   * @param {number} [page] Page number when paginating
   * @param {number} [max] Maximum number of items to get by page
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  keys(network, lockAddress, query, filterKey, expiration, page, max, options) {
    return DefaultApiFp(this.configuration).keys(network, lockAddress, query, filterKey, expiration, page, max, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * A list of all checkout configs created by the user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  listCheckoutConfigs(options) {
    return DefaultApiFp(this.configuration).listCheckoutConfigs(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * List payment methods for user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  listPaymentMethods(options) {
    return DefaultApiFp(this.configuration).listPaymentMethods(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get metadata for lock address.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  lockMetadata(network, lockAddress, options) {
    return DefaultApiFp(this.configuration).lockMetadata(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Login as a user using Sign in with Ethereum message signed by the wallet address.
   * @param {LoginRequest} loginRequest 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  login(loginRequest, options) {
    return DefaultApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Logout from locksmith. This will invalidate all your session tokens.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  logout(options) {
    return DefaultApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Provide a unique nonce for using in sign in with ethereum
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  nonce(options) {
    return DefaultApiFp(this.configuration).nonce(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @param {number} network Network id.
   * @param {number} [amount] Amount of tokens you want to get the price for in USD.
   * @param {string} [address] The erc20 address you want to get the price for. If nothing is passed, the API will return the native token price.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  price(network, amount, address, options) {
    return DefaultApiFp(this.configuration).price(network, amount, address, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Create purchase intent for stripe.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {PurchaseRequest} purchaseRequest 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  purchase(network, lockAddress, purchaseRequest, options) {
    return DefaultApiFp(this.configuration).purchase(network, lockAddress, purchaseRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * resubscribe emails from lock
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  reSubscribeEmail(network, lockAddress, options) {
    return DefaultApiFp(this.configuration).reSubscribeEmail(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Remove all payment methods for a user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  removePaymentMethods(options) {
    return DefaultApiFp(this.configuration).removePaymentMethods(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Invalidate a session.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  revoke(options) {
    return DefaultApiFp(this.configuration).revoke(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Save custom email content for a specif lock.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} template Template id for email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  saveCustomEmailContent(network, lockAddress, template, options) {
    return DefaultApiFp(this.configuration).saveCustomEmailContent(network, lockAddress, template, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Save event data
   * @param {SaveEventDataRequest} [saveEventDataRequest] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  saveEventData(saveEventDataRequest, options) {
    return DefaultApiFp(this.configuration).saveEventData(saveEventDataRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Save lock settings
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {LockSettings} [lockSettings] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  saveLockSetting(network, lockAddress, lockSettings, options) {
    return DefaultApiFp(this.configuration).saveLockSetting(network, lockAddress, lockSettings, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Create purchaser details
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} hash Hash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  saveReceipt(network, lockAddress, hash, options) {
    return DefaultApiFp(this.configuration).saveReceipt(network, lockAddress, hash, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Create supplier details.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  saveReceiptsBase(network, lockAddress, options) {
    return DefaultApiFp(this.configuration).saveReceiptsBase(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Send custom email to recipients
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {SendCustomEmailRequest} [sendCustomEmailRequest] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  sendCustomEmail(network, lockAddress, sendCustomEmailRequest, options) {
    return DefaultApiFp(this.configuration).sendCustomEmail(network, lockAddress, sendCustomEmailRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Setup a payment method for user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  setupPayment(options) {
    return DefaultApiFp(this.configuration).setupPayment(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Generate signature to prove validity of token.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} keyId Key Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  signTicket(network, lockAddress, keyId, options) {
    return DefaultApiFp(this.configuration).signTicket(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get QR code for the key.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} keyId Key Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  ticketQRCode(network, lockAddress, keyId, options) {
    return DefaultApiFp(this.configuration).ticketQRCode(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get the verification URL for the key.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} keyId Key Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  ticketVerificationUrl(network, lockAddress, keyId, options) {
    return DefaultApiFp(this.configuration).ticketVerificationUrl(network, lockAddress, keyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Finalize the transfer of a key to a recipient. This is to copy over any locksmith related data to the recipient\'s account.
   * @param {TransferDoneRequest} [transferDoneRequest] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  transferDone(transferDoneRequest, options) {
    return DefaultApiFp(this.configuration).transferDone(transferDoneRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Unsubscribe email from lock
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  unsubscribeEmail(network, lockAddress, options) {
    return DefaultApiFp(this.configuration).unsubscribeEmail(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Update application by id.
   * @param {string} id Application id.
   * @param {ApplicationBody} [applicationBody] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  updateApplication(id, applicationBody, options) {
    return DefaultApiFp(this.configuration).updateApplication(id, applicationBody, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * A new checkout config is created or updated if it already exists
   * @param {string} id This is optional. If you don\&#39;t pass an ID, a new config will be created. If you pass an ID, the config will be created.
   * @param {UpdateCheckoutConfigRequest} [updateCheckoutConfigRequest] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  updateCheckoutConfig(id, updateCheckoutConfigRequest, options) {
    return DefaultApiFp(this.configuration).updateCheckoutConfig(id, updateCheckoutConfigRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Update or create metadata for key.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} keyId Key Id.
   * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  updateKeyMetadata(network, lockAddress, keyId, updateLockMetadataRequest, options) {
    return DefaultApiFp(this.configuration).updateKeyMetadata(network, lockAddress, keyId, updateLockMetadataRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Update or create metadata for lock address.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {UpdateLockMetadataRequest} updateLockMetadataRequest 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  updateLockMetadata(network, lockAddress, updateLockMetadataRequest, options) {
    return DefaultApiFp(this.configuration).updateLockMetadata(network, lockAddress, updateLockMetadataRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Update or create user metadata for lock.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} userAddress User address.
   * @param {UpdateUserMetadataRequest} updateUserMetadataRequest 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  updateUserMetadata(network, lockAddress, userAddress, updateUserMetadataRequest, options) {
    return DefaultApiFp(this.configuration).updateUserMetadata(network, lockAddress, userAddress, updateUserMetadataRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Update or create user metadata for lock.
   * @param {UpdateUsersMetadataRequest} updateUsersMetadataRequest users array containing user metadata.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  updateUsersMetadata(updateUsersMetadataRequest, options) {
    return DefaultApiFp(this.configuration).updateUsersMetadata(updateUsersMetadataRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Upload images to locksmith
   * @param {Array<any>} [images] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  uploadImages(images, options) {
    return DefaultApiFp(this.configuration).uploadImages(images, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get user details.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  user(options) {
    return DefaultApiFp(this.configuration).user(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Check if an address is a verifier of the lock.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {string} verifierAddress User address to use as verifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  verifier(network, lockAddress, verifierAddress, options) {
    return DefaultApiFp(this.configuration).verifier(network, lockAddress, verifierAddress, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * List of verifiers for the lock address.
   * @param {number} network Network id.
   * @param {string} lockAddress Lock address.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  verifiers(network, lockAddress, options) {
    return DefaultApiFp(this.configuration).verifiers(network, lockAddress, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/@generated/client/configuration.ts
var Configuration = class {
  constructor(param = {}) {
    this.apiKey = param.apiKey;
    this.username = param.username;
    this.password = param.password;
    this.accessToken = param.accessToken;
    this.basePath = param.basePath;
    this.baseOptions = param.baseOptions;
    this.formDataCtor = param.formDataCtor;
  }
  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  isJsonMime(mime) {
    const jsonMime = new RegExp("^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$", "i");
    return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === "application/json-patch+json");
  }
};

// src/locksmithService.ts
var LocksmithService = class extends DefaultApi {
  /**
   * Helper static createSiweMessage method wrapping SIWE or sign in with ethereum standard message
   */
  static createSiweMessage(options) {
    return new SiweMessage(options);
  }
};

// ../../node_modules/tslib/tslib.es6.js
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};

// ../../node_modules/graphql-tag/lib/index.js
import { parse } from "graphql";
var docCache = /* @__PURE__ */ new Map();
var fragmentSourceMap = /* @__PURE__ */ new Map();
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
function normalize(string) {
  return string.replace(/[\s,]+/g, " ").trim();
}
function cacheKeyFromLoc(loc) {
  return normalize(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast) {
  var seenKeys = /* @__PURE__ */ new Set();
  var definitions = [];
  ast.definitions.forEach(function(fragmentDefinition) {
    if (fragmentDefinition.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  });
  return __assign(__assign({}, ast), { definitions });
}
function stripLoc(doc) {
  var workSet = new Set(doc.definitions);
  workSet.forEach(function(node) {
    if (node.loc)
      delete node.loc;
    Object.keys(node).forEach(function(key) {
      var value = node[key];
      if (value && typeof value === "object") {
        workSet.add(value);
      }
    });
  });
  var loc = doc.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc;
}
function parseDocument(source) {
  var cacheKey = normalize(source);
  if (!docCache.has(cacheKey)) {
    var parsed = parse(source, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
}
function gql(literals) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result = literals[0];
  args.forEach(function(arg, i) {
    if (arg && arg.kind === "Document") {
      result += arg.loc.source.body;
    } else {
      result += arg;
    }
    result += literals[i + 1];
  });
  return parseDocument(result);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var extras = {
  gql,
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables
};
(function(gql_1) {
  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql || (gql = {}));
gql["default"] = gql;
var lib_default = gql;

// src/@generated/subgraph/index.ts
var Key_OrderBy = /* @__PURE__ */ ((Key_OrderBy3) => {
  Key_OrderBy3["Cancelled"] = "cancelled";
  Key_OrderBy3["CreatedAt"] = "createdAt";
  Key_OrderBy3["CreatedAtBlock"] = "createdAtBlock";
  Key_OrderBy3["Expiration"] = "expiration";
  Key_OrderBy3["Id"] = "id";
  Key_OrderBy3["Lock"] = "lock";
  Key_OrderBy3["LockAddress"] = "lock__address";
  Key_OrderBy3["LockCreatedAtBlock"] = "lock__createdAtBlock";
  Key_OrderBy3["LockDeployer"] = "lock__deployer";
  Key_OrderBy3["LockExpirationDuration"] = "lock__expirationDuration";
  Key_OrderBy3["LockId"] = "lock__id";
  Key_OrderBy3["LockLastKeyMintedAt"] = "lock__lastKeyMintedAt";
  Key_OrderBy3["LockMaxKeysPerAddress"] = "lock__maxKeysPerAddress";
  Key_OrderBy3["LockMaxNumberOfKeys"] = "lock__maxNumberOfKeys";
  Key_OrderBy3["LockName"] = "lock__name";
  Key_OrderBy3["LockNumberOfReceipts"] = "lock__numberOfReceipts";
  Key_OrderBy3["LockPrice"] = "lock__price";
  Key_OrderBy3["LockSymbol"] = "lock__symbol";
  Key_OrderBy3["LockTokenAddress"] = "lock__tokenAddress";
  Key_OrderBy3["LockTotalKeys"] = "lock__totalKeys";
  Key_OrderBy3["LockVersion"] = "lock__version";
  Key_OrderBy3["Manager"] = "manager";
  Key_OrderBy3["Owner"] = "owner";
  Key_OrderBy3["TokenId"] = "tokenId";
  Key_OrderBy3["TokenUri"] = "tokenURI";
  Key_OrderBy3["TransactionsHash"] = "transactionsHash";
  return Key_OrderBy3;
})(Key_OrderBy || {});
var Lock_OrderBy = /* @__PURE__ */ ((Lock_OrderBy2) => {
  Lock_OrderBy2["Address"] = "address";
  Lock_OrderBy2["CreatedAtBlock"] = "createdAtBlock";
  Lock_OrderBy2["Deployer"] = "deployer";
  Lock_OrderBy2["ExpirationDuration"] = "expirationDuration";
  Lock_OrderBy2["Id"] = "id";
  Lock_OrderBy2["Keys"] = "keys";
  Lock_OrderBy2["LastKeyMintedAt"] = "lastKeyMintedAt";
  Lock_OrderBy2["LockManagers"] = "lockManagers";
  Lock_OrderBy2["MaxKeysPerAddress"] = "maxKeysPerAddress";
  Lock_OrderBy2["MaxNumberOfKeys"] = "maxNumberOfKeys";
  Lock_OrderBy2["Name"] = "name";
  Lock_OrderBy2["NumberOfReceipts"] = "numberOfReceipts";
  Lock_OrderBy2["Price"] = "price";
  Lock_OrderBy2["ReferrerFees"] = "referrerFees";
  Lock_OrderBy2["Symbol"] = "symbol";
  Lock_OrderBy2["TokenAddress"] = "tokenAddress";
  Lock_OrderBy2["TotalKeys"] = "totalKeys";
  Lock_OrderBy2["Version"] = "version";
  return Lock_OrderBy2;
})(Lock_OrderBy || {});
var OrderDirection = /* @__PURE__ */ ((OrderDirection2) => {
  OrderDirection2["Asc"] = "asc";
  OrderDirection2["Desc"] = "desc";
  return OrderDirection2;
})(OrderDirection || {});
var AllLocksDocument = lib_default`
    query allLocks($first: Int = 1, $skip: Int, $where: Lock_filter, $orderBy: Lock_orderBy, $orderDirection: OrderDirection, $referrerFeeSkip: Int = 0) {
  locks(
    first: $first
    skip: $skip
    where: $where
    orderBy: $orderBy
    orderDirection: $orderDirection
  ) {
    id
    address
    name
    expirationDuration
    tokenAddress
    symbol
    price
    lockManagers
    version
    maxNumberOfKeys
    maxKeysPerAddress
    createdAtBlock
    totalKeys
    referrerFees(skip: $referrerFeeSkip) {
      id
      referrer
      fee
    }
  }
}
    `;
var AllKeysDocument = lib_default`
    query AllKeys($first: Int = 1, $skip: Int, $where: Key_filter, $orderBy: Key_orderBy, $orderDirection: OrderDirection) {
  keys(
    first: $first
    skip: $skip
    where: $where
    orderBy: $orderBy
    orderDirection: $orderDirection
  ) {
    id
    lock {
      id
      address
      name
      expirationDuration
      tokenAddress
      symbol
      price
      lockManagers
      version
      maxNumberOfKeys
      maxKeysPerAddress
      createdAtBlock
      totalKeys
    }
    tokenId
    owner
    manager
    expiration
    tokenURI
    createdAtBlock
    cancelled
    transactionsHash
  }
}
    `;
var AllReceiptsDocument = lib_default`
    query AllReceipts($first: Int = 100, $skip: Int, $where: Receipt_filter, $orderBy: Receipt_orderBy, $orderDirection: OrderDirection) {
  receipts(
    first: $first
    skip: $skip
    where: $where
    orderBy: $orderBy
    orderDirection: $orderDirection
  ) {
    id
    receiptNumber
    timestamp
    sender
    payer
    lockAddress
    tokenAddress
    gasTotal
    amountTransferred
  }
}
    `;
var AllLocksWithKeysDocument = lib_default`
    query allLocksWithKeys($first: Int = 1, $skip: Int, $where: Lock_filter, $keyFilter: Key_filter, $orderBy: Lock_orderBy, $keyOrderBy: Key_orderBy, $orderDirection: OrderDirection) {
  locks(where: $where, orderBy: $orderBy, orderDirection: $orderDirection) {
    id
    address
    name
    expirationDuration
    tokenAddress
    symbol
    price
    lockManagers
    version
    maxNumberOfKeys
    maxKeysPerAddress
    createdAtBlock
    totalKeys
    keys(where: $keyFilter, orderBy: $keyOrderBy, first: $first, skip: $skip) {
      id
      tokenId
      owner
      manager
      expiration
      tokenURI
      createdAtBlock
      cancelled
      transactionsHash
    }
  }
}
    `;
var defaultWrapper = (action, _operationName, _operationType) => action();
function getSdk(client, withWrapper = defaultWrapper) {
  return {
    allLocks(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(AllLocksDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "allLocks", "query");
    },
    AllKeys(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(AllKeysDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "AllKeys", "query");
    },
    AllReceipts(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(AllReceiptsDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "AllReceipts", "query");
    },
    allLocksWithKeys(variables, requestHeaders) {
      return withWrapper((wrappedRequestHeaders) => client.request(AllLocksWithKeysDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "allLocksWithKeys", "query");
    }
  };
}

// src/subgraph/index.ts
import { GraphQLClient } from "graphql-request";
var SubgraphService = class {
  constructor(networks2) {
    this.networks = networks2 || networks;
  }
  createSdk(networkId = 1) {
    const network = this.networks[networkId];
    const client = new GraphQLClient(network.subgraph.endpointV2);
    const sdk = getSdk(client);
    return sdk;
  }
  /**
   * Get locks from multiple networks. By default, all networks will be queried.
   * If you want to query only specific network, you can pass options as the second parameter with network ids array.
   * ```ts
   * const service = new SubgraphService()
   * const locksOnMainnetAndGoerli = await service.locks({ first: 100, skip: 50, where: {}}, { networks: [1, 5] })
   * const locksOnAllNetworks = await service.locks({ first: 1000 })
   * ```
   */
  async locks(variables, options) {
    const networks2 = options?.networks?.map((item) => this.networks[item]) || Object.values(this.networks).filter((item) => item.id !== 31337);
    const items = await Promise.all(
      networks2.map(async (config) => {
        try {
          const sdk = this.createSdk(config.id);
          const results = await sdk.allLocks(variables);
          return results.locks.map((item) => ({
            ...item,
            network: config.id
          }));
        } catch (error) {
          console.error(error);
          return [];
        }
      })
    );
    return items.flat();
  }
  /**
   * Get locks with keys from multiple networks. By default, all networks will be queried.
   * If you want to query only specific network, you can pass options as the second parameter with network ids array.
   * ```ts
   * const service = new SubgraphService()
   * const locksKeysOnMainnetAndGoerli = await service.locksKeys({ first: 100, skip: 50, where: {}}, { networks: [1, 5] })
   * const locksKeysOnAllNetworks = await service.locksKeys({ first: 1000 })
   * ```
   */
  async locksKeys(variables, options) {
    const networks2 = options?.networks?.map((item) => this.networks[item]) || Object.values(this.networks).filter((item) => item.id !== 31337);
    const items = await Promise.all(
      networks2.map(async (config) => {
        try {
          const sdk = this.createSdk(config.id);
          const results = await sdk.allLocksWithKeys(variables);
          return results.locks.map((item) => ({
            ...item,
            network: config.id
          }));
        } catch (error) {
          console.error(error);
          return [];
        }
      })
    );
    return items.flat();
  }
  /**
   * Get a single lock on a network. This is a helper provided on top of locks.
   */
  async lock(variables, options) {
    const locks = await this.locks(variables, {
      networks: [options.network]
    });
    return locks?.[0];
  }
  /**
   * Get keys and associated lock data from multiple networks. By default, all networks will be queried.
   * If you want to query only specific network, you can pass options as the second parameter with network ids array.
   * ```ts
   * const service = new SubgraphService()
   * const keysOnMainnetAndGoerli = await service.keys({ first: 100, skip: 50, where: {}}, { networks: [1, 5] })
   * const keysOnAllNetworks = await service.keys({ first: 1000 })
   * ```
   */
  async keys(variables, options) {
    const networks2 = options?.networks?.map((item) => this.networks[item]) || Object.values(this.networks).filter((item) => item.id !== 31337);
    const items = await Promise.all(
      networks2.map(async (config) => {
        try {
          const sdk = this.createSdk(config.id);
          const results = await sdk.AllKeys(variables);
          return results.keys.map((item) => ({
            ...item,
            network: config.id
          }));
        } catch (error) {
          console.error(error);
          return [];
        }
      })
    );
    return items.flat();
  }
  /**
   * Get a single key on a network. This is a helper provided on top of keys.
   */
  async key(variables, options) {
    const keys = await this.keys(variables, { networks: [options.network] });
    return keys?.[0];
  }
  /** Get list or receipts from multiple networks */
  async receipts(variables, options) {
    const networks2 = options?.networks?.map((item) => this.networks[item]) || Object.values(this.networks).filter((item) => item.id !== 31337);
    const items = await Promise.all(
      networks2.map(async (config) => {
        try {
          const sdk = this.createSdk(config.id);
          const results = await sdk.AllReceipts(variables);
          return results.receipts.map((item) => ({
            ...item,
            network: config.id
          }));
        } catch (error) {
          console.error(error);
          return [];
        }
      })
    );
    return items.flat();
  }
  /** Get a single receipt for a specific network */
  async receipt(variables, options) {
    const receipts = await this.receipts(variables, {
      networks: [options.network]
    });
    return receipts?.[0];
  }
};

// src/KeyManager.ts
import { ethers as ethers12 } from "ethers";
var KeyManagerAbi = [
  "function transfer(address lock, uint256 token, address owner, uint256 deadline, bytes transferCode)",
  "function locksmiths(address user) view returns (bool)"
];
var TransferTypes = {
  Transfer: [
    { name: "lock", type: "address" },
    { name: "token", type: "uint256" },
    { name: "owner", type: "address" },
    { name: "deadline", type: "uint256" }
  ]
};
var KeyManager = class {
  constructor(networks2) {
    this.networks = networks2 || networks;
  }
  isSigner(network, signer) {
    const provider = this.providerForNetwork(network);
    const KeyManagerContract = this.getContract({ network });
    return KeyManagerContract.locksmiths(signer);
  }
  providerForNetwork(network) {
    if (!this.networks[network]) {
      throw new Error(`Missing config for ${network}`);
    }
    return new ethers12.providers.JsonRpcBatchProvider(
      this.networks[network].provider,
      network
    );
  }
  getDomain(network) {
    const networkConfig = this.networks[network];
    const domain = {
      name: "KeyManager",
      version: "1",
      chainId: networkConfig.id,
      verifyingContract: networkConfig.keyManagerAddress
    };
    return domain;
  }
  /**
   * This function returns the KeyManager contract for a given network.
   */
  getContract({ network, signer }) {
    const networkConfig = this.networks[network];
    const keyManagerContractAddress = networkConfig.keyManagerAddress;
    if (!keyManagerContractAddress) {
      throw new Error("No key manager contract address found for network");
    }
    const provider = this.providerForNetwork(network);
    const KeyManagerContract = new ethers12.Contract(
      keyManagerContractAddress,
      KeyManagerAbi,
      provider
    );
    if (signer) {
      return KeyManagerContract.connect(signer);
    }
    return KeyManagerContract;
  }
  /**
   * This function creates a transfer signature.
   */
  async createTransferSignature({
    params,
    signer,
    network
  }) {
    const domain = this.getDomain(network);
    const signature = await signer._signTypedData(domain, TransferTypes, params);
    return signature;
  }
  /**
   * This function transfers a key given a transfer signature.
   */
  async transfer({
    network,
    params: { lock, token, owner, deadline, transferSignature },
    signer
  }) {
    const KeyManagerContract = this.getContract({ network, signer });
    const tx = await KeyManagerContract.transfer(
      lock,
      token,
      owner,
      deadline,
      transferSignature
    );
    return tx;
  }
  /**
   * This function checks if a transfer is possible.
   */
  async isTransferPossible({
    network,
    params: { lock, token, owner, deadline, transferSignature },
    signer
  }) {
    const KeyManagerContract = this.getContract({ network, signer });
    const tx = await KeyManagerContract.callStatic.transfer(
      lock,
      token,
      owner,
      deadline,
      transferSignature
    );
    return tx;
  }
  /**
   * This function creates a wallet address from a lock address and an email address.
   */
  createTransferAddress({ params }) {
    const item = {
      email: params.email.trim().toLowerCase(),
      lock: params.lockAddress.trim().toLowerCase()
    };
    return ethers12.utils.id(JSON.stringify(item)).slice(0, 42);
  }
  /**
   * Return signer for the transfer signature provided in the params
   */
  getSignerForTransferSignature({
    params: { lock, token, owner, deadline, transferSignature },
    network
  }) {
    const domain = this.getDomain(network);
    const recoveredAddress = ethers12.utils.verifyTypedData(
      domain,
      TransferTypes,
      { lock, token, owner, deadline },
      transferSignature
    );
    return recoveredAddress;
  }
};
export {
  CapturePurchaseRequestPurchaseTypeEnum,
  Configuration,
  DefaultApi,
  DefaultApiAxiosParamCreator,
  DefaultApiFactory,
  DefaultApiFp,
  GetSubscription200ResponseSubscriptionsInnerTypeEnum,
  KeyManager,
  KeyManagerAbi,
  Key_OrderBy as KeyOrderBy,
  Lock_OrderBy as LockOrderBy,
  LocksmithService,
  Configuration as LocksmithServiceConfiguration,
  OrderDirection,
  SubgraphService,
  TransferTypes,
  TransferWithAuthorizationTypes,
  WalletService,
  Web3Service,
  approveTransfer,
  getAllowance,
  getCurrentProvider,
  getErc20BalanceForAddress,
  getErc20Decimals,
  getErc20TokenSymbol,
  getWeb3Provider,
  recoverTransferAuthorization,
  signTransferAuthorization,
  transferWithAuthorization
};
