"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const bignumber_js_1 = require("bignumber.js");
const typedi_1 = require("typedi");
const package_json_1 = require("../../package.json");
const dto_1 = require("../dto");
const service_1 = require("../service");
const EvmArchiveLoadBalancerRpc_1 = require("../service/rpc/evm/EvmArchiveLoadBalancerRpc");
const NativeEvmArchiveLoadBalancerRpc_1 = require("../service/rpc/evm/NativeEvmArchiveLoadBalancerRpc");
const TronLoadBalancerRpc_1 = require("../service/rpc/evm/TronLoadBalancerRpc");
const TronRpc_1 = require("../service/rpc/evm/TronRpc");
const EosLoadBalancerRpc_1 = require("../service/rpc/other/EosLoadBalancerRpc");
const EosRpc_1 = require("../service/rpc/other/EosRpc");
const SolanaLoadBalancerRpc_1 = require("../service/rpc/other/SolanaLoadBalancerRpc");
const XrpLoadBalancerRpc_1 = require("../service/rpc/other/XrpLoadBalancerRpc");
const UtxoLoadBalancerRpc_1 = require("../service/rpc/utxo/UtxoLoadBalancerRpc");
const constant_1 = require("./constant");
const di_tokens_1 = require("./di.tokens");
const EvmBeaconArchiveLoadBalancerRpc_1 = require("../service/rpc/evm/EvmBeaconArchiveLoadBalancerRpc");
const UtxoLoadBalancerRpcEstimateFee_1 = require("../service/rpc/utxo/UtxoLoadBalancerRpcEstimateFee");
const UtxoRpcEstimateFee_1 = require("../service/rpc/utxo/UtxoRpcEstimateFee");
const BnbLoadBalancerRpc_1 = require("../service/rpc/other/BnbLoadBalancerRpc");
exports.Utils = {
    getRpc: (id, config) => {
        const { network } = config;
        if ((0, dto_1.isBnbLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(BnbLoadBalancerRpc_1.BnbLoadBalancerRpc);
        }
        if ((0, dto_1.isUtxoLoadBalancerEstimateFeeNetwork)(network)) {
            return typedi_1.Container.of(id).get(UtxoLoadBalancerRpcEstimateFee_1.UtxoLoadBalancerRpcEstimateFee);
        }
        if ((0, dto_1.isUtxoEstimateFeeNetwork)(network)) {
            return typedi_1.Container.of(id).get(UtxoRpcEstimateFee_1.UtxoRpcEstimateFee);
        }
        if ((0, dto_1.isUtxoLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(UtxoLoadBalancerRpc_1.UtxoLoadBalancerRpc);
        }
        if ((0, dto_1.isNativeEvmLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(NativeEvmArchiveLoadBalancerRpc_1.NativeEvmArchiveLoadBalancerRpc);
        }
        if ((0, dto_1.isEvmArchiveNonArchiveBeaconLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(EvmBeaconArchiveLoadBalancerRpc_1.EvmBeaconArchiveLoadBalancerRpc);
        }
        if ((0, dto_1.isEvmArchiveNonArchiveLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(EvmArchiveLoadBalancerRpc_1.EvmArchiveLoadBalancerRpc);
        }
        if ((0, dto_1.isEvmLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(service_1.EvmLoadBalancerRpc);
        }
        if ((0, dto_1.isEvmBasedNetwork)(network)) {
            return typedi_1.Container.of(id).get(service_1.EvmRpc);
        }
        if ((0, dto_1.isUtxoBasedNetwork)(network)) {
            return typedi_1.Container.of(id).get(service_1.UtxoRpc);
        }
        if ((0, dto_1.isXrpNetwork)(network)) {
            return typedi_1.Container.of(id).get(XrpLoadBalancerRpc_1.XrpLoadBalancerRpc);
        }
        if ((0, dto_1.isSolanaNetwork)(network)) {
            return typedi_1.Container.of(id).get(SolanaLoadBalancerRpc_1.SolanaLoadBalancerRpc);
        }
        if ((0, dto_1.isTronLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(TronLoadBalancerRpc_1.TronLoadBalancerRpc);
        }
        if ((0, dto_1.isTronNetwork)(network)) {
            return typedi_1.Container.of(id).get(TronRpc_1.TronRpc);
        }
        if ((0, dto_1.isEosLoadBalancerNetwork)(network)) {
            return typedi_1.Container.of(id).get(EosLoadBalancerRpc_1.EosLoadBalancerRpc);
        }
        if ((0, dto_1.isEosNetwork)(network)) {
            return typedi_1.Container.of(id).get(EosRpc_1.EosRpc);
        }
        console.warn(`RPC Network ${network} is not supported.`);
        return typedi_1.Container.of(id).get(service_1.GenericRpc);
    },
    getRpcListUrl: (network) => {
        const mappedNetwork = exports.Utils.mapRpcListUrl(network);
        return [
            `https://rpc.tatum.io/${mappedNetwork}/list.json`,
            `https://rpc.tatum.io/${mappedNetwork}-archive/list.json`,
        ];
    },
    mapRpcListUrl: (network) => {
        const mappedNetwork = dto_1.MAPPED_NETWORK[network];
        return mappedNetwork ?? network;
    },
    getStatusPayload: (network) => {
        if ((0, dto_1.isUtxoBasedNetwork)(network)) {
            return {
                jsonrpc: '2.0',
                method: 'getblockcount',
                params: [],
                id: 1,
            };
        }
        if ((0, dto_1.isEvmBasedNetwork)(network) || (0, dto_1.isTronNetwork)(network)) {
            return {
                jsonrpc: '2.0',
                method: 'eth_blockNumber',
                params: [],
                id: 1,
            };
        }
        if ((0, dto_1.isSolanaNetwork)(network)) {
            return {
                jsonrpc: '2.0',
                method: 'getBlockHeight',
                params: [],
                id: 1,
            };
        }
        if ((0, dto_1.isBnbLoadBalancerNetwork)(network)) {
            return {
                jsonrpc: '2.0',
                method: 'block',
                params: {},
                id: 1,
            };
        }
        if ((0, dto_1.isEosNetwork)(network)) {
            return null;
        }
        throw new Error(`Network ${network} is not supported.`);
    },
    getStatusUrl(network, url) {
        if ((0, dto_1.isEosNetwork)(network)) {
            return `${url}${constant_1.Constant.EOS_PREFIX}get_info`;
        }
        if ((0, dto_1.isSameGetBlockNetwork)(network)) {
            return url;
        }
        if ((0, dto_1.isBnbLoadBalancerNetwork)(network)) {
            return url;
        }
        throw new Error(`Network ${network} is not supported.`);
    },
    parseStatusPayload: (network, response) => {
        if ((0, dto_1.isSameGetBlockNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response.result || -1).toNumber();
        }
        if ((0, dto_1.isBnbLoadBalancerNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response.result.block.header.height || -1).toNumber();
        }
        if ((0, dto_1.isEosNetwork)(network)) {
            return new bignumber_js_1.BigNumber(response.head_block_num || -1).toNumber();
        }
        throw new Error(`Network ${network} is not supported.`);
    },
    isResponseOk: (network, response) => {
        if ((0, dto_1.isEosNetwork)(network)) {
            return response.head_block_num !== undefined;
        }
        if ((0, dto_1.isBnbLoadBalancerNetwork)(network)) {
            return response.result.block.header.height !== undefined;
        }
        if ((0, dto_1.isSameGetBlockNetwork)(network)) {
            return response.result !== undefined;
        }
        throw new Error(`Network ${network} is not supported.`);
    },
    mapNotificationChainToNetwork: (chain) => {
        switch (chain) {
            case dto_1.AddressEventNotificationChain.BTC:
                return dto_1.Network.BITCOIN;
            case dto_1.AddressEventNotificationChain.BCH:
                return dto_1.Network.BITCOIN_CASH;
            case dto_1.AddressEventNotificationChain.LTC:
                return dto_1.Network.LITECOIN;
            case dto_1.AddressEventNotificationChain.DOGE:
                return dto_1.Network.DOGECOIN;
            case dto_1.AddressEventNotificationChain.ETH:
                return dto_1.Network.ETHEREUM;
            case dto_1.AddressEventNotificationChain.MATIC:
                return dto_1.Network.POLYGON;
            case dto_1.AddressEventNotificationChain.CELO:
                return dto_1.Network.CELO;
            case dto_1.AddressEventNotificationChain.SOL:
                return dto_1.Network.SOLANA;
            case dto_1.AddressEventNotificationChain.XRP:
                return dto_1.Network.XRP;
            case dto_1.AddressEventNotificationChain.BSC:
                return dto_1.Network.BINANCE_SMART_CHAIN;
            case dto_1.AddressEventNotificationChain.TRON:
                return dto_1.Network.TRON;
            case dto_1.AddressEventNotificationChain.KLAY:
                return dto_1.Network.KLAYTN;
            case dto_1.AddressEventNotificationChain.EON:
                return dto_1.Network.HORIZEN_EON;
            case dto_1.AddressEventNotificationChain.CHZ:
                return dto_1.Network.CHILIZ;
            default:
                throw new Error(`Chain ${chain} is not supported.`);
        }
    },
    mapNetworkToNotificationChain: (network) => {
        switch (network) {
            case dto_1.Network.BITCOIN:
            case dto_1.Network.BITCOIN_TESTNET:
                return dto_1.AddressEventNotificationChain.BTC;
            case dto_1.Network.BITCOIN_CASH:
            case dto_1.Network.BITCOIN_CASH_TESTNET:
                return dto_1.AddressEventNotificationChain.BCH;
            case dto_1.Network.LITECOIN:
            case dto_1.Network.LITECOIN_TESTNET:
                return dto_1.AddressEventNotificationChain.LTC;
            case dto_1.Network.DOGECOIN:
            case dto_1.Network.DOGECOIN_TESTNET:
                return dto_1.AddressEventNotificationChain.DOGE;
            case dto_1.Network.ETHEREUM:
            case dto_1.Network.ETHEREUM_SEPOLIA:
            case dto_1.Network.ETHEREUM_GOERLI:
                return dto_1.AddressEventNotificationChain.ETH;
            case dto_1.Network.POLYGON:
            case dto_1.Network.POLYGON_MUMBAI:
                return dto_1.AddressEventNotificationChain.MATIC;
            case dto_1.Network.CELO:
            case dto_1.Network.CELO_ALFAJORES:
                return dto_1.AddressEventNotificationChain.CELO;
            case dto_1.Network.SOLANA:
            case dto_1.Network.SOLANA_DEVNET:
                return dto_1.AddressEventNotificationChain.SOL;
            case dto_1.Network.XRP:
            case dto_1.Network.XRP_TESTNET:
                return dto_1.AddressEventNotificationChain.XRP;
            case dto_1.Network.BINANCE_SMART_CHAIN:
            case dto_1.Network.BINANCE_SMART_CHAIN_TESTNET:
                return dto_1.AddressEventNotificationChain.BSC;
            case dto_1.Network.TRON:
            case dto_1.Network.TRON_SHASTA:
                return dto_1.AddressEventNotificationChain.TRON;
            case dto_1.Network.KLAYTN:
            case dto_1.Network.KLAYTN_BAOBAB:
                return dto_1.AddressEventNotificationChain.KLAY;
            case dto_1.Network.TEZOS:
                return dto_1.AddressEventNotificationChain.TEZOS;
            case dto_1.Network.HORIZEN_EON:
                return dto_1.AddressEventNotificationChain.EON;
            case dto_1.Network.CHILIZ:
                return dto_1.AddressEventNotificationChain.CHZ;
            default:
                throw new Error(`Network ${network} is not supported.`);
        }
    },
    delay: (t) => new Promise((resolve) => setTimeout(resolve, t)),
    retryWithTimeout: async (action, timeoutInMs = 10000, delayInMs = 500) => {
        const startTime = Date.now();
        let lastError = null;
        while (timeoutInMs + startTime > Date.now()) {
            try {
                const result = await action();
                if (result === null || result === undefined) {
                    throw new Error('Null result');
                }
                return result;
            }
            catch (e) {
                lastError = e;
                await exports.Utils.delay(delayInMs);
            }
        }
        throw lastError ?? new Error('Retry timeout failed');
    },
    fetchWithTimeout: async (url, containerId, config, timeout = 5000) => {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        const start = Date.now();
        const response = await fetch(url, {
            ...config,
            signal: controller.signal,
            headers: exports.Utils.getHeaders(containerId),
        });
        const responseTime = Date.now() - start;
        clearTimeout(id);
        return { responseTime, response };
    },
    headersToJson(headers) {
        const headersObj = {};
        headers.forEach((value, key) => {
            headersObj[key] = value;
        });
        return JSON.stringify(headersObj);
    },
    getHeaders: (id) => {
        const basicHeaders = exports.Utils.getBasicHeaders(id);
        basicHeaders.set('Content-Type', 'application/json');
        return basicHeaders;
    },
    getBasicHeaders: (id) => {
        const config = typedi_1.Container.of(id).get(di_tokens_1.CONFIG);
        const headers = new Headers({
            'x-ttm-sdk-version': package_json_1.version,
            'x-ttm-sdk-product': 'JS',
            'x-ttm-sdk-debug': `${config.verbose}`,
        });
        if (config.apiKey) {
            if (config.version === service_1.ApiVersion.V3 && config.apiKey.v3) {
                headers.append('x-api-key', config.apiKey.v3);
            }
            else if (config.version === service_1.ApiVersion.V4 && config.apiKey.v4) {
                headers.append('x-api-key', config.apiKey.v4);
            }
        }
        return headers;
    },
    padWithZero: (data, length = 64) => data.replace('0x', '').padStart(length, '0'),
    camelToSnakeCase: (str) => str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`),
    convertObjCamelToSnake: (obj) => {
        const snakeObj = {};
        for (const [key, value] of Object.entries(obj)) {
            const snakeKey = exports.Utils.camelToSnakeCase(key);
            if (value instanceof bignumber_js_1.BigNumber) {
                snakeObj[snakeKey] = value.toNumber();
            }
            else if (typeof value === 'object' && value !== null) {
                snakeObj[snakeKey] = exports.Utils.convertObjCamelToSnake(value);
            }
            else {
                snakeObj[snakeKey] = value;
            }
        }
        return snakeObj;
    },
    getClient: (id, network) => {
        switch (network) {
            case dto_1.Network.BITCOIN:
            case dto_1.Network.BITCOIN_TESTNET:
                return new service_1.Bitcoin(id);
            case dto_1.Network.LITECOIN:
            case dto_1.Network.LITECOIN_TESTNET:
                return new service_1.Litecoin(id);
            case dto_1.Network.DOGECOIN:
            case dto_1.Network.DOGECOIN_TESTNET:
                return new service_1.Dogecoin(id);
            case dto_1.Network.BITCOIN_CASH:
            case dto_1.Network.BITCOIN_CASH_TESTNET:
                return new service_1.BitcoinCash(id);
            case dto_1.Network.ZCASH:
            case dto_1.Network.ZCASH_TESTNET:
                return new service_1.ZCash(id);
            case dto_1.Network.ETHEREUM:
            case dto_1.Network.ETHEREUM_SEPOLIA:
            case dto_1.Network.ETHEREUM_GOERLI:
            case dto_1.Network.ETHEREUM_HOLESKY:
                return new service_1.Ethereum(id);
            case dto_1.Network.ETHEREUM_CLASSIC:
                return new service_1.EthereumClassic(id);
            case dto_1.Network.ARBITRUM_NOVA:
            case dto_1.Network.ARBITRUM_NOVA_TESTNET:
                return new service_1.ArbitrumNova(id);
            case dto_1.Network.ARBITRUM_ONE:
                return new service_1.ArbitrumOne(id);
            case dto_1.Network.AURORA:
            case dto_1.Network.AURORA_TESTNET:
                return new service_1.Aurora(id);
            case dto_1.Network.AVALANCHE_C:
            case dto_1.Network.AVALANCHE_C_TESTNET:
            case dto_1.Network.AVALANCHE_P:
            case dto_1.Network.AVALANCHE_P_TESTNET:
            case dto_1.Network.AVALANCHE_X:
            case dto_1.Network.AVALANCHE_X_TESTNET:
                return new service_1.AvalancheC(id);
            case dto_1.Network.BINANCE_SMART_CHAIN:
            case dto_1.Network.BINANCE_SMART_CHAIN_TESTNET:
                return new service_1.BinanceSmartChain(id);
            case dto_1.Network.CELO:
            case dto_1.Network.CELO_ALFAJORES:
                return new service_1.Celo(id);
            case dto_1.Network.CRONOS:
            case dto_1.Network.CRONOS_TESTNET:
                return new service_1.Cronos(id);
            case dto_1.Network.FANTOM:
            case dto_1.Network.FANTOM_TESTNET:
                return new service_1.Fantom(id);
            case dto_1.Network.GNOSIS:
            case dto_1.Network.GNOSIS_TESTNET:
                return new service_1.Gnosis(id);
            case dto_1.Network.HARMONY_ONE_SHARD_0:
            case dto_1.Network.HARMONY_ONE_TESTNET_SHARD_0:
                return new service_1.HarmonyOne(id);
            case dto_1.Network.HAQQ:
            case dto_1.Network.HAQQ_TESTNET:
                return new service_1.Haqq(id);
            case dto_1.Network.FLARE:
            case dto_1.Network.FLARE_COSTON:
            case dto_1.Network.FLARE_COSTON_2:
            case dto_1.Network.FLARE_SONGBIRD:
                return new service_1.Flare(id);
            case dto_1.Network.KLAYTN:
            case dto_1.Network.KLAYTN_BAOBAB:
                return new service_1.Klaytn(id);
            case dto_1.Network.KUCOIN:
            case dto_1.Network.KUCOIN_TESTNET:
                return new service_1.Kucoin(id);
            case dto_1.Network.OASIS:
            case dto_1.Network.OASIS_TESTNET:
                return new service_1.Oasis(id);
            case dto_1.Network.OPTIMISM:
            case dto_1.Network.OPTIMISM_TESTNET:
                return new service_1.Optimism(id);
            case dto_1.Network.PALM:
            case dto_1.Network.PALM_TESTNET:
                return new service_1.Palm(id);
            case dto_1.Network.POLYGON:
            case dto_1.Network.POLYGON_MUMBAI:
                return new service_1.Polygon(id);
            case dto_1.Network.VECHAIN:
            case dto_1.Network.VECHAIN_TESTNET:
                return new service_1.Vechain(id);
            case dto_1.Network.XDC:
            case dto_1.Network.XDC_TESTNET:
                return new service_1.Xdc(id);
            case dto_1.Network.XRP:
            case dto_1.Network.XRP_TESTNET:
                return new service_1.Xrp(id);
            case dto_1.Network.SOLANA:
            case dto_1.Network.SOLANA_DEVNET:
                return new service_1.Solana(id);
            case dto_1.Network.TRON:
            case dto_1.Network.TRON_SHASTA:
                return new service_1.Tron(id);
            case dto_1.Network.TEZOS:
                return new service_1.Tezos(id);
            case dto_1.Network.HORIZEN_EON:
            case dto_1.Network.HORIZEN_EON_GOBI:
                return new service_1.HorizenEon(id);
            case dto_1.Network.EOS:
            case dto_1.Network.EOS_TESTNET:
                return new service_1.Eos(id);
            case dto_1.Network.CHILIZ:
                return new service_1.Chiliz(id);
            case dto_1.Network.BNB:
                return new service_1.Bnb(id);
            default:
                return new service_1.FullSdk(id);
        }
    },
    log: ({ id, message, data, mode }) => {
        const config = typedi_1.Container.of(id).get(di_tokens_1.CONFIG);
        if (config.verbose) {
            if (data) {
                if (mode === 'table') {
                    console.table(data);
                }
                else {
                    console.debug(new Date().toISOString(), message, data);
                }
            }
            else {
                console.debug(new Date().toISOString(), message);
            }
        }
    },
    prepareRpcCall: (method, params, id = 1) => {
        return {
            jsonrpc: '2.0',
            id,
            method,
            params,
        };
    },
    deepMerge(target, source) {
        const isObject = (obj) => typeof obj === 'object' && obj !== null;
        if (!isObject(target) || !isObject(source)) {
            return source;
        }
        const output = { ...target };
        Object.keys(source).forEach((key) => {
            const targetValue = output[key];
            const sourceValue = source[key];
            if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
                output[key] = [...targetValue, ...sourceValue];
            }
            else if (isObject(targetValue) && isObject(sourceValue)) {
                output[key] = exports.Utils.deepMerge(targetValue, sourceValue);
            }
            else {
                output[key] = sourceValue;
            }
        });
        return output;
    },
    getV3RpcUrl: (config, path) => {
        const { apiKey, rpc, network } = config;
        if (apiKey) {
            const url = rpc?.nodes?.[0].url ||
                `${constant_1.Constant.TATUM_API_URL.V3}blockchain/node/${network}/${apiKey.v3 ? apiKey.v3 : apiKey.v4}`;
            return url.concat(path || '');
        }
        return rpc?.nodes?.[0].url || `${constant_1.Constant.TATUM_API_URL.V3}blockchain/node/${network}`.concat(path || '');
    },
    addQueryParams: (basePath, queryParams) => {
        let queryString = '';
        if (queryParams) {
            const query = exports.Utils.convertObjCamelToSnake(queryParams);
            const params = [];
            Object.entries(query).forEach(([key, value]) => {
                if (Array.isArray(value)) {
                    value.forEach(val => {
                        params.push(`${encodeURIComponent(key)}=${encodeURIComponent(val)}`);
                    });
                }
                else {
                    params.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
                }
            });
            if (params.length > 0) {
                queryString = '?' + params.join('&');
            }
        }
        return basePath + queryString;
    },
};
//# sourceMappingURL=util.shared.js.map